{"version":3,"file":"app.js","sources":["../node_modules/@lwc/engine-dom/dist/index.js","../src/modules/src/modules/lwc/app/app.ts"],"sourcesContent":["/**\n * Copyright (c) 2025 Salesforce, Inc.\n */\n/**\n * Copyright (c) 2025 Salesforce, Inc.\n */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n *\n * @param value\n * @param msg\n */\nfunction invariant(value, msg) {\n    if (!value) {\n        throw new Error(`Invariant Violation: ${msg}`);\n    }\n}\n/**\n *\n * @param value\n * @param msg\n */\nfunction isTrue$1(value, msg) {\n    if (!value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\n/**\n *\n * @param value\n * @param msg\n */\nfunction isFalse$1(value, msg) {\n    if (value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\n/**\n *\n * @param msg\n */\nfunction fail(msg) {\n    throw new Error(msg);\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fail: fail,\n    invariant: invariant,\n    isFalse: isFalse$1,\n    isTrue: isTrue$1\n});\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { \n/** Detached {@linkcode Object.assign}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign MDN Reference}. */\nassign, \n/** Detached {@linkcode Object.create}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create MDN Reference}. */\ncreate, \n/** Detached {@linkcode Object.defineProperties}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties MDN Reference}. */\ndefineProperties, \n/** Detached {@linkcode Object.defineProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty MDN Reference}. */\ndefineProperty, \n/** Detached {@linkcode Object.entries}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries MDN Reference}. */\nentries, \n/** Detached {@linkcode Object.freeze}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze MDN Reference}. */\nfreeze, \n/** Detached {@linkcode Object.getOwnPropertyDescriptor}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor MDN Reference}. */\ngetOwnPropertyDescriptor: getOwnPropertyDescriptor$1, \n/** Detached {@linkcode Object.getOwnPropertyDescriptors}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors MDN Reference}. */\ngetOwnPropertyDescriptors, \n/** Detached {@linkcode Object.getOwnPropertyNames}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames MDN Reference}. */\ngetOwnPropertyNames: getOwnPropertyNames$1, \n/** Detached {@linkcode Object.getOwnPropertySymbols}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols MDN Reference}. */\ngetOwnPropertySymbols: getOwnPropertySymbols$1, \n/** Detached {@linkcode Object.getPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf MDN Reference}. */\ngetPrototypeOf: getPrototypeOf$1, \n/** Detached {@linkcode Object.hasOwnProperty}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty MDN Reference}. */\nhasOwnProperty: hasOwnProperty$1, \n/** Detached {@linkcode Object.isFrozen}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen MDN Reference}. */\nisFrozen, \n/** Detached {@linkcode Object.keys}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys MDN Reference}. */\nkeys, \n/** Detached {@linkcode Object.seal}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal MDN Reference}. */\nseal, \n/** Detached {@linkcode Object.setPrototypeOf}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf MDN Reference}. */\nsetPrototypeOf, } = Object;\nconst { \n/** Detached {@linkcode Array.isArray}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray MDN Reference}. */\nisArray: isArray$1, \n/** Detached {@linkcode Array.from}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from MDN Reference}. */\nfrom: ArrayFrom, } = Array;\n// For some reason, JSDoc don't get picked up for multiple renamed destructured constants (even\n// though it works fine for one, e.g. isArray), so comments for these are added to the export\n// statement, rather than this declaration.\nconst { copyWithin: ArrayCopyWithin, every: ArrayEvery, fill: ArrayFill, filter: ArrayFilter, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush$1, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, // Weird anomaly!\n } = Array.prototype;\n// The type of the return value of Array.prototype.every is `this is T[]`. However, once this\n// Array method is pulled out of the prototype, the function is now referencing `this` where\n// `this` is meaningless, resulting in a TypeScript compilation error.\n//\n// Exposing this helper function is the closest we can get to preserving the usage patterns\n// of Array.prototype methods used elsewhere in the codebase.\n/**\n * Wrapper for {@linkcode Array.prototype.every} that correctly preserves the type predicate in the\n * return value; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every MDN Reference}.\n * @param arr Array to test.\n * @param predicate A function to execute for each element of the array.\n * @returns Whether all elements in the array pass the test provided by the predicate.\n */\nfunction arrayEvery(arr, predicate) {\n    return ArrayEvery.call(arr, predicate);\n}\n/** Detached {@linkcode String.fromCharCode}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode MDN Reference}. */\nconst { fromCharCode: StringFromCharCode } = String;\n// No JSDocs here - see comment for Array.prototype\nconst { charAt: StringCharAt, charCodeAt: StringCharCodeAt, replace: StringReplace, split: StringSplit, slice: StringSlice, toLowerCase: StringToLowerCase, trim: StringTrim, } = String.prototype;\n/**\n * Determines whether the argument is `undefined`.\n * @param obj Value to test\n * @returns `true` if the value is `undefined`.\n */\nfunction isUndefined$1(obj) {\n    return obj === undefined;\n}\n/**\n * Determines whether the argument is `null`.\n * @param obj Value to test\n * @returns `true` if the value is `null`.\n */\nfunction isNull(obj) {\n    return obj === null;\n}\n/**\n * Determines whether the argument is `true`.\n * @param obj Value to test\n * @returns `true` if the value is `true`.\n */\nfunction isTrue(obj) {\n    return obj === true;\n}\n/**\n * Determines whether the argument is `false`.\n * @param obj Value to test\n * @returns `true` if the value is `false`.\n */\nfunction isFalse(obj) {\n    return obj === false;\n}\n/**\n * Determines whether the argument is a boolean.\n * @param obj Value to test\n * @returns `true` if the value is a boolean.\n */\nfunction isBoolean(obj) {\n    return typeof obj === 'boolean';\n}\n/**\n * Determines whether the argument is a function.\n * @param obj Value to test\n * @returns `true` if the value is a function.\n */\n// Replacing `Function` with a narrower type that works for all our use cases is tricky...\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction isFunction$1(obj) {\n    return typeof obj === 'function';\n}\n/**\n * Determines whether the argument is an object or null.\n * @param obj Value to test\n * @returns `true` if the value is an object or null.\n */\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\n/**\n * Determines whether the argument is a string.\n * @param obj Value to test\n * @returns `true` if the value is a string.\n */\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\n/**\n * Determines whether the argument is a number.\n * @param obj Value to test\n * @returns `true` if the value is a number.\n */\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\n/** Does nothing! ðŸš€ */\nfunction noop() {\n    /* Do nothing */\n}\nconst OtS = {}.toString;\n/**\n * Converts the argument to a string, safely accounting for objects with \"null\" prototype.\n * Note that `toString(null)` returns `\"[object Null]\"` rather than `\"null\"`.\n * @param obj Value to convert to a string.\n * @returns String representation of the value.\n */\nfunction toString(obj) {\n    if (obj?.toString) {\n        // Arrays might hold objects with \"null\" prototype So using\n        // Array.prototype.toString directly will cause an error Iterate through\n        // all the items and handle individually.\n        if (isArray$1(obj)) {\n            // This behavior is slightly different from Array#toString:\n            // 1. Array#toString calls `this.join`, rather than Array#join\n            // Ex: arr = []; arr.join = () => 1; arr.toString() === 1; toString(arr) === ''\n            // 2. Array#toString delegates to Object#toString if `this.join` is not a function\n            // Ex: arr = []; arr.join = 'no'; arr.toString() === '[object Array]; toString(arr) = ''\n            // 3. Array#toString converts null/undefined to ''\n            // Ex: arr = [null, undefined]; arr.toString() === ','; toString(arr) === '[object Null],undefined'\n            // 4. Array#toString converts recursive references to arrays to ''\n            // Ex: arr = [1]; arr.push(arr, 2); arr.toString() === '1,,2'; toString(arr) throws\n            // Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString\n            return ArrayJoin.call(ArrayMap.call(obj, toString), ',');\n        }\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        // This catches null and returns \"[object Null]\". Weird, but kept for backwards compatibility.\n        return OtS.call(obj);\n    }\n    else {\n        return String(obj);\n    }\n}\n/**\n * Gets the property descriptor for the given object and property key. Similar to\n * {@linkcode Object.getOwnPropertyDescriptor}, but looks up the prototype chain.\n * @param o Value to get the property descriptor for\n * @param p Property key to get the descriptor for\n * @returns The property descriptor for the given object and property key.\n */\nfunction getPropertyDescriptor(o, p) {\n    do {\n        const d = getOwnPropertyDescriptor$1(o, p);\n        if (!isUndefined$1(d)) {\n            return d;\n        }\n        o = getPrototypeOf$1(o);\n    } while (o !== null);\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// These must be updated when the enum is updated.\n// It's a bit annoying to do have to do this manually, but this makes the file tree-shakeable,\n// passing the `verify-treeshakeable.js` test.\nconst allVersions = [\n    58 /* APIVersion.V58_244_SUMMER_23 */,\n    59 /* APIVersion.V59_246_WINTER_24 */,\n    60 /* APIVersion.V60_248_SPRING_24 */,\n    61 /* APIVersion.V61_250_SUMMER_24 */,\n    62 /* APIVersion.V62_252_WINTER_25 */,\n    63 /* APIVersion.V63_254_SPRING_25 */,\n];\nconst LOWEST_API_VERSION = allVersions[0];\n/**\n *\n * @param apiVersionFeature\n * @param apiVersion\n */\nfunction isAPIFeatureEnabled(apiVersionFeature, apiVersion) {\n    switch (apiVersionFeature) {\n        case 0 /* APIFeature.LOWERCASE_SCOPE_TOKENS */:\n        case 1 /* APIFeature.TREAT_ALL_PARSE5_ERRORS_AS_ERRORS */:\n            return apiVersion >= 59 /* APIVersion.V59_246_WINTER_24 */;\n        case 3 /* APIFeature.DISABLE_OBJECT_REST_SPREAD_TRANSFORMATION */:\n        case 4 /* APIFeature.SKIP_UNNECESSARY_REGISTER_DECORATORS */:\n        case 5 /* APIFeature.USE_COMMENTS_FOR_FRAGMENT_BOOKENDS */:\n        case 2 /* APIFeature.USE_FRAGMENTS_FOR_LIGHT_DOM_SLOTS */:\n            return apiVersion >= 60 /* APIVersion.V60_248_SPRING_24 */;\n        case 7 /* APIFeature.ENABLE_ELEMENT_INTERNALS_AND_FACE */:\n        case 6 /* APIFeature.USE_LIGHT_DOM_SLOT_FORWARDING */:\n            return apiVersion >= 61 /* APIVersion.V61_250_SUMMER_24 */;\n        case 8 /* APIFeature.ENABLE_THIS_DOT_HOST_ELEMENT */:\n        case 9 /* APIFeature.ENABLE_THIS_DOT_STYLE */:\n        case 10 /* APIFeature.TEMPLATE_CLASS_NAME_OBJECT_BINDING */:\n            return apiVersion >= 62 /* APIVersion.V62_252_WINTER_25 */;\n        case 11 /* APIFeature.ENABLE_COMPLEX_TEMPLATE_EXPRESSIONS */:\n            return apiVersion >= 63 /* APIVersion.V63_254_SPRING_25 */;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and\n * ariaGrabbed) are deprecated:\n * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes\n *\n * The above list of 46 aria attributes is consistent with the following resources:\n * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060\n * https://wicg.github.io/aom/spec/aria-reflection.html\n *\n * NOTE: If you update this list, please update test files that implicitly reference this list!\n * Searching the codebase for `aria-flowto` and `ariaFlowTo` should be good enough to find all usages.\n */\nconst AriaPropertyNames = [\n    'ariaActiveDescendant',\n    'ariaAtomic',\n    'ariaAutoComplete',\n    'ariaBusy',\n    'ariaChecked',\n    'ariaColCount',\n    'ariaColIndex',\n    'ariaColIndexText',\n    'ariaColSpan',\n    'ariaControls',\n    'ariaCurrent',\n    'ariaDescribedBy',\n    'ariaDescription',\n    'ariaDetails',\n    'ariaDisabled',\n    'ariaErrorMessage',\n    'ariaExpanded',\n    'ariaFlowTo',\n    'ariaHasPopup',\n    'ariaHidden',\n    'ariaInvalid',\n    'ariaKeyShortcuts',\n    'ariaLabel',\n    'ariaLabelledBy',\n    'ariaLevel',\n    'ariaLive',\n    'ariaModal',\n    'ariaMultiLine',\n    'ariaMultiSelectable',\n    'ariaOrientation',\n    'ariaOwns',\n    'ariaPlaceholder',\n    'ariaPosInSet',\n    'ariaPressed',\n    'ariaReadOnly',\n    'ariaRelevant',\n    'ariaRequired',\n    'ariaRoleDescription',\n    'ariaRowCount',\n    'ariaRowIndex',\n    'ariaRowIndexText',\n    'ariaRowSpan',\n    'ariaSelected',\n    'ariaSetSize',\n    'ariaSort',\n    'ariaValueMax',\n    'ariaValueMin',\n    'ariaValueNow',\n    'ariaValueText',\n    'ariaBrailleLabel',\n    'ariaBrailleRoleDescription',\n    'role',\n];\nconst { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap } = /*@__PURE__*/ (() => {\n    const AriaAttrNameToPropNameMap = create(null);\n    const AriaPropNameToAttrNameMap = create(null);\n    // Synthetic creation of all AOM property descriptors for Custom Elements\n    forEach.call(AriaPropertyNames, (propName) => {\n        const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, () => 'aria-'));\n        // These type assertions are because the map types are a 1:1 mapping of ariaX to aria-x.\n        // TypeScript knows we have one of ariaX | ariaY and one of aria-x | aria-y, and tries to\n        // prevent us from doing ariaX: aria-y, but we that it's safe.\n        AriaAttrNameToPropNameMap[attrName] = propName;\n        AriaPropNameToAttrNameMap[propName] = attrName;\n    });\n    return { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap };\n})();\n// These attributes take either an ID or a list of IDs as values.\n// This includes aria-* attributes as well as the special non-ARIA \"for\" attribute\nconst ID_REFERENCING_ATTRIBUTES_SET = /*@__PURE__*/ new Set([\n    'aria-activedescendant',\n    'aria-controls',\n    'aria-describedby',\n    'aria-details',\n    'aria-errormessage',\n    'aria-flowto',\n    'aria-labelledby',\n    'aria-owns',\n    'for',\n]);\n\n/*\n * Copyright (c) 2023, Salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst KEY__SHADOW_RESOLVER = '$shadowResolver$';\nconst KEY__SHADOW_STATIC = '$shadowStaticNode$';\nconst KEY__SHADOW_TOKEN = '$shadowToken$';\nconst KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';\nconst KEY__SCOPED_CSS = '$scoped$';\nconst KEY__NATIVE_ONLY_CSS = '$nativeOnly$';\nconst KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';\nconst KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';\nconst XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nconst XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CAMEL_REGEX = /-([a-z])/g;\n// These are HTML standard prop/attribute IDL mappings, but are not predictable based on camel/kebab-case conversion\nconst SPECIAL_PROPERTY_ATTRIBUTE_MAPPING = /*@__PURE__@*/ new Map([\n    ['accessKey', 'accesskey'],\n    ['readOnly', 'readonly'],\n    ['tabIndex', 'tabindex'],\n    ['bgColor', 'bgcolor'],\n    ['colSpan', 'colspan'],\n    ['rowSpan', 'rowspan'],\n    ['contentEditable', 'contenteditable'],\n    ['crossOrigin', 'crossorigin'],\n    ['dateTime', 'datetime'],\n    ['formAction', 'formaction'],\n    ['isMap', 'ismap'],\n    ['maxLength', 'maxlength'],\n    ['minLength', 'minlength'],\n    ['noValidate', 'novalidate'],\n    ['useMap', 'usemap'],\n    ['htmlFor', 'for'],\n]);\n// Global properties that this framework currently reflects. For CSR, the native\n// descriptors for these properties are added from HTMLElement.prototype to\n// LightningElement.prototype. For SSR, in order to match CSR behavior, this\n// list is used to determine which attributes to reflect.\nconst REFLECTIVE_GLOBAL_PROPERTY_SET = /*@__PURE__@*/ new Set([\n    'accessKey',\n    'dir',\n    'draggable',\n    'hidden',\n    'id',\n    'lang',\n    'spellcheck',\n    'tabIndex',\n    'title',\n]);\n/**\n * Map associating previously transformed HTML property into HTML attribute.\n */\nconst CACHED_PROPERTY_ATTRIBUTE_MAPPING = /*@__PURE__@*/ new Map();\n/**\n *\n * @param propName\n */\nfunction htmlPropertyToAttribute(propName) {\n    const ariaAttributeName = AriaPropNameToAttrNameMap[propName];\n    if (!isUndefined$1(ariaAttributeName)) {\n        return ariaAttributeName;\n    }\n    const specialAttributeName = SPECIAL_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined$1(specialAttributeName)) {\n        return specialAttributeName;\n    }\n    const cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined$1(cachedAttributeName)) {\n        return cachedAttributeName;\n    }\n    let attributeName = '';\n    for (let i = 0, len = propName.length; i < len; i++) {\n        const code = StringCharCodeAt.call(propName, i);\n        if (code >= 65 && // \"A\"\n            code <= 90 // \"Z\"\n        ) {\n            attributeName += '-' + StringFromCharCode(code + 32);\n        }\n        else {\n            attributeName += StringFromCharCode(code);\n        }\n    }\n    CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);\n    return attributeName;\n}\n/**\n * Map associating previously transformed kabab-case attributes into camel-case props.\n */\nconst CACHED_KEBAB_CAMEL_MAPPING = /*@__PURE__@*/ new Map();\n/**\n *\n * @param attrName\n */\nfunction kebabCaseToCamelCase(attrName) {\n    let result = CACHED_KEBAB_CAMEL_MAPPING.get(attrName);\n    if (isUndefined$1(result)) {\n        result = StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());\n        CACHED_KEBAB_CAMEL_MAPPING.set(attrName, result);\n    }\n    return result;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Increment whenever the LWC template compiler changes\nconst LWC_VERSION = \"8.13.2\";\nconst LWC_VERSION_COMMENT_REGEX = /\\/\\*LWC compiler v([\\d.]+)\\*\\/\\s*}/;\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * [ncls] - Normalize class name attribute.\n *\n * Transforms the provided class property value from an object/string into a string the diffing algo\n * can operate on.\n *\n * This implementation is borrowed from Vue:\n * https://github.com/vuejs/core/blob/e790e1bdd7df7be39e14780529db86e4da47a3db/packages/shared/src/normalizeProp.ts#L63-L82\n */\nfunction normalizeClass(value) {\n    if (isUndefined$1(value) || isNull(value)) {\n        // Returning undefined here improves initial render cost, because the old vnode's class will be considered\n        // undefined in the `patchClassAttribute` routine, so `oldClass === newClass` will be true so we return early\n        return undefined;\n    }\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray$1(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value) && !isNull(value)) {\n        // Iterate own enumerable keys of the object\n        const _keys = keys(value);\n        for (let i = 0; i < _keys.length; i += 1) {\n            const key = _keys[i];\n            if (value[key]) {\n                res += key + ' ';\n            }\n        }\n    }\n    return StringTrim.call(res);\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet hooksAreSet = false;\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar\n * libraries to sanitize HTML content. This hook process the content passed via the template to\n * lwc:inner-html directive.\n * It is meant to be overridden via `setHooks`; it throws an error by default.\n */\nlet sanitizeHtmlContent = () => {\n    // locker-service patches this function during runtime to sanitize HTML content.\n    throw new Error('sanitizeHtmlContent hook must be implemented.');\n};\nfunction setHooks(hooks) {\n    isFalse$1(hooksAreSet, 'Hooks are already overridden, only one definition is allowed.');\n    hooksAreSet = true;\n    sanitizeHtmlContent = hooks.sanitizeHtmlContent;\n}\nconst DECLARATION_DELIMITER = /;(?![^(]*\\))/g;\nconst PROPERTY_DELIMITER = /:(.+)/s; // `/s` (dotAll) required to match styles across newlines, e.g. `color: \\n red;`\n// Borrowed from Vue template compiler.\n// https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16\nfunction parseStyleText(cssText) {\n    const styleMap = {};\n    const declarations = cssText.split(DECLARATION_DELIMITER);\n    for (const declaration of declarations) {\n        if (declaration) {\n            const [prop, value] = declaration.split(PROPERTY_DELIMITER);\n            if (prop !== undefined && value !== undefined) {\n                styleMap[prop.trim()] = value.trim();\n            }\n        }\n    }\n    return styleMap;\n}\nfunction flattenStylesheets(stylesheets) {\n    const list = [];\n    for (const stylesheet of stylesheets) {\n        if (!isArray$1(stylesheet)) {\n            list.push(stylesheet);\n        }\n        else {\n            list.push(...flattenStylesheets(stylesheet));\n        }\n    }\n    return list;\n}\n\n/*\n * Copyright (c) 2024, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet trustedSignals;\nfunction setTrustedSignalSet(signals) {\n    isFalse$1(trustedSignals, 'Trusted Signal Set is already set!');\n    trustedSignals = signals;\n}\nfunction isTrustedSignal(target) {\n    if (!trustedSignals) {\n        // The runtime didn't set a trustedSignals set\n        // this check should only be performed for runtimes that care about filtering signals to track\n        // our default behavior should be to track all signals\n        return true;\n    }\n    return trustedSignals.has(target);\n}\n/** version: 8.13.2 */\n\n/**\n * Copyright (c) 2025 Salesforce, Inc.\n */\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// When deprecating a feature flag, ensure that it is also no longer set in the application. For\n// example, in core, the flag should be removed from LwcPermAndPrefUtilImpl.java\n/** List of all feature flags available, with the default value `null`. */\nconst features = {\n    PLACEHOLDER_TEST_FLAG: null,\n    DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE: null,\n    ENABLE_WIRE_SYNC_EMIT: null,\n    DISABLE_LIGHT_DOM_UNSCOPED_CSS: null,\n    ENABLE_FROZEN_TEMPLATE: null,\n    ENABLE_LEGACY_SCOPE_TOKENS: null,\n    ENABLE_FORCE_SHADOW_MIGRATE_MODE: null,\n    ENABLE_EXPERIMENTAL_SIGNALS: null,\n    DISABLE_SYNTHETIC_SHADOW: null,\n    LEGACY_LOCKER_ENABLED: null,\n};\nif (!globalThis.lwcRuntimeFlags) {\n    Object.defineProperty(globalThis, 'lwcRuntimeFlags', { value: create(null) });\n}\n/** Feature flags that have been set. */\nconst flags = globalThis.lwcRuntimeFlags;\n/**\n * Set the value at runtime of a given feature flag. This method only be invoked once per feature\n * flag. It is meant to be used during the app initialization.\n * @param name Name of the feature flag to set\n * @param value Whether the feature flag should be enabled\n * @throws Will throw if a non-boolean value is provided when running in production.\n * @example setFeatureFlag(\"DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE\", true)\n */\nfunction setFeatureFlag(name, value) {\n    if (!isBoolean(value)) {\n        const message = `Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". Runtime feature flags can only be set to a boolean value.`;\n        if (process.env.NODE_ENV !== 'production') {\n            throw new TypeError(message);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error(message);\n            return;\n        }\n    }\n    if (isUndefined$1(features[name])) {\n        // eslint-disable-next-line no-console\n        console.info(`Attempt to set a value on an unknown feature flag \"${name}\" resulted in a NOOP.`);\n        return;\n    }\n    // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests\n    if (process.env.NODE_ENV === 'test-karma-lwc' || process.env.NODE_ENV !== 'production') {\n        // Allow the same flag to be set more than once outside of production to enable testing\n        flags[name] = value;\n    }\n    else {\n        // Disallow the same flag to be set more than once in production\n        const runtimeValue = flags[name];\n        if (!isUndefined$1(runtimeValue)) {\n            // eslint-disable-next-line no-console\n            console.error(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". \"${name}\" has already been set with the value \"${runtimeValue}\".`);\n            return;\n        }\n        defineProperty(flags, name, { value });\n    }\n}\n/**\n * Set the value at runtime of a given feature flag. This method should only be used for testing\n * purposes. It is a no-op when invoked in production mode.\n * @param name Name of the feature flag to enable or disable\n * @param value Whether the feature flag should be enabled\n * @example setFeatureFlag(\"DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE\", true)\n */\nfunction setFeatureFlagForTest(name, value) {\n    // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests\n    if (process.env.NODE_ENV === 'test-karma-lwc' || process.env.NODE_ENV !== 'production') {\n        setFeatureFlag(name, value);\n    }\n}\n/** version: 8.13.2 */\n\n/**\n * Copyright (c) 2025 Salesforce, Inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst onReportingEnabledCallbacks = [];\n/** The currently assigned reporting dispatcher. */\nlet currentDispatcher$1 = noop;\n/**\n * Whether reporting is enabled.\n *\n * Note that this may seem redundant, given you can just check if the currentDispatcher is undefined,\n * but it turns out that Terser only strips out unused code if we use this explicit boolean.\n */\nlet enabled$1 = false;\nconst reportingControl = {\n    /**\n     * Attach a new reporting control (aka dispatcher).\n     * @param dispatcher reporting control\n     */\n    attachDispatcher(dispatcher) {\n        enabled$1 = true;\n        currentDispatcher$1 = dispatcher;\n        for (const callback of onReportingEnabledCallbacks) {\n            try {\n                callback();\n            }\n            catch (err) {\n                // This should never happen. But if it does, we don't want one callback to cause another to fail\n                // eslint-disable-next-line no-console\n                console.error('Could not invoke callback', err);\n            }\n        }\n        onReportingEnabledCallbacks.length = 0; // clear the array\n    },\n    /**\n     * Detach the current reporting control (aka dispatcher).\n     */\n    detachDispatcher() {\n        enabled$1 = false;\n        currentDispatcher$1 = noop;\n    },\n};\n/**\n * Call a callback when reporting is enabled, or immediately if reporting is already enabled.\n * Will only ever be called once.\n * @param callback\n */\nfunction onReportingEnabled(callback) {\n    if (enabled$1) {\n        // call immediately\n        callback();\n    }\n    else {\n        // call later\n        onReportingEnabledCallbacks.push(callback);\n    }\n}\n/**\n * Report to the current dispatcher, if there is one.\n * @param reportingEventId\n * @param payload data to report\n */\nfunction report(reportingEventId, payload) {\n    if (enabled$1) {\n        currentDispatcher$1(reportingEventId, payload);\n    }\n}\n/**\n * Return true if reporting is enabled\n */\nfunction isReportingEnabled() {\n    return enabled$1;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getComponentTag(vm) {\n    return `<${StringToLowerCase.call(vm.tagName)}>`;\n}\n// TODO [#1695]: Unify getComponentStack and getErrorComponentStack\nfunction getComponentStack(vm) {\n    const stack = [];\n    let prefix = '';\n    while (!isNull(vm.owner)) {\n        ArrayPush$1.call(stack, prefix + getComponentTag(vm));\n        vm = vm.owner;\n        prefix += '\\t';\n    }\n    return ArrayJoin.call(stack, '\\n');\n}\nfunction getErrorComponentStack(vm) {\n    const wcStack = [];\n    let currentVm = vm;\n    while (!isNull(currentVm)) {\n        ArrayPush$1.call(wcStack, getComponentTag(currentVm));\n        currentVm = currentVm.owner;\n    }\n    return wcStack.reverse().join('\\n\\t');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction addErrorComponentStack(vm, error) {\n    if (!isFrozen(error) && isUndefined$1(error.wcStack)) {\n        const wcStack = getErrorComponentStack(vm);\n        defineProperty(error, 'wcStack', {\n            get() {\n                return wcStack;\n            },\n        });\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst alreadyLoggedMessages = new Set();\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    window.__lwcResetAlreadyLoggedMessages = () => {\n        alreadyLoggedMessages.clear();\n    };\n}\nfunction log(method, message, vm, once) {\n    let msg = `[LWC ${method}]: ${message}`;\n    if (!isUndefined$1(vm)) {\n        msg = `${msg}\\n${getComponentStack(vm)}`;\n    }\n    if (once) {\n        if (alreadyLoggedMessages.has(msg)) {\n            return;\n        }\n        alreadyLoggedMessages.add(msg);\n    }\n    // In Vitest tests, reduce the warning and error verbosity by not printing the callstack\n    if (process.env.NODE_ENV === 'test') {\n        /* eslint-disable-next-line no-console */\n        console[method](msg);\n        return;\n    }\n    try {\n        throw new Error(msg);\n    }\n    catch (e) {\n        /* eslint-disable-next-line no-console */\n        console[method](e);\n    }\n}\nfunction logError(message, vm) {\n    log('error', message, vm, false);\n}\nfunction logWarn(message, vm) {\n    log('warn', message, vm, false);\n}\nfunction logWarnOnce(message, vm) {\n    log('warn', message, vm, true);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal(create(null));\nconst EmptyArray = seal([]);\nfunction flushCallbackQueue() {\n    if (process.env.NODE_ENV !== 'production') {\n        if (nextTickCallbackQueue.length === 0) {\n            throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n        }\n    }\n    const callbacks = nextTickCallbackQueue;\n    nextTickCallbackQueue = []; // reset to a new queue\n    for (let i = 0, len = callbacks.length; i < len; i += 1) {\n        callbacks[i]();\n    }\n}\nfunction addCallbackToNextTick(callback) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isFunction$1(callback)) {\n            throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n        }\n    }\n    if (nextTickCallbackQueue.length === 0) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.resolve().then(flushCallbackQueue);\n    }\n    ArrayPush$1.call(nextTickCallbackQueue, callback);\n}\nfunction guid() {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n// Make a shallow copy of an object but omit the given key\nfunction cloneAndOmitKey(object, keyToOmit) {\n    const result = {};\n    for (const key of keys(object)) {\n        if (key !== keyToOmit) {\n            result[key] = object[key];\n        }\n    }\n    return result;\n}\n// Throw an error if we're running in prod mode. Ensures code is truly removed from prod mode.\nfunction assertNotProd() {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n}\nfunction shouldBeFormAssociated(Ctor) {\n    const ctorFormAssociated = Boolean(Ctor.formAssociated);\n    const apiVersion = getComponentAPIVersion(Ctor);\n    const apiFeatureEnabled = isAPIFeatureEnabled(7 /* APIFeature.ENABLE_ELEMENT_INTERNALS_AND_FACE */, apiVersion);\n    if (process.env.NODE_ENV !== 'production' && ctorFormAssociated && !apiFeatureEnabled) {\n        const tagName = getComponentRegisteredName(Ctor);\n        logWarnOnce(`Component <${tagName}> set static formAssociated to true, but form ` +\n            `association is not enabled because the API version is ${apiVersion}. To enable form association, ` +\n            `update the LWC component API version to 61 or above. https://lwc.dev/guide/versioning`);\n    }\n    return ctorFormAssociated && apiFeatureEnabled;\n}\n// check if a property is in an object, and if the object throws an error merely because we are\n// checking if the property exists, return false\nfunction safeHasProp(obj, prop) {\n    try {\n        return prop in obj;\n    }\n    catch (_err) {\n        return false;\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// Do additional mutation tracking for DevTools performance profiling, in dev mode only.\n//\nconst reactiveObserversToVMs = new WeakMap();\nconst targetsToPropertyKeys = new WeakMap();\nlet mutationLogs = [];\n// Create a human-readable member access notation like `obj.foo` or `arr[1]`,\n// handling edge cases like `obj[Symbol(\"bar\")]` and `obj[\"spaces here\"]`\nfunction toPrettyMemberNotation(parent, child) {\n    if (isUndefined$1(parent)) {\n        // Bare prop, just stringify the child\n        return toString(child);\n    }\n    else if (!isString(child)) {\n        // Symbol/number, e.g. `obj[Symbol(\"foo\")]` or `obj[1234]`\n        return `${toString(parent)}[${toString(child)}]`;\n    }\n    else if (/^\\w+$/.test(child)) {\n        // Dot-notation-safe string, e.g. `obj.foo`\n        return `${toString(parent)}.${child}`;\n    }\n    else {\n        // Bracket-notation-requiring string, e.g. `obj[\"prop with spaces\"]`\n        return `${toString(parent)}[${JSON.stringify(child)}]`;\n    }\n}\nfunction safelyCallGetter(target, key) {\n    // Arbitrary getters can throw. We don't want to throw an error just due to dev-mode-only mutation tracking\n    // (which is only used for performance debugging) so ignore errors here.\n    try {\n        return target[key];\n    }\n    catch (_err) {\n        /* ignore */\n    }\n}\nfunction isRevokedProxy(target) {\n    try {\n        // `str in obj` will never throw for normal objects or active proxies,\n        // but the operation is not allowed for revoked proxies\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        '' in target;\n        return false;\n    }\n    catch (_) {\n        return true;\n    }\n}\n/**\n * Flush all the logs we've written so far and return the current logs.\n */\nfunction getAndFlushMutationLogs() {\n    assertNotProd();\n    const result = mutationLogs;\n    mutationLogs = [];\n    return result;\n}\n/**\n * Log a new mutation for this reactive observer.\n * @param reactiveObserver - relevant ReactiveObserver\n * @param target - target object that is being observed\n * @param key - key (property) that was mutated\n */\nfunction logMutation(reactiveObserver, target, key) {\n    assertNotProd();\n    const parentKey = targetsToPropertyKeys.get(target);\n    const vm = reactiveObserversToVMs.get(reactiveObserver);\n    /* istanbul ignore if */\n    if (isUndefined$1(vm)) {\n        // VM should only be undefined in Vitest tests, where a reactive observer is not always associated with a VM\n        // because the unit tests just create Reactive Observers on-the-fly.\n        // Note we could explicitly target Vitest with `process.env.NODE_ENV === 'test'`, but then that would also\n        // affect our downstream consumers' Jest/Vitest tests, and we don't want to throw an error just for a logger.\n        if (process.env.NODE_ENV === 'test-karma-lwc') {\n            throw new Error('The VM should always be defined except possibly in unit tests');\n        }\n    }\n    else {\n        const prop = toPrettyMemberNotation(parentKey, key);\n        ArrayPush$1.call(mutationLogs, { vm, prop });\n    }\n}\n/**\n * Flush logs associated with a given VM.\n * @param vm - given VM\n */\nfunction flushMutationLogsForVM(vm) {\n    assertNotProd();\n    mutationLogs = ArrayFilter.call(mutationLogs, (log) => log.vm !== vm);\n}\n/**\n * Mark this ReactiveObserver as related to this VM. This is only needed for mutation tracking in dev mode.\n * @param reactiveObserver\n * @param vm\n */\nfunction associateReactiveObserverWithVM(reactiveObserver, vm) {\n    assertNotProd();\n    reactiveObserversToVMs.set(reactiveObserver, vm);\n}\n/**\n * Deeply track all objects in a target and associate with a given key.\n * @param key - key associated with the object in the component\n * @param target - tracked target object\n */\nfunction trackTargetForMutationLogging(key, target) {\n    assertNotProd();\n    if (targetsToPropertyKeys.has(target)) {\n        // Guard against recursive objects - don't traverse forever\n        return;\n    }\n    // Revoked proxies (e.g. window props in LWS sandboxes) throw an error if we try to track them\n    if (isObject(target) && !isNull(target) && !isRevokedProxy(target)) {\n        // only track non-primitives; others are invalid as WeakMap keys\n        targetsToPropertyKeys.set(target, key);\n        // Deeply traverse arrays and objects to track every object within\n        if (isArray$1(target)) {\n            for (let i = 0; i < target.length; i++) {\n                trackTargetForMutationLogging(toPrettyMemberNotation(key, i), safelyCallGetter(target, i));\n            }\n        }\n        else {\n            // Track only own property names and symbols (including non-enumerated)\n            // This is consistent with what observable-membrane does:\n            // https://github.com/salesforce/observable-membrane/blob/b85417f/src/base-handler.ts#L142-L143\n            // Note this code path is very hot, hence doing two separate for-loops rather than creating a new array.\n            for (const prop of getOwnPropertyNames$1(target)) {\n                trackTargetForMutationLogging(toPrettyMemberNotation(key, prop), safelyCallGetter(target, prop));\n            }\n            for (const prop of getOwnPropertySymbols$1(target)) {\n                trackTargetForMutationLogging(toPrettyMemberNotation(key, prop), safelyCallGetter(target, prop));\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst TargetToReactiveRecordMap = new WeakMap();\nfunction getReactiveRecord(target) {\n    let reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (isUndefined$1(reactiveRecord)) {\n        const newRecord = create(null);\n        reactiveRecord = newRecord;\n        TargetToReactiveRecordMap.set(target, newRecord);\n    }\n    return reactiveRecord;\n}\nlet currentReactiveObserver = null;\nfunction valueMutated(target, key) {\n    const reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (!isUndefined$1(reactiveRecord)) {\n        const reactiveObservers = reactiveRecord[key];\n        if (!isUndefined$1(reactiveObservers)) {\n            for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {\n                const ro = reactiveObservers[i];\n                if (process.env.NODE_ENV !== 'production') {\n                    logMutation(ro, target, key);\n                }\n                ro.notify();\n            }\n        }\n    }\n}\nfunction valueObserved(target, key) {\n    // We should determine if an active Observing Record is present to track mutations.\n    if (currentReactiveObserver === null) {\n        return;\n    }\n    const ro = currentReactiveObserver;\n    const reactiveRecord = getReactiveRecord(target);\n    let reactiveObservers = reactiveRecord[key];\n    if (isUndefined$1(reactiveObservers)) {\n        reactiveObservers = [];\n        reactiveRecord[key] = reactiveObservers;\n    }\n    else if (reactiveObservers[0] === ro) {\n        return; // perf optimization considering that most subscriptions will come from the same record\n    }\n    if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {\n        ro.link(reactiveObservers);\n    }\n}\nclass ReactiveObserver {\n    constructor(callback) {\n        this.listeners = [];\n        this.callback = callback;\n    }\n    observe(job) {\n        const inceptionReactiveRecord = currentReactiveObserver;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        currentReactiveObserver = this;\n        let error;\n        try {\n            job();\n        }\n        catch (e) {\n            error = Object(e);\n        }\n        finally {\n            currentReactiveObserver = inceptionReactiveRecord;\n            if (error !== undefined) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n        }\n    }\n    /**\n     * This method is responsible for disconnecting the Reactive Observer\n     * from any Reactive Record that has a reference to it, to prevent future\n     * notifications about previously recorded access.\n     */\n    reset() {\n        const { listeners } = this;\n        const len = listeners.length;\n        if (len > 0) {\n            for (let i = 0; i < len; i++) {\n                const set = listeners[i];\n                const setLength = set.length;\n                // The length is usually 1, so avoid doing an indexOf when we know for certain\n                // that `this` is the first item in the array.\n                if (setLength > 1) {\n                    // Swap with the last item before removal.\n                    // (Avoiding splice here is a perf optimization, and the order doesn't matter.)\n                    const index = ArrayIndexOf.call(set, this);\n                    set[index] = set[setLength - 1];\n                }\n                // Remove the last item\n                ArrayPop.call(set);\n            }\n            listeners.length = 0;\n        }\n    }\n    // friend methods\n    notify() {\n        this.callback.call(undefined, this);\n    }\n    link(reactiveObservers) {\n        ArrayPush$1.call(reactiveObservers, this);\n        // we keep track of observing records where the observing record was added to so we can do some clean up later on\n        ArrayPush$1.call(this.listeners, reactiveObservers);\n    }\n    isObserving() {\n        return currentReactiveObserver === this;\n    }\n}\n\n/*\n * Copyright (c) 2024, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This map keeps track of objects to signals. There is an assumption that the signal is strongly referenced\n * on the object which allows the SignalTracker to be garbage collected along with the object.\n */\nconst TargetToSignalTrackerMap = new WeakMap();\nfunction getSignalTracker(target) {\n    let signalTracker = TargetToSignalTrackerMap.get(target);\n    if (isUndefined$1(signalTracker)) {\n        signalTracker = new SignalTracker();\n        TargetToSignalTrackerMap.set(target, signalTracker);\n    }\n    return signalTracker;\n}\nfunction subscribeToSignal(target, signal, update) {\n    const signalTracker = getSignalTracker(target);\n    if (isFalse(signalTracker.seen(signal))) {\n        signalTracker.subscribeToSignal(signal, update);\n    }\n}\nfunction unsubscribeFromSignals(target) {\n    if (TargetToSignalTrackerMap.has(target)) {\n        const signalTracker = getSignalTracker(target);\n        signalTracker.unsubscribeFromSignals();\n        signalTracker.reset();\n    }\n}\n/**\n * This class is used to keep track of the signals associated to a given object.\n * It is used to prevent the LWC engine from subscribing duplicate callbacks multiple times\n * to the same signal. Additionally, it keeps track of all signal unsubscribe callbacks, handles invoking\n * them when necessary and discarding them.\n */\nclass SignalTracker {\n    constructor() {\n        this.signalToUnsubscribeMap = new Map();\n    }\n    seen(signal) {\n        return this.signalToUnsubscribeMap.has(signal);\n    }\n    subscribeToSignal(signal, update) {\n        try {\n            const unsubscribe = signal.subscribe(update);\n            if (isFunction$1(unsubscribe)) {\n                // TODO [#3978]: Evaluate how we should handle the case when unsubscribe is not a function.\n                // Long term we should throw an error or log a warning.\n                this.signalToUnsubscribeMap.set(signal, unsubscribe);\n            }\n        }\n        catch (err) {\n            logWarnOnce(`Attempted to subscribe to an object that has the shape of a signal but received the following error: ${err?.stack ?? err}`);\n        }\n    }\n    unsubscribeFromSignals() {\n        try {\n            this.signalToUnsubscribeMap.forEach((unsubscribe) => unsubscribe());\n        }\n        catch (err) {\n            logWarnOnce(`Attempted to call a signal's unsubscribe callback but received the following error: ${err?.stack ?? err}`);\n        }\n    }\n    reset() {\n        this.signalToUnsubscribeMap.clear();\n    }\n}\nfunction componentValueMutated(vm, key) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        valueMutated(vm.component, key);\n    }\n}\nfunction componentValueObserved(vm, key, target = {}) {\n    const { component, tro } = vm;\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        valueObserved(component, key);\n    }\n    // The portion of reactivity that's exposed to signals is to subscribe a callback to re-render the VM (templates).\n    // We check the following to ensure re-render is subscribed at the correct time.\n    //  1. The template is currently being rendered (there is a template reactive observer)\n    //  2. There was a call to a getter to access the signal (happens during vnode generation)\n    if (lwcRuntimeFlags.ENABLE_EXPERIMENTAL_SIGNALS &&\n        isObject(target) &&\n        !isNull(target) &&\n        safeHasProp(target, 'value') &&\n        safeHasProp(target, 'subscribe') &&\n        isFunction$1(target.subscribe) &&\n        isTrustedSignal(target) &&\n        // Only subscribe if a template is being rendered by the engine\n        tro.isObserving()) {\n        // Subscribe the template reactive observer's notify method, which will mark the vm as dirty and schedule hydration.\n        subscribeToSignal(component, target, tro.notify.bind(tro));\n    }\n}\nfunction createReactiveObserver(callback) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return new ReactiveObserver(callback) ;\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resolveCircularModuleDependency(fn) {\n    const module = fn();\n    return module?.__esModule ? module.default : module;\n}\nfunction isCircularModuleDependency(obj) {\n    return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst instrumentDef = globalThis.__lwc_instrument_cmp_def ?? noop;\nconst instrumentInstance = globalThis.__lwc_instrument_cmp_instance ?? noop;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having\n// to inject at runtime.\nconst HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () { };\nconst HTMLElementPrototype = HTMLElementConstructor.prototype;\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Apply ARIA string reflection behavior to a prototype.\n// This is deliberately kept separate from @lwc/aria-reflection. @lwc/aria-reflection is a global polyfill that is\n// needed for backwards compatibility in LEX, whereas this is designed to only apply to our own\n// LightningElement/BaseBridgeElement prototypes.\n// Note we only need to handle ARIA reflections that aren't already in Element.prototype\nconst ariaReflectionPolyfillDescriptors = create(null);\nfor (const [propName, attrName] of entries(AriaPropNameToAttrNameMap)) {\n    if (isUndefined$1(getPropertyDescriptor(HTMLElementPrototype, propName))) {\n        // Note that we need to call this.{get,set,has,remove}Attribute rather than dereferencing\n        // from Element.prototype, because these methods are overridden in LightningElement.\n        ariaReflectionPolyfillDescriptors[propName] = {\n            get() {\n                return this.getAttribute(attrName);\n            },\n            set(newValue) {\n                // TODO [#3284]: According to the spec, IDL nullable type values\n                // (null and undefined) should remove the attribute; however, we\n                // only do so in the case of null for historical reasons.\n                // See also https://github.com/w3c/aria/issues/1858\n                if (isNull(newValue)) {\n                    this.removeAttribute(attrName);\n                }\n                else {\n                    this.setAttribute(attrName, newValue);\n                }\n            },\n            // configurable and enumerable to allow it to be overridden â€“ this mimics Safari's/Chrome's behavior\n            configurable: true,\n            enumerable: true,\n        };\n    }\n}\n// Add descriptors for ARIA attributes\nfor (const [attrName, propName] of entries(AriaAttrNameToPropNameMap)) {\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\nconst HTMLElementOriginalDescriptors = create(null);\nforEach.call(keys(AriaPropNameToAttrNameMap), (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n    if (!isUndefined$1(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\nfor (const propName of REFLECTIVE_GLOBAL_PROPERTY_SET) {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n    // this category, so, better to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n    if (!isUndefined$1(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction generateDataDescriptor(options) {\n    return assign({\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    }, options);\n}\nfunction generateAccessorDescriptor(options) {\n    return assign({\n        configurable: true,\n        enumerable: true,\n    }, options);\n}\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n    assertNotProd(); // this method should never leak to prod\n    isDomMutationAllowed = true;\n}\nfunction lockDomMutation() {\n    assertNotProd(); // this method should never leak to prod\n    isDomMutationAllowed = false;\n}\nfunction logMissingPortalWarn(name, type) {\n    return logWarn(`The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`);\n}\nfunction patchElementWithRestrictions(elm, options) {\n    assertNotProd(); // this method should never leak to prod\n    const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n    const descriptors = {\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(value) {\n                logError(`Invalid attempt to set outerHTML on Element.`);\n                return originalOuterHTMLDescriptor.set.call(this, value);\n            },\n        }),\n    };\n    // Apply extra restriction related to DOM manipulation if the element is not a portal.\n    if (!options.isLight && options.isSynthetic && !options.isPortal) {\n        const { appendChild, insertBefore, removeChild, replaceChild } = elm;\n        const originalNodeValueDescriptor = getPropertyDescriptor(elm, 'nodeValue');\n        const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n        const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n        assign(descriptors, {\n            appendChild: generateDataDescriptor({\n                value(aChild) {\n                    logMissingPortalWarn('appendChild', 'method');\n                    return appendChild.call(this, aChild);\n                },\n            }),\n            insertBefore: generateDataDescriptor({\n                value(newNode, referenceNode) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalWarn('insertBefore', 'method');\n                    }\n                    return insertBefore.call(this, newNode, referenceNode);\n                },\n            }),\n            removeChild: generateDataDescriptor({\n                value(aChild) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalWarn('removeChild', 'method');\n                    }\n                    return removeChild.call(this, aChild);\n                },\n            }),\n            replaceChild: generateDataDescriptor({\n                value(newChild, oldChild) {\n                    logMissingPortalWarn('replaceChild', 'method');\n                    return replaceChild.call(this, newChild, oldChild);\n                },\n            }),\n            nodeValue: generateAccessorDescriptor({\n                get() {\n                    return originalNodeValueDescriptor.get.call(this);\n                },\n                set(value) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalWarn('nodeValue', 'property');\n                    }\n                    originalNodeValueDescriptor.set.call(this, value);\n                },\n            }),\n            textContent: generateAccessorDescriptor({\n                get() {\n                    return originalTextContentDescriptor.get.call(this);\n                },\n                set(value) {\n                    logMissingPortalWarn('textContent', 'property');\n                    originalTextContentDescriptor.set.call(this, value);\n                },\n            }),\n            innerHTML: generateAccessorDescriptor({\n                get() {\n                    return originalInnerHTMLDescriptor.get.call(this);\n                },\n                set(value) {\n                    logMissingPortalWarn('innerHTML', 'property');\n                    return originalInnerHTMLDescriptor.set.call(this, value);\n                },\n            }),\n        });\n    }\n    defineProperties(elm, descriptors);\n}\nfunction getShadowRootRestrictionsDescriptors(sr) {\n    assertNotProd(); // this method should never leak to prod\n    // Disallowing properties in dev mode only to avoid people doing the wrong\n    // thing when using the real shadow root, because if that's the case,\n    // the component will not work when running with synthetic shadow.\n    const originalAddEventListener = sr.addEventListener;\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');\n    return {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(value) {\n                logError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n                return originalInnerHTMLDescriptor.set.call(this, value);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(value) {\n                logError(`Invalid attempt to set textContent on ShadowRoot.`);\n                return originalTextContentDescriptor.set.call(this, value);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type, listener, options) {\n                // TODO [#1824]: Potentially relax this restriction\n                if (!isUndefined$1(options)) {\n                    logError('The `addEventListener` method on ShadowRoot does not support any options.', getAssociatedVMIfPresent(this));\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-expect-error type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n    };\n}\n// Custom Elements Restrictions:\n// -----------------------------\nfunction getCustomElementRestrictionsDescriptors(elm) {\n    assertNotProd(); // this method should never leak to prod\n    const originalAddEventListener = elm.addEventListener;\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n    const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n    return {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(value) {\n                logError(`Invalid attempt to set innerHTML on HTMLElement.`);\n                return originalInnerHTMLDescriptor.set.call(this, value);\n            },\n        }),\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(value) {\n                logError(`Invalid attempt to set outerHTML on HTMLElement.`);\n                return originalOuterHTMLDescriptor.set.call(this, value);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(value) {\n                logError(`Invalid attempt to set textContent on HTMLElement.`);\n                return originalTextContentDescriptor.set.call(this, value);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type, listener, options) {\n                // TODO [#1824]: Potentially relax this restriction\n                if (!isUndefined$1(options)) {\n                    logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-expect-error type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n    };\n}\n// This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\nfunction patchShadowRootWithRestrictions(sr) {\n    defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));\n}\nfunction patchCustomElementWithRestrictions(elm) {\n    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);\n    const elmProto = getPrototypeOf$1(elm);\n    setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction updateComponentValue(vm, key, newValue) {\n    const { cmpFields } = vm;\n    if (newValue !== cmpFields[key]) {\n        cmpFields[key] = newValue;\n        componentValueMutated(vm, key);\n    }\n}\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst { isArray } = Array;\nconst { prototype: ObjectDotPrototype, getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\nconst { push: ArrayPush, concat: ArrayConcat } = Array.prototype;\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nconst proxyToValueMap = new WeakMap();\nfunction registerProxy(proxy, value) {\n    proxyToValueMap.set(proxy, value);\n}\nconst unwrap$1 = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nclass BaseProxyHandler {\n    constructor(membrane, value) {\n        this.originalTarget = value;\n        this.membrane = membrane;\n    }\n    // Shared utility methods\n    wrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            descriptor.value = this.wrapValue(descriptor.value);\n        }\n        else {\n            const { set: originalSet, get: originalGet } = descriptor;\n            if (!isUndefined(originalGet)) {\n                descriptor.get = this.wrapGetter(originalGet);\n            }\n            if (!isUndefined(originalSet)) {\n                descriptor.set = this.wrapSetter(originalSet);\n            }\n        }\n        return descriptor;\n    }\n    copyDescriptorIntoShadowTarget(shadowTarget, key) {\n        const { originalTarget } = this;\n        // Note: a property might get defined multiple times in the shadowTarget\n        //       but it will always be compatible with the previous descriptor\n        //       to preserve the object invariants, which makes these lines safe.\n        const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n        // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed\n        /* istanbul ignore else */\n        if (!isUndefined(originalDescriptor)) {\n            const wrappedDesc = this.wrapDescriptor(originalDescriptor);\n            ObjectDefineProperty(shadowTarget, key, wrappedDesc);\n        }\n    }\n    lockShadowTarget(shadowTarget) {\n        const { originalTarget } = this;\n        const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n        targetKeys.forEach((key) => {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        });\n        const { membrane: { tagPropertyKey }, } = this;\n        if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));\n        }\n        preventExtensions(shadowTarget);\n    }\n    // Shared Traps\n    // TODO: apply() is never called\n    /* istanbul ignore next */\n    apply(shadowTarget, thisArg, argArray) {\n        /* No op */\n    }\n    // TODO: construct() is never called\n    /* istanbul ignore next */\n    construct(shadowTarget, argArray, newTarget) {\n        /* No op */\n    }\n    get(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved }, } = this;\n        const value = originalTarget[key];\n        valueObserved(originalTarget, key);\n        return this.wrapValue(value);\n    }\n    has(shadowTarget, key) {\n        const { originalTarget, membrane: { tagPropertyKey, valueObserved }, } = this;\n        valueObserved(originalTarget, key);\n        // since key is never going to be undefined, and tagPropertyKey might be undefined\n        // we can simply compare them as the second part of the condition.\n        return key in originalTarget || key === tagPropertyKey;\n    }\n    ownKeys(shadowTarget) {\n        const { originalTarget, membrane: { tagPropertyKey }, } = this;\n        // if the membrane tag key exists and it is not in the original target, we add it to the keys.\n        const keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey)\n            ? []\n            : [tagPropertyKey];\n        // small perf optimization using push instead of concat to avoid creating an extra array\n        ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));\n        ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));\n        return keys;\n    }\n    isExtensible(shadowTarget) {\n        const { originalTarget } = this;\n        // optimization to avoid attempting to lock down the shadowTarget multiple times\n        if (!isExtensible(shadowTarget)) {\n            return false; // was already locked down\n        }\n        if (!isExtensible(originalTarget)) {\n            this.lockShadowTarget(shadowTarget);\n            return false;\n        }\n        return true;\n    }\n    getPrototypeOf(shadowTarget) {\n        const { originalTarget } = this;\n        return getPrototypeOf(originalTarget);\n    }\n    getOwnPropertyDescriptor(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved, tagPropertyKey }, } = this;\n        // keys looked up via getOwnPropertyDescriptor need to be reactive\n        valueObserved(originalTarget, key);\n        let desc = getOwnPropertyDescriptor(originalTarget, key);\n        if (isUndefined(desc)) {\n            if (key !== tagPropertyKey) {\n                return undefined;\n            }\n            // if the key is the membrane tag key, and is not in the original target,\n            // we produce a synthetic descriptor and install it on the shadow target\n            desc = { value: undefined, writable: false, configurable: false, enumerable: false };\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);\n            return desc;\n        }\n        if (desc.configurable === false) {\n            // updating the descriptor to non-configurable on the shadow\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        // Note: by accessing the descriptor, the key is marked as observed\n        // but access to the value, setter or getter (if available) cannot observe\n        // mutations, just like regular methods, in which case we just do nothing.\n        return this.wrapDescriptor(desc);\n    }\n}\n\nconst getterMap$1 = new WeakMap();\nconst setterMap$1 = new WeakMap();\nconst reverseGetterMap = new WeakMap();\nconst reverseSetterMap = new WeakMap();\nclass ReactiveProxyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap$1.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap$1(this)));\n        };\n        getterMap$1.set(originalGet, get);\n        reverseGetterMap.set(get, originalGet);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap$1.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const set = function (v) {\n            // invoking the original setter with the original target\n            originalSet.call(unwrap$1(this), unwrap$1(v));\n        };\n        setterMap$1.set(originalSet, set);\n        reverseSetterMap.set(set, originalSet);\n        return set;\n    }\n    unwrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            // dealing with a data descriptor\n            descriptor.value = unwrap$1(descriptor.value);\n        }\n        else {\n            const { set, get } = descriptor;\n            if (!isUndefined(get)) {\n                descriptor.get = this.unwrapGetter(get);\n            }\n            if (!isUndefined(set)) {\n                descriptor.set = this.unwrapSetter(set);\n            }\n        }\n        return descriptor;\n    }\n    unwrapGetter(redGet) {\n        const reverseGetter = reverseGetterMap.get(redGet);\n        if (!isUndefined(reverseGetter)) {\n            return reverseGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the red getter with the proxy of this\n            return unwrap$1(redGet.call(handler.wrapValue(this)));\n        };\n        getterMap$1.set(get, redGet);\n        reverseGetterMap.set(redGet, get);\n        return get;\n    }\n    unwrapSetter(redSet) {\n        const reverseSetter = reverseSetterMap.get(redSet);\n        if (!isUndefined(reverseSetter)) {\n            return reverseSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            // invoking the red setter with the proxy of this\n            redSet.call(handler.wrapValue(this), handler.wrapValue(v));\n        };\n        setterMap$1.set(set, redSet);\n        reverseSetterMap.set(redSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        const { originalTarget, membrane: { valueMutated }, } = this;\n        const oldValue = originalTarget[key];\n        if (oldValue !== value) {\n            originalTarget[key] = value;\n            valueMutated(originalTarget, key);\n        }\n        else if (key === 'length' && isArray(originalTarget)) {\n            // fix for issue #236: push will add the new index, and by the time length\n            // is updated, the internal length is already equal to the new length value\n            // therefore, the oldValue is equal to the value. This is the forking logic\n            // to support this use case.\n            valueMutated(originalTarget, key);\n        }\n        return true;\n    }\n    deleteProperty(shadowTarget, key) {\n        const { originalTarget, membrane: { valueMutated }, } = this;\n        delete originalTarget[key];\n        valueMutated(originalTarget, key);\n        return true;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n    }\n    preventExtensions(shadowTarget) {\n        if (isExtensible(shadowTarget)) {\n            const { originalTarget } = this;\n            preventExtensions(originalTarget);\n            // if the originalTarget is a proxy itself, it might reject\n            // the preventExtension call, in which case we should not attempt to lock down\n            // the shadow target.\n            // TODO: It should not actually be possible to reach this `if` statement.\n            // If a proxy rejects extensions, then calling preventExtensions will throw an error:\n            // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY\n            /* istanbul ignore if */\n            if (isExtensible(originalTarget)) {\n                return false;\n            }\n            this.lockShadowTarget(shadowTarget);\n        }\n        return true;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        const { originalTarget, membrane: { valueMutated, tagPropertyKey }, } = this;\n        if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {\n            // To avoid leaking the membrane tag property into the original target, we must\n            // be sure that the original target doesn't have yet.\n            // NOTE: we do not return false here because Object.freeze and equivalent operations\n            // will attempt to set the descriptor to the same value, and expect no to throw. This\n            // is an small compromise for the sake of not having to diff the descriptors.\n            return true;\n        }\n        ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));\n        // intentionally testing if false since it could be undefined as well\n        if (descriptor.configurable === false) {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        valueMutated(originalTarget, key);\n        return true;\n    }\n}\n\nconst getterMap = new WeakMap();\nconst setterMap = new WeakMap();\nclass ReadOnlyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getReadOnlyProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap$1(this)));\n        };\n        getterMap.set(originalGet, get);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const set = function (v) {\n        };\n        setterMap.set(originalSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        /* istanbul ignore next */\n        return false;\n    }\n    deleteProperty(shadowTarget, key) {\n        /* istanbul ignore next */\n        return false;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n    }\n    preventExtensions(shadowTarget) {\n        /* istanbul ignore next */\n        return false;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        /* istanbul ignore next */\n        return false;\n    }\n}\n\nfunction defaultValueIsObservable(value) {\n    // intentionally checking for null\n    if (value === null) {\n        return false;\n    }\n    // treat all non-object types, including undefined, as non-observable values\n    if (typeof value !== 'object') {\n        return false;\n    }\n    if (isArray(value)) {\n        return true;\n    }\n    const proto = getPrototypeOf(value);\n    return proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null;\n}\nconst defaultValueObserved = (obj, key) => {\n    /* do nothing */\n};\nconst defaultValueMutated = (obj, key) => {\n    /* do nothing */\n};\nfunction createShadowTarget(value) {\n    return isArray(value) ? [] : {};\n}\nclass ObservableMembrane {\n    constructor(options = {}) {\n        this.readOnlyObjectGraph = new WeakMap();\n        this.reactiveObjectGraph = new WeakMap();\n        const { valueMutated, valueObserved, valueIsObservable, tagPropertyKey } = options;\n        this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n        this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n        this.valueIsObservable = isFunction(valueIsObservable)\n            ? valueIsObservable\n            : defaultValueIsObservable;\n        this.tagPropertyKey = tagPropertyKey;\n    }\n    getProxy(value) {\n        const unwrappedValue = unwrap$1(value);\n        if (this.valueIsObservable(unwrappedValue)) {\n            // When trying to extract the writable version of a readonly we return the readonly.\n            if (this.readOnlyObjectGraph.get(unwrappedValue) === value) {\n                return value;\n            }\n            return this.getReactiveHandler(unwrappedValue);\n        }\n        return unwrappedValue;\n    }\n    getReadOnlyProxy(value) {\n        value = unwrap$1(value);\n        if (this.valueIsObservable(value)) {\n            return this.getReadOnlyHandler(value);\n        }\n        return value;\n    }\n    unwrapProxy(p) {\n        return unwrap$1(p);\n    }\n    getReactiveHandler(value) {\n        let proxy = this.reactiveObjectGraph.get(value);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReactiveProxyHandler(this, value);\n            proxy = new Proxy(createShadowTarget(value), handler);\n            registerProxy(proxy, value);\n            this.reactiveObjectGraph.set(value, proxy);\n        }\n        return proxy;\n    }\n    getReadOnlyHandler(value) {\n        let proxy = this.readOnlyObjectGraph.get(value);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReadOnlyHandler(this, value);\n            proxy = new Proxy(createShadowTarget(value), handler);\n            registerProxy(proxy, value);\n            this.readOnlyObjectGraph.set(value, proxy);\n        }\n        return proxy;\n    }\n}\n/** version: 2.0.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');\nconst reactiveMembrane = new ObservableMembrane({\n    valueObserved,\n    valueMutated,\n    tagPropertyKey: lockerLivePropertyKey,\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n * @param value\n */\nfunction unwrap(value) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return reactiveMembrane.unwrapProxy(value) ;\n}\nfunction getReadOnlyProxy(value) {\n    // We must return a frozen wrapper around the value, so that child components cannot mutate properties passed to\n    // them from their parents. This applies to both the client and server.\n    return reactiveMembrane.getReadOnlyProxy(value);\n}\nfunction getReactiveProxy(value) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return reactiveMembrane.getProxy(value) ;\n}\n// Making the component instance a live value when using Locker to support expandos.\nfunction markLockerLiveObject(obj) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        obj[lockerLivePropertyKey] = undefined;\n    }\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet globalStylesheet;\nfunction isStyleElement(elm) {\n    return elm.tagName === 'STYLE';\n}\nasync function fetchStylesheet(elm) {\n    if (isStyleElement(elm)) {\n        return elm.textContent;\n    }\n    else {\n        // <link>\n        const { href } = elm;\n        try {\n            return await (await fetch(href)).text();\n        }\n        catch (_err) {\n            logWarnOnce(`Ignoring cross-origin stylesheet in migrate mode: ${href}`);\n            // ignore errors with cross-origin stylesheets - nothing we can do for those\n            return '';\n        }\n    }\n}\nfunction initGlobalStylesheet() {\n    const stylesheet = new CSSStyleSheet();\n    const elmsToPromises = new Map();\n    let lastSeenLength = 0;\n    const copyToGlobalStylesheet = () => {\n        const elms = document.head.querySelectorAll('style:not([data-rendered-by-lwc]),link[rel=\"stylesheet\"]');\n        if (elms.length === lastSeenLength) {\n            return; // nothing to update\n        }\n        lastSeenLength = elms.length;\n        const promises = [...elms].map((elm) => {\n            let promise = elmsToPromises.get(elm);\n            if (!promise) {\n                // Cache the promise\n                promise = fetchStylesheet(elm);\n                elmsToPromises.set(elm, promise);\n            }\n            return promise;\n        });\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Promise.all(promises).then((stylesheetTexts) => {\n            // When replaceSync() is called, the entire contents of the constructable stylesheet are replaced\n            // with the copied+concatenated styles. This means that any shadow root's adoptedStyleSheets that\n            // contains this constructable stylesheet will immediately get the new styles.\n            stylesheet.replaceSync(stylesheetTexts.join('\\n'));\n        });\n    };\n    const headObserver = new MutationObserver(copyToGlobalStylesheet);\n    // By observing only the childList, note that we are not covering the case where someone changes an `href`\n    // on an existing <link>`, or the textContent on an existing `<style>`. This is assumed to be an uncommon\n    // case and not worth covering.\n    headObserver.observe(document.head, {\n        childList: true,\n    });\n    copyToGlobalStylesheet();\n    return stylesheet;\n}\nfunction applyShadowMigrateMode(shadowRoot) {\n    if (!globalStylesheet) {\n        globalStylesheet = initGlobalStylesheet();\n    }\n    shadowRoot.synthetic = true; // pretend to be synthetic mode\n    shadowRoot.adoptedStyleSheets.push(globalStylesheet);\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This module is responsible for producing the ComponentDef object that is always\n * accessible via `vm.def`. This is lazily created during the creation of the first\n * instance of a component class, and shared across all instances.\n *\n * This structure can be used to synthetically create proxies, and understand the\n * shape of a component. It is also used internally to apply extra optimizations.\n */\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n * @param propName\n * @param descriptor\n */\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!isFunction$1(get)) {\n        throw new TypeError(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n    }\n    if (!isFunction$1(set)) {\n        throw new TypeError(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n    }\n    return {\n        enumerable,\n        configurable,\n        get() {\n            const vm = getAssociatedVM(this);\n            if (isBeingConstructed(vm)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logError(`The value of property \\`${propName}\\` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n                }\n                return;\n            }\n            componentValueObserved(vm, propName);\n            return get.call(vm.elm);\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                if (isInvokingRender) {\n                    logError(`${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n                }\n                if (isUpdatingTemplate) {\n                    logError(`When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);\n                }\n                if (isBeingConstructed(vm)) {\n                    logError(`Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n                }\n                if (isObject(newValue) && !isNull(newValue)) {\n                    logError(`Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n                }\n            }\n            updateComponentValue(vm, propName, newValue);\n            return set.call(vm.elm, newValue);\n        },\n    };\n}\nconst refsCache = new WeakMap();\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n */\n// @ts-expect-error When exported, it will conform, but we need to build it first!\nconst LightningElement = function () {\n    // This should be as performant as possible, while any initialization should be done lazily\n    if (isNull(vmBeingConstructed)) {\n        // Thrown when doing something like `new LightningElement()` or\n        // `class Foo extends LightningElement {}; new Foo()`\n        throw new TypeError('Illegal constructor');\n    }\n    // This is a no-op unless Lightning DevTools are enabled.\n    instrumentInstance(this, vmBeingConstructed);\n    const vm = vmBeingConstructed;\n    const { def, elm } = vm;\n    const { bridge } = def;\n    if (process.env.NODE_ENV !== 'production') {\n        const { assertInstanceOfHTMLElement } = vm.renderer;\n        assertInstanceOfHTMLElement(vm.elm, `Component creation requires a DOM element to be associated to ${vm}.`);\n    }\n    setPrototypeOf(elm, bridge.prototype);\n    vm.component = this;\n    // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new\n    // component creation and passes hooks to instrument all the component interactions with the\n    // engine. We are intentionally hiding this argument from the formal API of LightningElement\n    // because we don't want folks to know about it just yet.\n    if (arguments.length === 1) {\n        const { callHook, setHook, getHook } = arguments[0];\n        vm.callHook = callHook;\n        vm.setHook = setHook;\n        vm.getHook = getHook;\n    }\n    markLockerLiveObject(this);\n    // Linking elm, shadow root and component with the VM.\n    associateVM(this, vm);\n    associateVM(elm, vm);\n    if (vm.renderMode === 1 /* RenderMode.Shadow */) {\n        vm.renderRoot = doAttachShadow(vm);\n    }\n    else {\n        vm.renderRoot = elm;\n    }\n    // Adding extra guard rails in DEV mode.\n    if (process.env.NODE_ENV !== 'production') {\n        patchCustomElementWithRestrictions(elm);\n    }\n    return this;\n};\nfunction doAttachShadow(vm) {\n    const { elm, mode, shadowMode, def: { ctor }, renderer: { attachShadow }, } = vm;\n    const shadowRoot = attachShadow(elm, {\n        [KEY__SYNTHETIC_MODE]: shadowMode === 1 /* ShadowMode.Synthetic */,\n        delegatesFocus: Boolean(ctor.delegatesFocus),\n        mode,\n    });\n    vm.shadowRoot = shadowRoot;\n    associateVM(shadowRoot, vm);\n    if (process.env.NODE_ENV !== 'production') {\n        patchShadowRootWithRestrictions(shadowRoot);\n    }\n    if (lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE &&\n        vm.shadowMigrateMode) {\n        applyShadowMigrateMode(shadowRoot);\n    }\n    return shadowRoot;\n}\nfunction warnIfInvokedDuringConstruction(vm, methodOrPropName) {\n    if (isBeingConstructed(vm)) {\n        logError(`this.${methodOrPropName} should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM or has no children yet.`);\n    }\n}\n// Type assertion because we need to build the prototype before it satisfies the interface.\nLightningElement.prototype = {\n    constructor: LightningElement,\n    dispatchEvent(event) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { dispatchEvent }, } = vm;\n        return dispatchEvent(elm, event);\n    },\n    addEventListener(type, listener, options) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { addEventListener }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            const vmBeingRendered = getVMBeingRendered();\n            if (isInvokingRender) {\n                logError(`${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            }\n            if (isUpdatingTemplate) {\n                logError(`Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            }\n            if (!isFunction$1(listener)) {\n                logError(`Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n            }\n        }\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        addEventListener(elm, type, wrappedListener, options);\n    },\n    removeEventListener(type, listener, options) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { removeEventListener }, } = vm;\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        removeEventListener(elm, type, wrappedListener, options);\n    },\n    hasAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getAttribute }, } = vm;\n        return !isNull(getAttribute(elm, name));\n    },\n    hasAttributeNS(namespace, name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getAttribute }, } = vm;\n        return !isNull(getAttribute(elm, name, namespace));\n    },\n    removeAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { removeAttribute }, } = vm;\n        removeAttribute(elm, name);\n    },\n    removeAttributeNS(namespace, name) {\n        const { elm, renderer: { removeAttribute }, } = getAssociatedVM(this);\n        removeAttribute(elm, name, namespace);\n    },\n    getAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm } = vm;\n        const { getAttribute } = vm.renderer;\n        return getAttribute(elm, name);\n    },\n    getAttributeNS(namespace, name) {\n        const vm = getAssociatedVM(this);\n        const { elm } = vm;\n        const { getAttribute } = vm.renderer;\n        return getAttribute(elm, name, namespace);\n    },\n    setAttribute(name, value) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { setAttribute }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            if (isBeingConstructed(vm)) {\n                logError(`Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n            }\n        }\n        setAttribute(elm, name, value);\n    },\n    setAttributeNS(namespace, name, value) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { setAttribute }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            if (isBeingConstructed(vm)) {\n                logError(`Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n            }\n        }\n        setAttribute(elm, name, value, namespace);\n    },\n    getBoundingClientRect() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getBoundingClientRect }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'getBoundingClientRect()');\n        }\n        return getBoundingClientRect(elm);\n    },\n    attachInternals() {\n        const vm = getAssociatedVM(this);\n        const { elm, apiVersion, renderer: { attachInternals }, } = vm;\n        if (!isAPIFeatureEnabled(7 /* APIFeature.ENABLE_ELEMENT_INTERNALS_AND_FACE */, apiVersion)) {\n            throw new Error(`The attachInternals API is only supported in API version 61 and above. ` +\n                `The current version is ${apiVersion}. ` +\n                `To use this API, update the LWC component API version. https://lwc.dev/guide/versioning`);\n        }\n        if (vm.shadowMode === 1 /* ShadowMode.Synthetic */) {\n            throw new Error('attachInternals API is not supported in synthetic shadow.');\n        }\n        return attachInternals(elm);\n    },\n    get isConnected() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { isConnected }, } = vm;\n        return isConnected(elm);\n    },\n    get classList() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getClassList }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            if (isBeingConstructed(vm)) {\n                logError(`Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n            }\n        }\n        return getClassList(elm);\n    },\n    get template() {\n        const vm = getAssociatedVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            if (vm.renderMode === 0 /* RenderMode.Light */) {\n                logError('`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`.');\n            }\n        }\n        return vm.shadowRoot;\n    },\n    get hostElement() {\n        const vm = getAssociatedVM(this);\n        const apiVersion = getComponentAPIVersion(vm.def.ctor);\n        if (!isAPIFeatureEnabled(8 /* APIFeature.ENABLE_THIS_DOT_HOST_ELEMENT */, apiVersion)) {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarnOnce('The `this.hostElement` API within LightningElement is ' +\n                    'only supported in API version 62 and above. Increase the API version to use it.');\n            }\n            // Simulate the old behavior for `this.hostElement` to avoid a breaking change\n            return undefined;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isTrue(vm.elm instanceof Element, `this.hostElement should be an Element, found: ${vm.elm}`);\n        }\n        return vm.elm;\n    },\n    get refs() {\n        const vm = getAssociatedVM(this);\n        if (isUpdatingTemplate) {\n            if (process.env.NODE_ENV !== 'production') {\n                logError(`this.refs should not be called while ${getComponentTag(vm)} is rendering. Use this.refs only when the DOM is stable, e.g. in renderedCallback().`);\n            }\n            // If the template is in the process of being updated, then we don't want to go through the normal\n            // process of returning the refs and caching them, because the state of the refs is unstable.\n            // This can happen if e.g. a template contains `<div class={foo}></div>` and `foo` is computed\n            // based on `this.refs.bar`.\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'refs');\n        }\n        const { refVNodes, cmpTemplate } = vm;\n        // If the `cmpTemplate` is null, that means that the template has not been rendered yet. Most likely this occurs\n        // if `this.refs` is called during the `connectedCallback` phase. The DOM elements have not been rendered yet,\n        // so log a warning. Note we also check `isBeingConstructed()` to avoid a double warning (due to\n        // `warnIfInvokedDuringConstruction` above).\n        if (process.env.NODE_ENV !== 'production' &&\n            isNull(cmpTemplate) &&\n            !isBeingConstructed(vm)) {\n            logError(`this.refs is undefined for ${getComponentTag(vm)}. This is either because the attached template has no \"lwc:ref\" directive, or this.refs was ` +\n                `invoked before renderedCallback(). Use this.refs only when the referenced HTML elements have ` +\n                `been rendered to the DOM, such as within renderedCallback() or disconnectedCallback().`);\n        }\n        // For backwards compatibility with component written before template refs\n        // were introduced, we return undefined if the template has no refs defined\n        // anywhere. This fixes components that may want to add an expando called `refs`\n        // and are checking if it exists with `if (this.refs)`  before adding it.\n        // Note we use a null refVNodes to indicate that the template has no refs defined.\n        if (isNull(refVNodes)) {\n            return;\n        }\n        // The refNodes can be cached based on the refVNodes, since the refVNodes\n        // are recreated from scratch every time the template is rendered.\n        // This happens with `vm.refVNodes = null` in `template.ts` in `@lwc/engine-core`.\n        let refs = refsCache.get(refVNodes);\n        if (isUndefined$1(refs)) {\n            refs = create(null);\n            for (const key of keys(refVNodes)) {\n                refs[key] = refVNodes[key].elm;\n            }\n            freeze(refs);\n            refsCache.set(refVNodes, refs);\n        }\n        return refs;\n    },\n    // For backwards compat, we allow component authors to set `refs` as an expando\n    set refs(value) {\n        defineProperty(this, 'refs', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value,\n        });\n    },\n    get shadowRoot() {\n        // From within the component instance, the shadowRoot is always reported as \"closed\".\n        // Authors should rely on this.template instead.\n        return null;\n    },\n    get children() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'children');\n        }\n        return renderer.getChildren(vm.elm);\n    },\n    get childNodes() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'childNodes');\n        }\n        // getChildNodes returns a NodeList, which has `item(index: number): Node | null`.\n        // NodeListOf<T> extends NodeList, but claims to not return null. That seems inaccurate,\n        // but these are built-in types, so ultimately not our problem.\n        return renderer.getChildNodes(vm.elm);\n    },\n    get firstChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'firstChild');\n        }\n        return renderer.getFirstChild(vm.elm);\n    },\n    get firstElementChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'firstElementChild');\n        }\n        return renderer.getFirstElementChild(vm.elm);\n    },\n    get lastChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'lastChild');\n        }\n        return renderer.getLastChild(vm.elm);\n    },\n    get lastElementChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'lastElementChild');\n        }\n        return renderer.getLastElementChild(vm.elm);\n    },\n    get ownerDocument() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'ownerDocument');\n        }\n        return renderer.ownerDocument(vm.elm);\n    },\n    get tagName() {\n        const { elm, renderer } = getAssociatedVM(this);\n        return renderer.getTagName(elm);\n    },\n    get style() {\n        const { elm, renderer, def } = getAssociatedVM(this);\n        const apiVersion = getComponentAPIVersion(def.ctor);\n        if (!isAPIFeatureEnabled(9 /* APIFeature.ENABLE_THIS_DOT_STYLE */, apiVersion)) {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarnOnce('The `this.style` API within LightningElement returning the CSSStyleDeclaration is ' +\n                    'only supported in API version 62 and above. Increase the API version to use it.');\n            }\n            // Simulate the old behavior for `this.style` to avoid a breaking change\n            return undefined;\n        }\n        return renderer.getStyle(elm);\n    },\n    render() {\n        const vm = getAssociatedVM(this);\n        return vm.def.template;\n    },\n    toString() {\n        const vm = getAssociatedVM(this);\n        return `[object ${vm.def.name}]`;\n    },\n};\nconst queryAndChildGetterDescriptors = create(null);\nconst queryMethods = [\n    'getElementsByClassName',\n    'getElementsByTagName',\n    'querySelector',\n    'querySelectorAll',\n];\n// Generic passthrough for query APIs on HTMLElement to the relevant Renderer APIs\nfor (const queryMethod of queryMethods) {\n    queryAndChildGetterDescriptors[queryMethod] = {\n        value(arg) {\n            const vm = getAssociatedVM(this);\n            const { elm, renderer } = vm;\n            if (process.env.NODE_ENV !== 'production') {\n                warnIfInvokedDuringConstruction(vm, `${queryMethod}()`);\n            }\n            return renderer[queryMethod](elm, arg);\n        },\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    };\n}\ndefineProperties(LightningElement.prototype, queryAndChildGetterDescriptors);\nconst lightningBasedDescriptors = create(null);\nfor (const propName in HTMLElementOriginalDescriptors) {\n    lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n}\n// Apply ARIA reflection to LightningElement.prototype, on both the browser and server.\n// This allows `this.aria*` property accessors to work from inside a component, and to reflect `aria-*` attrs.\n// Note this works regardless of whether the global ARIA reflection polyfill is applied or not.\n{\n    // In the browser, we use createBridgeToElementDescriptor, so we can get the normal reactivity lifecycle for\n    // aria* properties\n    for (const [propName, descriptor] of entries(ariaReflectionPolyfillDescriptors)) {\n        lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, descriptor);\n    }\n}\ndefineProperties(LightningElement.prototype, lightningBasedDescriptors);\ndefineProperty(LightningElement, 'CustomElementConstructor', {\n    get() {\n        // If required, a runtime-specific implementation must be defined.\n        throw new ReferenceError('The current runtime does not support CustomElementConstructor.');\n    },\n    configurable: true,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction createObservedFieldPropertyDescriptor(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            const val = vm.cmpFields[key];\n            componentValueObserved(vm, key, val);\n            return val;\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            updateComponentValue(vm, key, newValue);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst AdapterToTokenMap = new Map();\nfunction createContextProviderWithRegister(adapter, registerContextProvider) {\n    if (AdapterToTokenMap.has(adapter)) {\n        throw new Error(`Adapter already has a context provider.`);\n    }\n    const adapterContextToken = guid();\n    AdapterToTokenMap.set(adapter, adapterContextToken);\n    const providers = new WeakSet();\n    return (elmOrComponent, options) => {\n        if (providers.has(elmOrComponent)) {\n            throw new Error(`Adapter was already installed on ${elmOrComponent}.`);\n        }\n        providers.add(elmOrComponent);\n        const { consumerConnectedCallback, consumerDisconnectedCallback } = options;\n        registerContextProvider(elmOrComponent, adapterContextToken, (subscriptionPayload) => {\n            const { setNewContext, setDisconnectedCallback } = subscriptionPayload;\n            const consumer = {\n                provide(newContext) {\n                    setNewContext(newContext);\n                },\n            };\n            const disconnectCallback = () => {\n                if (!isUndefined$1(consumerDisconnectedCallback)) {\n                    consumerDisconnectedCallback(consumer);\n                }\n            };\n            setDisconnectedCallback(disconnectCallback);\n            consumerConnectedCallback(consumer);\n        });\n    };\n}\nfunction createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {\n    const { adapter } = wireDef;\n    const adapterContextToken = AdapterToTokenMap.get(adapter);\n    if (isUndefined$1(adapterContextToken)) {\n        return; // no provider found, nothing to be done\n    }\n    const { elm, context: { wiredConnecting, wiredDisconnecting }, renderer: { registerContextConsumer }, } = vm;\n    // waiting for the component to be connected to formally request the context via the token\n    ArrayPush$1.call(wiredConnecting, () => {\n        // This will attempt to connect the current element with one of its anscestors\n        // that can provide context for the given wire adapter. This relationship is\n        // keyed on the secret & internal value of `adapterContextToken`, which is unique\n        // to a given wire adapter.\n        //\n        // Depending on the runtime environment, this connection is made using either DOM\n        // events (in the browser) or a custom traversal (on the server).\n        registerContextConsumer(elm, adapterContextToken, {\n            setNewContext(newContext) {\n                // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo\n                // TODO: dev-mode validation of config based on the adapter.contextSchema\n                callbackWhenContextIsReady(newContext);\n            },\n            setDisconnectedCallback(disconnectCallback) {\n                // adds this callback into the disconnect bucket so it gets disconnected from parent\n                // the the element hosting the wire is disconnected\n                ArrayPush$1.call(wiredDisconnecting, disconnectCallback);\n            },\n        });\n    });\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';\nconst DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';\nconst WIRE_DEBUG_ENTRY = '@wire';\nconst WireMetaMap = new Map();\nfunction createFieldDataCallback(vm, name) {\n    return (value) => {\n        updateComponentValue(vm, name, value);\n    };\n}\nfunction createMethodDataCallback(vm, method) {\n    return (value) => {\n        // dispatching new value into the wired method\n        runWithBoundaryProtection(vm, vm.owner, noop, () => {\n            // job\n            method.call(vm.component, value);\n        }, noop);\n    };\n}\nfunction createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {\n    let hasPendingConfig = false;\n    // creating the reactive observer for reactive params when needed\n    const ro = createReactiveObserver(() => {\n        if (hasPendingConfig === false) {\n            hasPendingConfig = true;\n            // collect new config in the micro-task\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            Promise.resolve().then(() => {\n                hasPendingConfig = false;\n                // resetting current reactive params\n                ro.reset();\n                // dispatching a new config due to a change in the configuration\n                computeConfigAndUpdate();\n            });\n        }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        associateReactiveObserverWithVM(ro, getAssociatedVM(component));\n    }\n    const computeConfigAndUpdate = () => {\n        let config;\n        ro.observe(() => (config = configCallback(component)));\n        // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo\n        // TODO: dev-mode validation of config based on the adapter.configSchema\n        // @ts-expect-error it is assigned in the observe() callback\n        callbackWhenConfigIsReady(config);\n    };\n    return {\n        computeConfigAndUpdate,\n        ro,\n    };\n}\nfunction createConnector(vm, name, wireDef) {\n    const { method, adapter, configCallback, dynamic } = wireDef;\n    let debugInfo;\n    if (process.env.NODE_ENV !== 'production') {\n        const wiredPropOrMethod = isUndefined$1(method) ? name : method.name;\n        debugInfo = create(null);\n        debugInfo.wasDataProvisionedForConfig = false;\n        vm.debugInfo[WIRE_DEBUG_ENTRY][wiredPropOrMethod] = debugInfo;\n    }\n    const fieldOrMethodCallback = isUndefined$1(method)\n        ? createFieldDataCallback(vm, name)\n        : createMethodDataCallback(vm, method);\n    const dataCallback = (value) => {\n        if (process.env.NODE_ENV !== 'production') {\n            debugInfo.data = value;\n            // Note: most of the time, the data provided is for the current config, but there may be\n            // some conditions in which it does not, ex:\n            // race conditions in a poor network while the adapter does not cancel a previous request.\n            debugInfo.wasDataProvisionedForConfig = true;\n        }\n        fieldOrMethodCallback(value);\n    };\n    let context;\n    let connector;\n    // Workaround to pass the component element associated to this wire adapter instance.\n    defineProperty(dataCallback, DeprecatedWiredElementHost, {\n        value: vm.elm,\n    });\n    defineProperty(dataCallback, DeprecatedWiredParamsMeta, {\n        value: dynamic,\n    });\n    runWithBoundaryProtection(vm, vm, noop, () => {\n        // job\n        connector = new adapter(dataCallback, { tagName: vm.tagName });\n    }, noop);\n    const updateConnectorConfig = (config) => {\n        // every time the config is recomputed due to tracking,\n        // this callback will be invoked with the new computed config\n        runWithBoundaryProtection(vm, vm, noop, () => {\n            // job\n            if (process.env.NODE_ENV !== 'production') {\n                debugInfo.config = config;\n                debugInfo.context = context;\n                debugInfo.wasDataProvisionedForConfig = false;\n            }\n            connector.update(config, context);\n        }, noop);\n    };\n    // Computes the current wire config and calls the update method on the wire adapter.\n    // If it has params, we will need to observe changes in the next tick.\n    const { computeConfigAndUpdate, ro } = createConfigWatcher(vm.component, configCallback, updateConnectorConfig);\n    // if the adapter needs contextualization, we need to watch for new context and push it alongside the config\n    if (!isUndefined$1(adapter.contextSchema)) {\n        createContextWatcher(vm, wireDef, (newContext) => {\n            // every time the context is pushed into this component,\n            // this callback will be invoked with the new computed context\n            if (context !== newContext) {\n                context = newContext;\n                // Note: when new context arrives, the config will be recomputed and pushed along side the new\n                // context, this is to preserve the identity characteristics, config should not have identity\n                // (ever), while context can have identity\n                if (vm.state === 1 /* VMState.connected */) {\n                    computeConfigAndUpdate();\n                }\n            }\n        });\n    }\n    return {\n        // @ts-expect-error the boundary protection executes sync, connector is always defined\n        connector,\n        computeConfigAndUpdate,\n        resetConfigWatcher: () => ro.reset(),\n    };\n}\nfunction storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {\n    // support for callable adapters\n    if (adapter.adapter) {\n        adapter = adapter.adapter;\n    }\n    const method = descriptor.value;\n    const def = {\n        adapter,\n        method,\n        configCallback,\n        dynamic,\n    };\n    WireMetaMap.set(descriptor, def);\n}\nfunction storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {\n    // support for callable adapters\n    if (adapter.adapter) {\n        adapter = adapter.adapter;\n    }\n    const def = {\n        adapter,\n        configCallback,\n        dynamic,\n    };\n    WireMetaMap.set(descriptor, def);\n}\nfunction installWireAdapters(vm) {\n    const { context, def: { wire }, } = vm;\n    if (process.env.NODE_ENV !== 'production') {\n        vm.debugInfo[WIRE_DEBUG_ENTRY] = create(null);\n    }\n    const wiredConnecting = (context.wiredConnecting = []);\n    const wiredDisconnecting = (context.wiredDisconnecting =\n        []);\n    for (const fieldNameOrMethod in wire) {\n        const descriptor = wire[fieldNameOrMethod];\n        const wireDef = WireMetaMap.get(descriptor);\n        if (process.env.NODE_ENV !== 'production') {\n            assert.invariant(wireDef, `Internal Error: invalid wire definition found.`);\n        }\n        if (!isUndefined$1(wireDef)) {\n            const { connector, computeConfigAndUpdate, resetConfigWatcher } = createConnector(vm, fieldNameOrMethod, wireDef);\n            const hasDynamicParams = wireDef.dynamic.length > 0;\n            ArrayPush$1.call(wiredConnecting, () => {\n                connector.connect();\n                if (!lwcRuntimeFlags.ENABLE_WIRE_SYNC_EMIT) {\n                    if (hasDynamicParams) {\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                        Promise.resolve().then(computeConfigAndUpdate);\n                        return;\n                    }\n                }\n                computeConfigAndUpdate();\n            });\n            ArrayPush$1.call(wiredDisconnecting, () => {\n                connector.disconnect();\n                resetConfigWatcher();\n            });\n        }\n    }\n}\nfunction connectWireAdapters(vm) {\n    const { wiredConnecting } = vm.context;\n    for (let i = 0, len = wiredConnecting.length; i < len; i += 1) {\n        wiredConnecting[i]();\n    }\n}\nfunction disconnectWireAdapters(vm) {\n    const { wiredDisconnecting } = vm.context;\n    runWithBoundaryProtection(vm, vm, noop, () => {\n        // job\n        for (let i = 0, len = wiredDisconnecting.length; i < len; i += 1) {\n            wiredDisconnecting[i]();\n        }\n    }, noop);\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * The `@api` decorator marks public fields and public methods in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\nfunction api$1(\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvalue, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ncontext) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`@api decorator can only be used as a decorator function.`);\n    }\n    throw new Error();\n}\nfunction createPublicPropertyDescriptor(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            if (isBeingConstructed(vm)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logError(`Canâ€™t read the value of property \\`${toString(key)}\\` from the constructor because the owner component hasnâ€™t set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n                }\n                return;\n            }\n            const val = vm.cmpProps[key];\n            componentValueObserved(vm, key, val);\n            return val;\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                if (isInvokingRender) {\n                    logError(`render() method has side effects on the state of property \"${toString(key)}\"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);\n                }\n                if (isUpdatingTemplate) {\n                    logError(`Updating the template has side effects on the state of property \"${toString(key)}\"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);\n                }\n            }\n            vm.cmpProps[key] = newValue;\n            componentValueMutated(vm, key);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\nfunction createPublicAccessorDescriptor(key, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    assert.invariant(isFunction$1(get), `Invalid public accessor ${toString(key)} decorated with @api. The property is missing a getter.`);\n    return {\n        get() {\n            if (process.env.NODE_ENV !== 'production') {\n                // Assert that the this value is an actual Component with an associated VM.\n                getAssociatedVM(this);\n            }\n            return get.call(this);\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                if (isInvokingRender) {\n                    logError(`render() method has side effects on the state of property \"${toString(key)}\"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);\n                }\n                if (isUpdatingTemplate) {\n                    logError(`Updating the template has side effects on the state of property \"${toString(key)}\"`, isNull(vmBeingRendered) ? vm : vmBeingRendered);\n                }\n            }\n            if (set) {\n                set.call(this, newValue);\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logError(`Invalid attempt to set a new value for property \"${toString(key)}\" that does not has a setter decorated with @api.`, vm);\n            }\n        },\n        enumerable,\n        configurable,\n    };\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ncontext) {\n    if (arguments.length === 1) {\n        return getReactiveProxy(target);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n    }\n    throw new Error();\n}\nfunction internalTrackDecorator(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            const val = vm.cmpFields[key];\n            componentValueObserved(vm, key, val);\n            return val;\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                if (isInvokingRender) {\n                    logError(`${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n                }\n                if (isUpdatingTemplate) {\n                    logError(`Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString(key)}`);\n                }\n            }\n            const reactiveOrAnyValue = getReactiveProxy(newValue);\n            if (process.env.NODE_ENV !== 'production') {\n                trackTargetForMutationLogging(key, newValue);\n            }\n            updateComponentValue(vm, key, reactiveOrAnyValue);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * Decorator factory to wire a property or method to a wire adapter data source.\n * @param adapter the adapter used to provision data\n * @param config configuration object for the adapter\n * @returns A decorator function\n * @example\n * export default class WireExample extends LightningElement {\n *   \\@api bookId;\n *   \\@wire(getBook, { id: '$bookId'}) book;\n * }\n */\nfunction wire(\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nadapter, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconfig) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.fail('@wire(adapter, config?) may only be used as a decorator.');\n    }\n    throw new Error();\n}\nfunction internalWireFieldDecorator(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(value) {\n            const vm = getAssociatedVM(this);\n            /**\n             * Reactivity for wired fields is provided in wiring.\n             * We intentionally add reactivity here since this is just\n             * letting the author to do the wrong thing, but it will keep our\n             * system to be backward compatible.\n             */\n            updateComponentValue(vm, key, value);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getClassDescriptorType(descriptor) {\n    if (isFunction$1(descriptor.value)) {\n        return 'method';\n    }\n    else if (isFunction$1(descriptor.set) || isFunction$1(descriptor.get)) {\n        return 'accessor';\n    }\n    else {\n        return 'field';\n    }\n}\nfunction validateObservedField(Ctor, fieldName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        const message = `Invalid observed ${fieldName} field. Found a duplicate ${type} with the same name.`;\n        // TODO [#3408]: this should throw, not log\n        logError(message);\n    }\n}\nfunction validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        // TODO [#3408]: this should throw, not log\n        logError(`Invalid @track ${fieldName} field. Found a duplicate ${type} with the same name.`);\n    }\n}\nfunction validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        // TODO [#3408]: this should throw, not log\n        logError(`Invalid @wire ${fieldName} field. Found a duplicate ${type} with the same name.`);\n    }\n}\nfunction validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {\n        // TODO [#3441]: This line of code does not seem possible to reach.\n        logError(`Invalid @wire ${methodName} field. The field should have a valid writable descriptor.`);\n    }\n}\nfunction validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        const message = `Invalid @api ${fieldName} field. Found a duplicate ${type} with the same name.`;\n        // TODO [#3408]: this should throw, not log\n        logError(message);\n    }\n}\nfunction validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (isFunction$1(descriptor.set)) {\n        if (!isFunction$1(descriptor.get)) {\n            // TODO [#3441]: This line of code does not seem possible to reach.\n            logError(`Missing getter for property ${fieldName} decorated with @api in ${Ctor}. You cannot have a setter without the corresponding getter.`);\n        }\n    }\n    else if (!isFunction$1(descriptor.get)) {\n        // TODO [#3441]: This line of code does not seem possible to reach.\n        logError(`Missing @api get ${fieldName} accessor.`);\n    }\n}\nfunction validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {\n    assertNotProd(); // this method should never leak to prod\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {\n        // TODO [#3441]: This line of code does not seem possible to reach.\n        logError(`Invalid @api ${methodName} method.`);\n    }\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by user-land code.\n * @param Ctor\n * @param meta\n */\nfunction registerDecorators(Ctor, meta) {\n    const proto = Ctor.prototype;\n    const { publicProps, publicMethods, wire, track, fields } = meta;\n    const apiMethods = create(null);\n    const apiFields = create(null);\n    const wiredMethods = create(null);\n    const wiredFields = create(null);\n    const observedFields = create(null);\n    const apiFieldsConfig = create(null);\n    let descriptor;\n    if (!isUndefined$1(publicProps)) {\n        for (const fieldName in publicProps) {\n            const propConfig = publicProps[fieldName];\n            apiFieldsConfig[fieldName] = propConfig.config;\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (propConfig.config > 0) {\n                if (isUndefined$1(descriptor)) {\n                    // TODO [#3441]: This line of code does not seem possible to reach.\n                    throw new Error();\n                }\n                // accessor declaration\n                if (process.env.NODE_ENV !== 'production') {\n                    validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);\n                }\n                descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n            }\n            else {\n                // field declaration\n                if (process.env.NODE_ENV !== 'production') {\n                    validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);\n                }\n                // [W-9927596] If a component has both a public property and a private setter/getter\n                // with the same name, the property is defined as a public accessor. This branch is\n                // only here for backward compatibility reasons.\n                if (!isUndefined$1(descriptor) && !isUndefined$1(descriptor.get)) {\n                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n                }\n                else {\n                    descriptor = createPublicPropertyDescriptor(fieldName);\n                }\n            }\n            apiFields[fieldName] = descriptor;\n            defineProperty(proto, fieldName, descriptor);\n        }\n    }\n    if (!isUndefined$1(publicMethods)) {\n        forEach.call(publicMethods, (methodName) => {\n            descriptor = getOwnPropertyDescriptor$1(proto, methodName);\n            if (process.env.NODE_ENV !== 'production') {\n                validateMethodDecoratedWithApi(Ctor, methodName, descriptor);\n            }\n            if (isUndefined$1(descriptor)) {\n                throw new Error();\n            }\n            apiMethods[methodName] = descriptor;\n        });\n    }\n    if (!isUndefined$1(wire)) {\n        for (const fieldOrMethodName in wire) {\n            const { adapter, method, config: configCallback, dynamic = [], } = wire[fieldOrMethodName];\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);\n            if (method === 1) {\n                if (process.env.NODE_ENV !== 'production') {\n                    if (!adapter) {\n                        // TODO [#3408]: this should throw, not log\n                        logError(`@wire on method \"${fieldOrMethodName}\": adapter id must be truthy.`);\n                    }\n                    validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n                }\n                if (isUndefined$1(descriptor)) {\n                    throw new Error();\n                }\n                wiredMethods[fieldOrMethodName] = descriptor;\n                storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);\n            }\n            else {\n                if (process.env.NODE_ENV !== 'production') {\n                    if (!adapter) {\n                        // TODO [#3408]: this should throw, not log\n                        logError(`@wire on field \"${fieldOrMethodName}\": adapter id must be truthy.`);\n                    }\n                    validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n                }\n                descriptor = internalWireFieldDecorator(fieldOrMethodName);\n                wiredFields[fieldOrMethodName] = descriptor;\n                storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);\n                defineProperty(proto, fieldOrMethodName, descriptor);\n            }\n        }\n    }\n    if (!isUndefined$1(track)) {\n        for (const fieldName in track) {\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (process.env.NODE_ENV !== 'production') {\n                validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);\n            }\n            descriptor = internalTrackDecorator(fieldName);\n            defineProperty(proto, fieldName, descriptor);\n        }\n    }\n    if (!isUndefined$1(fields)) {\n        for (let i = 0, n = fields.length; i < n; i++) {\n            const fieldName = fields[i];\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (process.env.NODE_ENV !== 'production') {\n                validateObservedField(Ctor, fieldName, descriptor);\n            }\n            // [W-9927596] Only mark a field as observed whenever it isn't a duplicated public nor\n            // tracked property. This is only here for backward compatibility purposes.\n            const isDuplicatePublicProp = !isUndefined$1(publicProps) && fieldName in publicProps;\n            const isDuplicateTrackedProp = !isUndefined$1(track) && fieldName in track;\n            if (!isDuplicatePublicProp && !isDuplicateTrackedProp) {\n                observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);\n            }\n        }\n    }\n    setDecoratorsMeta(Ctor, {\n        apiMethods,\n        apiFields,\n        apiFieldsConfig,\n        wiredMethods,\n        wiredFields,\n        observedFields,\n    });\n    return Ctor;\n}\nconst signedDecoratorToMetaMap = new Map();\nfunction setDecoratorsMeta(Ctor, meta) {\n    signedDecoratorToMetaMap.set(Ctor, meta);\n}\nconst defaultMeta = {\n    apiMethods: EmptyObject,\n    apiFields: EmptyObject,\n    apiFieldsConfig: EmptyObject,\n    wiredMethods: EmptyObject,\n    wiredFields: EmptyObject,\n    observedFields: EmptyObject,\n};\nfunction getDecoratorsMeta(Ctor) {\n    const meta = signedDecoratorToMetaMap.get(Ctor);\n    return isUndefined$1(meta) ? defaultMeta : meta;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet warned = false;\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    window.__lwcResetWarnedOnVersionMismatch = () => {\n        warned = false;\n    };\n}\nfunction checkVersionMismatch(func, type) {\n    const versionMatcher = func.toString().match(LWC_VERSION_COMMENT_REGEX);\n    if (!isNull(versionMatcher) && !warned) {\n        const version = versionMatcher[1];\n        if (version !== LWC_VERSION) {\n            warned = true; // only warn once to avoid flooding the console\n            // stylesheets and templates do not have user-meaningful names, but components do\n            const friendlyName = type === 'component' ? `${type} ${func.name}` : type;\n            logError(`LWC WARNING: current engine is v${LWC_VERSION}, but ${friendlyName} was compiled with v${version}.\\nPlease update your compiled code or LWC engine so that the versions match.\\nNo further warnings will appear.`);\n            report(\"CompilerRuntimeVersionMismatch\" /* ReportingEventId.CompilerRuntimeVersionMismatch */, {\n                compilerVersion: version,\n                runtimeVersion: LWC_VERSION,\n            });\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n    return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n    return signedTemplateSet.has(tpl);\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n * @param tpl\n */\nfunction registerTemplate(tpl) {\n    if (process.env.NODE_ENV !== 'production') {\n        checkVersionMismatch(tpl, 'template');\n    }\n    signedTemplateSet.add(tpl);\n    // chaining this method as a way to wrap existing\n    // assignment of templates easily, without too much transformation\n    return tpl;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar\n * libraries to sanitize vulnerable attributes.\n * @param tagName\n * @param namespaceUri\n * @param attrName\n * @param attrValue\n */\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n    // locker-service patches this function during runtime to sanitize vulnerable attributes. When\n    // ran off-core this function becomes a noop and returns the user authored value.\n    return attrValue;\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This module is responsible for creating the base bridge class BaseBridgeElement\n * that represents the HTMLElement extension used for any LWC inserted in the DOM.\n */\n// A bridge descriptor is a descriptor whose job is just to get the component instance\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\nconst cachedGetterByKey = create(null);\nconst cachedSetterByKey = create(null);\nfunction createGetter(key) {\n    let fn = cachedGetterByKey[key];\n    if (isUndefined$1(fn)) {\n        fn = cachedGetterByKey[key] = function () {\n            const vm = getAssociatedVM(this);\n            const { getHook } = vm;\n            return getHook(vm.component, key);\n        };\n    }\n    return fn;\n}\nfunction createSetter(key) {\n    let fn = cachedSetterByKey[key];\n    if (isUndefined$1(fn)) {\n        fn = cachedSetterByKey[key] = function (newValue) {\n            const vm = getAssociatedVM(this);\n            const { setHook } = vm;\n            newValue = getReadOnlyProxy(newValue);\n            setHook(vm.component, key, newValue);\n        };\n    }\n    return fn;\n}\nfunction createMethodCaller(methodName) {\n    return function () {\n        const vm = getAssociatedVM(this);\n        const { callHook, component } = vm;\n        const fn = component[methodName];\n        return callHook(vm.component, fn, ArraySlice.call(arguments));\n    };\n}\nfunction createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {\n    return function attributeChangedCallback(attrName, oldValue, newValue) {\n        if (oldValue === newValue) {\n            // Ignore same values.\n            return;\n        }\n        const propName = attributeToPropMap[attrName];\n        if (isUndefined$1(propName)) {\n            if (!isUndefined$1(superAttributeChangedCallback)) {\n                // delegate unknown attributes to the super.\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-expect-error type-mismatch\n                superAttributeChangedCallback.apply(this, arguments);\n            }\n            return;\n        }\n        // Reflect attribute change to the corresponding property when changed from outside.\n        this[propName] = newValue;\n    };\n}\nfunction createAccessorThatWarns(propName) {\n    let prop;\n    return {\n        get() {\n            logWarn(`The property \"${propName}\" is not publicly accessible. Add the @api annotation to the property declaration or getter/setter in the component to make it accessible.`);\n            return prop;\n        },\n        set(value) {\n            logWarn(`The property \"${propName}\" is not publicly accessible. Add the @api annotation to the property declaration or getter/setter in the component to make it accessible.`);\n            prop = value;\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\nfunction HTMLBridgeElementFactory(SuperClass, publicProperties, methods, observedFields, proto, hasCustomSuperClass) {\n    const HTMLBridgeElement = class extends SuperClass {\n    };\n    // generating the hash table for attributes to avoid duplicate fields and facilitate validation\n    // and false positives in case of inheritance.\n    const attributeToPropMap = create(null);\n    const { attributeChangedCallback: superAttributeChangedCallback } = SuperClass.prototype;\n    const { observedAttributes: superObservedAttributes = [] } = SuperClass;\n    const descriptors = create(null);\n    // present a hint message so that developers are aware that they have not decorated property with @api\n    // Note that we also don't do this in SSR because we cannot sniff for what props are declared on\n    // HTMLElementPrototype, and it seems not worth it to have these dev-only warnings there, since\n    // an `in` check could mistakenly assume that a prop is declared on a LightningElement prototype.\n    if (process.env.NODE_ENV !== 'production' && true) {\n        // TODO [#3761]: enable for components that don't extend from LightningElement\n        if (!isUndefined$1(proto) && !isNull(proto) && !hasCustomSuperClass) {\n            const nonPublicPropertiesToWarnOn = new Set([\n                // getters, setters, and methods\n                ...keys(getOwnPropertyDescriptors(proto)),\n                // class properties\n                ...observedFields,\n            ]\n                // we don't want to override HTMLElement props because these are meaningful in other ways,\n                // and can break tooling that expects it to be iterable or defined, e.g. Jest:\n                // https://github.com/jestjs/jest/blob/b4c9587/packages/pretty-format/src/plugins/DOMElement.ts#L95\n                // It also doesn't make sense to override e.g. \"constructor\".\n                .filter((propName) => !(propName in HTMLElementPrototype) &&\n                !(propName in ariaReflectionPolyfillDescriptors)));\n            for (const propName of nonPublicPropertiesToWarnOn) {\n                if (ArrayIndexOf.call(publicProperties, propName) === -1) {\n                    descriptors[propName] = createAccessorThatWarns(propName);\n                }\n            }\n        }\n    }\n    // expose getters and setters for each public props on the new Element Bridge\n    for (let i = 0, len = publicProperties.length; i < len; i += 1) {\n        const propName = publicProperties[i];\n        attributeToPropMap[htmlPropertyToAttribute(propName)] = propName;\n        descriptors[propName] = {\n            get: createGetter(propName),\n            set: createSetter(propName),\n            enumerable: true,\n            configurable: true,\n        };\n    }\n    // expose public methods as props on the new Element Bridge\n    for (let i = 0, len = methods.length; i < len; i += 1) {\n        const methodName = methods[i];\n        descriptors[methodName] = {\n            value: createMethodCaller(methodName),\n            writable: true,\n            configurable: true,\n        };\n    }\n    // creating a new attributeChangedCallback per bridge because they are bound to the corresponding\n    // map of attributes to props. We do this after all other props and methods to avoid the possibility\n    // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable\n    // to preserve this definition.\n    descriptors.attributeChangedCallback = {\n        value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback),\n    };\n    // To avoid leaking private component details, accessing internals from outside a component is not allowed.\n    descriptors.attachInternals = {\n        set() {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarn('attachInternals cannot be accessed outside of a component. Use this.attachInternals instead.');\n            }\n        },\n        get() {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarn('attachInternals cannot be accessed outside of a component. Use this.attachInternals instead.');\n            }\n        },\n    };\n    descriptors.formAssociated = {\n        set() {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarn('formAssociated cannot be accessed outside of a component. Set the value within the component class.');\n            }\n        },\n        get() {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarn('formAssociated cannot be accessed outside of a component. Set the value within the component class.');\n            }\n        },\n    };\n    // Specify attributes for which we want to reflect changes back to their corresponding\n    // properties via attributeChangedCallback.\n    defineProperty(HTMLBridgeElement, 'observedAttributes', {\n        get() {\n            return [...superObservedAttributes, ...keys(attributeToPropMap)];\n        },\n    });\n    defineProperties(HTMLBridgeElement.prototype, descriptors);\n    return HTMLBridgeElement;\n}\n// We do some special handling of non-standard ARIA props like ariaLabelledBy as well as props without (as of this\n// writing) broad cross-browser support like ariaBrailleLabel. This is so the reflection works correctly and preserves\n// backwards compatibility with the previous global polyfill approach.\n//\n// The goal here is to expose `elm.aria*` property accessors to work from outside a component, and to reflect `aria-*`\n// attrs. This is especially important because the template compiler compiles aria-* attrs on components to aria* props.\n// Note this works regardless of whether the global ARIA reflection polyfill is applied or not.\n//\n// Also note this ARIA reflection only really makes sense in the browser. On the server, there is no\n// `renderedCallback()`, so you cannot do e.g. `this.template.querySelector('x-child').ariaBusy = 'true'`. So we don't\n// need to expose ARIA props outside the LightningElement\nconst basePublicProperties = [\n    ...getOwnPropertyNames$1(HTMLElementOriginalDescriptors),\n    ...(getOwnPropertyNames$1(ariaReflectionPolyfillDescriptors) ),\n];\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, basePublicProperties, [], [], null, false);\nfreeze(BaseBridgeElement);\nseal(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// These are only used for HMR in dev mode\n// The \"pure\" annotations are so that Rollup knows for sure it can remove these from prod mode\nlet stylesheetsToCssContent = /*@__PURE__@*/ new WeakMap();\nlet cssContentToAbortControllers = /*@__PURE__@*/ new Map();\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    // Used to reset the global state between test runs\n    window.__lwcResetStylesheetCache = () => {\n        stylesheetsToCssContent = new WeakMap();\n        cssContentToAbortControllers = new Map();\n    };\n}\nfunction linkStylesheetToCssContentInDevMode(stylesheet, cssContent) {\n    // Should never leak to prod; only used for HMR\n    assertNotProd();\n    let cssContents = stylesheetsToCssContent.get(stylesheet);\n    if (isUndefined$1(cssContents)) {\n        cssContents = new Set();\n        stylesheetsToCssContent.set(stylesheet, cssContents);\n    }\n    cssContents.add(cssContent);\n}\nfunction getOrCreateAbortControllerInDevMode(cssContent) {\n    // Should never leak to prod; only used for HMR\n    assertNotProd();\n    let abortController = cssContentToAbortControllers.get(cssContent);\n    if (isUndefined$1(abortController)) {\n        abortController = new AbortController();\n        cssContentToAbortControllers.set(cssContent, abortController);\n    }\n    return abortController;\n}\nfunction getOrCreateAbortSignal(cssContent) {\n    // abort controller/signal is only used for HMR in development\n    if (process.env.NODE_ENV !== 'production') {\n        return getOrCreateAbortControllerInDevMode(cssContent).signal;\n    }\n    return undefined;\n}\nfunction makeHostToken(token) {\n    // Note: if this ever changes, update the `cssScopeTokens` returned by `@lwc/compiler`\n    return `${token}-host`;\n}\nfunction createInlineStyleVNode(content) {\n    return api.h('style', {\n        key: 'style', // special key\n        attrs: {\n            type: 'text/css',\n        },\n    }, [api.t(content)]);\n}\n// TODO [#3733]: remove support for legacy scope tokens\nfunction updateStylesheetToken(vm, template, legacy) {\n    const { elm, context, renderMode, shadowMode, renderer: { getClassList, removeAttribute, setAttribute }, } = vm;\n    const { stylesheets: newStylesheets } = template;\n    const newStylesheetToken = legacy ? template.legacyStylesheetToken : template.stylesheetToken;\n    const { stylesheets: newVmStylesheets } = vm;\n    const isSyntheticShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */;\n    const { hasScopedStyles } = context;\n    let newToken;\n    let newHasTokenInClass;\n    let newHasTokenInAttribute;\n    // Reset the styling token applied to the host element.\n    let oldToken;\n    let oldHasTokenInClass;\n    let oldHasTokenInAttribute;\n    if (legacy) {\n        oldToken = context.legacyStylesheetToken;\n        oldHasTokenInClass = context.hasLegacyTokenInClass;\n        oldHasTokenInAttribute = context.hasLegacyTokenInAttribute;\n    }\n    else {\n        oldToken = context.stylesheetToken;\n        oldHasTokenInClass = context.hasTokenInClass;\n        oldHasTokenInAttribute = context.hasTokenInAttribute;\n    }\n    if (!isUndefined$1(oldToken)) {\n        if (oldHasTokenInClass) {\n            getClassList(elm).remove(makeHostToken(oldToken));\n        }\n        if (oldHasTokenInAttribute) {\n            removeAttribute(elm, makeHostToken(oldToken));\n        }\n    }\n    // Apply the new template styling token to the host element, if the new template has any\n    // associated stylesheets. In the case of light DOM, also ensure there is at least one scoped stylesheet.\n    const hasNewStylesheets = hasStyles(newStylesheets);\n    const hasNewVmStylesheets = hasStyles(newVmStylesheets);\n    if (hasNewStylesheets || hasNewVmStylesheets) {\n        newToken = newStylesheetToken;\n    }\n    // Set the new styling token on the host element\n    if (!isUndefined$1(newToken)) {\n        if (hasScopedStyles) {\n            const hostScopeTokenClass = makeHostToken(newToken);\n            getClassList(elm).add(hostScopeTokenClass);\n            newHasTokenInClass = true;\n        }\n        if (isSyntheticShadow) {\n            setAttribute(elm, makeHostToken(newToken), '');\n            newHasTokenInAttribute = true;\n        }\n    }\n    // Update the styling tokens present on the context object.\n    if (legacy) {\n        context.legacyStylesheetToken = newToken;\n        context.hasLegacyTokenInClass = newHasTokenInClass;\n        context.hasLegacyTokenInAttribute = newHasTokenInAttribute;\n    }\n    else {\n        context.stylesheetToken = newToken;\n        context.hasTokenInClass = newHasTokenInClass;\n        context.hasTokenInAttribute = newHasTokenInAttribute;\n    }\n}\nfunction evaluateStylesheetsContent(stylesheets, stylesheetToken, vm) {\n    const content = [];\n    let root;\n    for (let i = 0; i < stylesheets.length; i++) {\n        let stylesheet = stylesheets[i];\n        if (isArray$1(stylesheet)) {\n            ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, stylesheetToken, vm));\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                // Check for compiler version mismatch in dev mode only\n                checkVersionMismatch(stylesheet, 'stylesheet');\n                // in dev-mode, we support hot swapping of stylesheet, which means that\n                // the component instance might be attempting to use an old version of\n                // the stylesheet, while internally, we have a replacement for it.\n                stylesheet = getStyleOrSwappedStyle(stylesheet);\n            }\n            const isScopedCss = isTrue(stylesheet[KEY__SCOPED_CSS]);\n            const isNativeOnlyCss = isTrue(stylesheet[KEY__NATIVE_ONLY_CSS]);\n            const { renderMode, shadowMode } = vm;\n            if (lwcRuntimeFlags.DISABLE_LIGHT_DOM_UNSCOPED_CSS &&\n                !isScopedCss &&\n                renderMode === 0 /* RenderMode.Light */) {\n                logError('Unscoped CSS is not supported in Light DOM in this environment. Please use scoped CSS ' +\n                    '(*.scoped.css) instead of unscoped CSS (*.css). See also: https://sfdc.co/scoped-styles-light-dom');\n                continue;\n            }\n            // Apply the scope token only if the stylesheet itself is scoped, or if we're rendering synthetic shadow.\n            const scopeToken = isScopedCss ||\n                (shadowMode === 1 /* ShadowMode.Synthetic */ && renderMode === 1 /* RenderMode.Shadow */)\n                ? stylesheetToken\n                : undefined;\n            // Use the actual `:host` selector if we're rendering global CSS for light DOM, or if we're rendering\n            // native shadow DOM. Synthetic shadow DOM never uses `:host`.\n            const useActualHostSelector = renderMode === 0 /* RenderMode.Light */ ? !isScopedCss : shadowMode === 0 /* ShadowMode.Native */;\n            // Use the native :dir() pseudoclass only in native shadow DOM. Otherwise, in synthetic shadow,\n            // we use an attribute selector on the host to simulate :dir().\n            let useNativeDirPseudoclass;\n            if (renderMode === 1 /* RenderMode.Shadow */) {\n                useNativeDirPseudoclass = shadowMode === 0 /* ShadowMode.Native */;\n            }\n            else {\n                // Light DOM components should only render `[dir]` if they're inside of a synthetic shadow root.\n                // At the top level (root is null) or inside of a native shadow root, they should use `:dir()`.\n                if (isUndefined$1(root)) {\n                    // Only calculate the root once as necessary\n                    root = getNearestShadowComponent(vm);\n                }\n                useNativeDirPseudoclass = isNull(root) || root.shadowMode === 0 /* ShadowMode.Native */;\n            }\n            let cssContent;\n            if (isNativeOnlyCss &&\n                renderMode === 1 /* RenderMode.Shadow */ &&\n                shadowMode === 1 /* ShadowMode.Synthetic */) {\n                // Native-only (i.e. disableSyntheticShadowSupport) CSS should be ignored entirely\n                // in synthetic shadow. It's fine to use in either native shadow or light DOM, but in\n                // synthetic shadow it wouldn't be scoped properly and so should be ignored.\n                cssContent = '/* ignored native-only CSS */';\n            }\n            else {\n                cssContent = stylesheet(scopeToken, useActualHostSelector, useNativeDirPseudoclass);\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                linkStylesheetToCssContentInDevMode(stylesheet, cssContent);\n            }\n            ArrayPush$1.call(content, cssContent);\n        }\n    }\n    return content;\n}\nfunction getStylesheetsContent(vm, template) {\n    const { stylesheets, stylesheetToken } = template;\n    const { stylesheets: vmStylesheets } = vm;\n    const hasTemplateStyles = hasStyles(stylesheets);\n    const hasVmStyles = hasStyles(vmStylesheets);\n    if (hasTemplateStyles) {\n        const content = evaluateStylesheetsContent(stylesheets, stylesheetToken, vm);\n        if (hasVmStyles) {\n            // Slow path â€“ merge the template styles and vm styles\n            ArrayPush$1.apply(content, evaluateStylesheetsContent(vmStylesheets, stylesheetToken, vm));\n        }\n        return content;\n    }\n    if (hasVmStyles) {\n        // No template styles, so return vm styles directly\n        return evaluateStylesheetsContent(vmStylesheets, stylesheetToken, vm);\n    }\n    // Fastest path - no styles, so return an empty array\n    return EmptyArray;\n}\n// It might be worth caching this to avoid doing the lookup repeatedly, but\n// perf testing has not shown it to be a huge improvement yet:\n// https://github.com/salesforce/lwc/pull/2460#discussion_r691208892\nfunction getNearestShadowComponent(vm) {\n    let owner = vm;\n    while (!isNull(owner)) {\n        if (owner.renderMode === 1 /* RenderMode.Shadow */) {\n            return owner;\n        }\n        owner = owner.owner;\n    }\n    return owner;\n}\n/**\n * If the component that is currently being rendered uses scoped styles,\n * this returns the unique token for that scoped stylesheet. Otherwise\n * it returns null.\n * @param owner\n * @param legacy\n */\n// TODO [#3733]: remove support for legacy scope tokens\nfunction getScopeTokenClass(owner, legacy) {\n    const { cmpTemplate, context } = owner;\n    return ((context.hasScopedStyles &&\n        (legacy ? cmpTemplate?.legacyStylesheetToken : cmpTemplate?.stylesheetToken)) ||\n        null);\n}\nfunction getNearestNativeShadowComponent(vm) {\n    const owner = getNearestShadowComponent(vm);\n    if (!isNull(owner) && owner.shadowMode === 1 /* ShadowMode.Synthetic */) {\n        // Synthetic-within-native is impossible. So if the nearest shadow component is\n        // synthetic, we know we won't find a native component if we go any further.\n        return null;\n    }\n    return owner;\n}\nfunction createStylesheet(vm, stylesheets) {\n    const { renderMode, shadowMode, renderer: { insertStylesheet }, } = vm;\n    if (renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */) {\n        for (let i = 0; i < stylesheets.length; i++) {\n            const stylesheet = stylesheets[i];\n            insertStylesheet(stylesheet, undefined, getOrCreateAbortSignal(stylesheet));\n        }\n    }\n    else if (vm.hydrated) {\n        // Note: We need to ensure that during hydration, the stylesheets method is the same as those in ssr.\n        //       This works in the client, because the stylesheets are created, and cached in the VM\n        //       the first time the VM renders.\n        // native shadow or light DOM, SSR\n        return ArrayMap.call(stylesheets, createInlineStyleVNode);\n    }\n    else {\n        // native shadow or light DOM, DOM renderer\n        const root = getNearestNativeShadowComponent(vm);\n        // null root means a global style\n        const target = isNull(root) ? undefined : root.shadowRoot;\n        for (let i = 0; i < stylesheets.length; i++) {\n            const stylesheet = stylesheets[i];\n            insertStylesheet(stylesheet, target, getOrCreateAbortSignal(stylesheet));\n        }\n    }\n    return null;\n}\nfunction unrenderStylesheet(stylesheet) {\n    // should never leak to prod; only used for HMR\n    assertNotProd();\n    const cssContents = stylesheetsToCssContent.get(stylesheet);\n    /* istanbul ignore if */\n    if (isUndefined$1(cssContents)) {\n        throw new Error('Cannot unrender stylesheet which was never rendered');\n    }\n    for (const cssContent of cssContents) {\n        const abortController = cssContentToAbortControllers.get(cssContent);\n        if (isUndefined$1(abortController)) {\n            // Two stylesheets with the same content will share an abort controller, in which case it only needs to be called once.\n            continue;\n        }\n        abortController.abort();\n        // remove association with AbortController in case stylesheet is rendered again\n        cssContentToAbortControllers.delete(cssContent);\n    }\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst supportsWeakRefs = typeof WeakRef === 'function' && typeof FinalizationRegistry === 'function';\n// In browsers that doesn't support WeakRefs, the values will still leak, but at least the keys won't\nclass LegacyWeakMultiMap {\n    constructor() {\n        this._map = new WeakMap();\n    }\n    _getValues(key) {\n        let values = this._map.get(key);\n        if (isUndefined$1(values)) {\n            values = new Set();\n            this._map.set(key, values);\n        }\n        return values;\n    }\n    get(key) {\n        return this._getValues(key);\n    }\n    add(key, vm) {\n        const set = this._getValues(key);\n        set.add(vm);\n    }\n    delete(key) {\n        this._map.delete(key);\n    }\n}\n// This implementation relies on the WeakRef/FinalizationRegistry proposal.\n// For some background, see: https://github.com/tc39/proposal-weakrefs\nclass ModernWeakMultiMap {\n    constructor() {\n        this._map = new WeakMap();\n        this._registry = new FinalizationRegistry((weakRefs) => {\n            // This should be considered an optional cleanup method to remove GC'ed values from their respective arrays.\n            // JS VMs are not obligated to call FinalizationRegistry callbacks.\n            // Work backwards, removing stale VMs\n            for (let i = weakRefs.length - 1; i >= 0; i--) {\n                const vm = weakRefs[i].deref();\n                if (isUndefined$1(vm)) {\n                    ArraySplice.call(weakRefs, i, 1); // remove\n                }\n            }\n        });\n    }\n    _getWeakRefs(key) {\n        let weakRefs = this._map.get(key);\n        if (isUndefined$1(weakRefs)) {\n            weakRefs = [];\n            this._map.set(key, weakRefs);\n        }\n        return weakRefs;\n    }\n    get(key) {\n        const weakRefs = this._getWeakRefs(key);\n        const result = new Set();\n        for (const weakRef of weakRefs) {\n            const vm = weakRef.deref();\n            if (!isUndefined$1(vm)) {\n                result.add(vm);\n            }\n        }\n        return result;\n    }\n    add(key, value) {\n        const weakRefs = this._getWeakRefs(key);\n        // We could check for duplicate values here, but it doesn't seem worth it.\n        // We transform the output into a Set anyway\n        ArrayPush$1.call(weakRefs, new WeakRef(value));\n        // It's important here not to leak the second argument, which is the \"held value.\" The FinalizationRegistry\n        // effectively creates a strong reference between the first argument (the \"target\") and the held value. When\n        // the target is GC'ed, the callback is called, and then the held value is GC'ed.\n        // Putting the key here would mean the key is not GC'ed until the value is GC'ed, which defeats the purpose\n        // of the WeakMap. Whereas putting the weakRefs array here is fine, because it doesn't have a strong reference\n        // to anything. See also this example:\n        // https://gist.github.com/nolanlawson/79a3d36e8e6cc25c5048bb17c1795aea\n        this._registry.register(value, weakRefs);\n    }\n    delete(key) {\n        this._map.delete(key);\n    }\n}\nconst WeakMultiMap = supportsWeakRefs ? ModernWeakMultiMap : LegacyWeakMultiMap;\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet swappedTemplateMap = /*@__PURE__@*/ new WeakMap();\nlet swappedComponentMap = \n/*@__PURE__@*/ new WeakMap();\nlet swappedStyleMap = /*@__PURE__@*/ new WeakMap();\n// The important thing here is the weak values â€“ VMs are transient (one per component instance) and should be GC'ed,\n// so we don't want to create strong references to them.\n// The weak keys are kind of useless, because Templates, LightningElementConstructors, and Stylesheets are\n// never GC'ed. But maybe they will be someday, so we may as well use weak keys too.\n// The \"pure\" annotations are so that Rollup knows for sure it can remove these from prod mode\nlet activeTemplates = /*@__PURE__@*/ new WeakMultiMap();\nlet activeComponents = \n/*@__PURE__@*/ new WeakMultiMap();\nlet activeStyles = /*@__PURE__@*/ new WeakMultiMap();\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    // Used to reset the global state between test runs\n    window.__lwcResetHotSwaps = () => {\n        swappedTemplateMap = new WeakMap();\n        swappedComponentMap = new WeakMap();\n        swappedStyleMap = new WeakMap();\n        activeTemplates = new WeakMultiMap();\n        activeComponents = new WeakMultiMap();\n        activeStyles = new WeakMultiMap();\n    };\n}\nfunction rehydrateHotTemplate(tpl) {\n    const list = activeTemplates.get(tpl);\n    for (const vm of list) {\n        if (isFalse(vm.isDirty)) {\n            // forcing the vm to rehydrate in the micro-task:\n            markComponentAsDirty(vm);\n            scheduleRehydration(vm);\n        }\n    }\n    // Resetting the Set since these VMs are no longer related to this template, instead\n    // they will get re-associated once these instances are rehydrated.\n    activeTemplates.delete(tpl);\n    return true;\n}\nfunction rehydrateHotStyle(style) {\n    const activeVMs = activeStyles.get(style);\n    if (!activeVMs.size) {\n        return true;\n    }\n    unrenderStylesheet(style);\n    for (const vm of activeVMs) {\n        // if a style definition is swapped, we must reset\n        // vm's template content in the next micro-task:\n        forceRehydration(vm);\n    }\n    // Resetting the Set since these VMs are no longer related to this style, instead\n    // they will get re-associated once these instances are rehydrated.\n    activeStyles.delete(style);\n    return true;\n}\nfunction rehydrateHotComponent(Ctor) {\n    const list = activeComponents.get(Ctor);\n    let canRefreshAllInstances = true;\n    for (const vm of list) {\n        const { owner } = vm;\n        if (!isNull(owner)) {\n            // if a component class definition is swapped, we must reset\n            // owner's template content in the next micro-task:\n            forceRehydration(owner);\n        }\n        else {\n            // the hot swapping for components only work for instances of components\n            // created from a template, root elements can't be swapped because we\n            // don't have a way to force the creation of the element with the same state\n            // of the current element.\n            // Instead, we can report the problem to the caller so it can take action,\n            // for example: reload the entire page.\n            canRefreshAllInstances = false;\n        }\n    }\n    // resetting the Set since these VMs are no longer related to this constructor, instead\n    // they will get re-associated once these instances are rehydrated.\n    activeComponents.delete(Ctor);\n    return canRefreshAllInstances;\n}\nfunction getTemplateOrSwappedTemplate(tpl) {\n    assertNotProd(); // this method should never leak to prod\n    // TODO [#4154]: shows stale content when swapping content back and forth multiple times\n    const visited = new Set();\n    while (swappedTemplateMap.has(tpl) && !visited.has(tpl)) {\n        visited.add(tpl);\n        tpl = swappedTemplateMap.get(tpl);\n    }\n    return tpl;\n}\nfunction getComponentOrSwappedComponent(Ctor) {\n    assertNotProd(); // this method should never leak to prod\n    // TODO [#4154]: shows stale content when swapping content back and forth multiple times\n    const visited = new Set();\n    while (swappedComponentMap.has(Ctor) && !visited.has(Ctor)) {\n        visited.add(Ctor);\n        Ctor = swappedComponentMap.get(Ctor);\n    }\n    return Ctor;\n}\nfunction getStyleOrSwappedStyle(style) {\n    assertNotProd(); // this method should never leak to prod\n    // TODO [#4154]: shows stale content when swapping content back and forth multiple times\n    const visited = new Set();\n    while (swappedStyleMap.has(style) && !visited.has(style)) {\n        visited.add(style);\n        style = swappedStyleMap.get(style);\n    }\n    return style;\n}\nfunction addActiveStylesheets(stylesheets, vm) {\n    if (isUndefined$1(stylesheets) || isNull(stylesheets)) {\n        // Ignore non-existent stylesheets\n        return;\n    }\n    for (const stylesheet of flattenStylesheets(stylesheets)) {\n        // this is necessary because we don't hold the list of styles\n        // in the vm, we only hold the selected (already swapped template)\n        // but the styles attached to the template might not be the actual\n        // active ones, but the swapped versions of those.\n        const swappedStylesheet = getStyleOrSwappedStyle(stylesheet);\n        // this will allow us to keep track of the stylesheet that are\n        // being used by a hot component\n        activeStyles.add(swappedStylesheet, vm);\n    }\n}\nfunction setActiveVM(vm) {\n    assertNotProd(); // this method should never leak to prod\n    // tracking active component\n    const Ctor = vm.def.ctor;\n    // this will allow us to keep track of the hot components\n    activeComponents.add(Ctor, vm);\n    // tracking active template\n    const template = vm.cmpTemplate;\n    if (!isNull(template)) {\n        // this will allow us to keep track of the templates that are\n        // being used by a hot component\n        activeTemplates.add(template, vm);\n        // Tracking active styles from the template or the VM. `template.stylesheets` are implicitly associated\n        // (e.g. `foo.css` associated with `foo.html`), whereas `vm.stylesheets` are from `static stylesheets`.\n        addActiveStylesheets(template.stylesheets, vm);\n        addActiveStylesheets(vm.stylesheets, vm);\n    }\n}\nfunction swapTemplate(oldTpl, newTpl) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {\n            swappedTemplateMap.set(oldTpl, newTpl);\n            return rehydrateHotTemplate(oldTpl);\n        }\n        else {\n            throw new TypeError(`Invalid Template`);\n        }\n    }\n    return false;\n}\nfunction swapComponent(oldComponent, newComponent) {\n    if (process.env.NODE_ENV !== 'production') {\n        const isOldCtorAComponent = isComponentConstructor(oldComponent);\n        const isNewCtorAComponent = isComponentConstructor(newComponent);\n        if (isOldCtorAComponent && isNewCtorAComponent) {\n            swappedComponentMap.set(oldComponent, newComponent);\n            return rehydrateHotComponent(oldComponent);\n        }\n        else if (isOldCtorAComponent === false && isNewCtorAComponent === true) {\n            throw new TypeError(`Invalid Component: Attempting to swap a non-component with a component`);\n        }\n        else if (isOldCtorAComponent === true && isNewCtorAComponent === false) {\n            throw new TypeError(`Invalid Component: Attempting to swap a component with a non-component`);\n        }\n        else {\n            // The dev-server relies on the presence of registerComponent() as a way to determine a\n            // component module. However, the compiler cannot definitively add registerComponent()\n            // transformation only to a component constructor. Hence the dev-server may attempt to\n            // hot swap javascript modules that look like a component and should not cause the app\n            // to fail. To allow that, this api ignores such hot swap attempts.\n            return false;\n        }\n    }\n    return false;\n}\nfunction swapStyle(oldStyle, newStyle) {\n    if (process.env.NODE_ENV !== 'production') {\n        // TODO [#1887]: once the support for registering styles is implemented\n        // we can add the validation of both styles around this block.\n        swappedStyleMap.set(oldStyle, newStyle);\n        return rehydrateHotStyle(oldStyle);\n    }\n    return false;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This module is responsible for producing the ComponentDef object that is always\n * accessible via `vm.def`. This is lazily created during the creation of the first\n * instance of a component class, and shared across all instances.\n *\n * This structure can be used to synthetically create proxies, and understand the\n * shape of a component. It is also used internally to apply extra optimizations.\n */\nconst CtorToDefMap = new WeakMap();\nfunction getCtorProto(Ctor) {\n    let proto = getPrototypeOf$1(Ctor);\n    if (isNull(proto)) {\n        throw new ReferenceError(`Invalid prototype chain for ${Ctor.name}, you must extend LightningElement.`);\n    }\n    // covering the cases where the ref is circular in AMD\n    if (isCircularModuleDependency(proto)) {\n        const p = resolveCircularModuleDependency(proto);\n        if (process.env.NODE_ENV !== 'production') {\n            if (isNull(p)) {\n                throw new ReferenceError(`Circular module dependency for ${Ctor.name}, must resolve to a constructor that extends LightningElement.`);\n            }\n        }\n        // escape hatch for Locker and other abstractions to provide their own base class instead\n        // of our Base class without having to leak it to user-land. If the circular function returns\n        // itself, that's the signal that we have hit the end of the proto chain, which must always\n        // be base.\n        proto = p === proto ? LightningElement : p;\n    }\n    return proto;\n}\nfunction createComponentDef(Ctor) {\n    const { shadowSupportMode: ctorShadowSupportMode, renderMode: ctorRenderMode, formAssociated: ctorFormAssociated, } = Ctor;\n    if (process.env.NODE_ENV !== 'production') {\n        const ctorName = Ctor.name;\n        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n        if (!Ctor.constructor) {\n            // This error seems impossible to hit, due to an earlier check in `isComponentConstructor()`.\n            // But we keep it here just in case.\n            logError(`Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n        }\n        if (!isUndefined$1(ctorShadowSupportMode) &&\n            ctorShadowSupportMode !== 'any' &&\n            ctorShadowSupportMode !== 'reset' &&\n            ctorShadowSupportMode !== 'native') {\n            logError(`Invalid value for static property shadowSupportMode: '${ctorShadowSupportMode}'`);\n        }\n        // TODO [#3971]: Completely remove shadowSupportMode \"any\"\n        if (ctorShadowSupportMode === 'any') {\n            logWarn(`Invalid value 'any' for static property shadowSupportMode. 'any' is deprecated and will be removed in a future release--use 'native' instead.`);\n        }\n        if (!isUndefined$1(ctorRenderMode) &&\n            ctorRenderMode !== 'light' &&\n            ctorRenderMode !== 'shadow') {\n            logError(`Invalid value for static property renderMode: '${ctorRenderMode}'. renderMode must be either 'light' or 'shadow'.`);\n        }\n    }\n    const decoratorsMeta = getDecoratorsMeta(Ctor);\n    const { apiFields, apiFieldsConfig, apiMethods, wiredFields, wiredMethods, observedFields } = decoratorsMeta;\n    const proto = Ctor.prototype;\n    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, formAssociatedCallback, formResetCallback, formDisabledCallback, formStateRestoreCallback, render, } = proto;\n    const superProto = getCtorProto(Ctor);\n    const hasCustomSuperClass = superProto !== LightningElement;\n    const superDef = hasCustomSuperClass ? getComponentInternalDef(superProto) : lightingElementDef;\n    const bridge = HTMLBridgeElementFactory(superDef.bridge, keys(apiFields), keys(apiMethods), keys(observedFields), proto, hasCustomSuperClass);\n    const props = assign(create(null), superDef.props, apiFields);\n    const propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);\n    const methods = assign(create(null), superDef.methods, apiMethods);\n    const wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);\n    connectedCallback = connectedCallback || superDef.connectedCallback;\n    disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n    renderedCallback = renderedCallback || superDef.renderedCallback;\n    errorCallback = errorCallback || superDef.errorCallback;\n    formAssociatedCallback = formAssociatedCallback || superDef.formAssociatedCallback;\n    formResetCallback = formResetCallback || superDef.formResetCallback;\n    formDisabledCallback = formDisabledCallback || superDef.formDisabledCallback;\n    formStateRestoreCallback = formStateRestoreCallback || superDef.formStateRestoreCallback;\n    render = render || superDef.render;\n    let shadowSupportMode = superDef.shadowSupportMode;\n    if (!isUndefined$1(ctorShadowSupportMode)) {\n        shadowSupportMode = ctorShadowSupportMode;\n        if (isReportingEnabled() &&\n            (shadowSupportMode === 'any' || shadowSupportMode === 'native')) {\n            report(\"ShadowSupportModeUsage\" /* ReportingEventId.ShadowSupportModeUsage */, {\n                tagName: Ctor.name,\n                mode: shadowSupportMode,\n            });\n        }\n    }\n    let renderMode = superDef.renderMode;\n    if (!isUndefined$1(ctorRenderMode)) {\n        renderMode = ctorRenderMode === 'light' ? 0 /* RenderMode.Light */ : 1 /* RenderMode.Shadow */;\n    }\n    let formAssociated = superDef.formAssociated;\n    if (!isUndefined$1(ctorFormAssociated)) {\n        formAssociated = ctorFormAssociated;\n    }\n    const template = getComponentRegisteredTemplate(Ctor) || superDef.template;\n    const name = Ctor.name || superDef.name;\n    // installing observed fields into the prototype.\n    defineProperties(proto, observedFields);\n    const def = {\n        ctor: Ctor,\n        name,\n        wire,\n        props,\n        propsConfig,\n        methods,\n        bridge,\n        template,\n        renderMode,\n        shadowSupportMode,\n        formAssociated,\n        connectedCallback,\n        disconnectedCallback,\n        errorCallback,\n        formAssociatedCallback,\n        formDisabledCallback,\n        formResetCallback,\n        formStateRestoreCallback,\n        renderedCallback,\n        render,\n    };\n    // This is a no-op unless Lightning DevTools are enabled.\n    instrumentDef(def);\n    if (process.env.NODE_ENV !== 'production') {\n        freeze(Ctor.prototype);\n    }\n    return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is\n * subject to change or being removed.\n * @param ctor\n */\nfunction isComponentConstructor(ctor) {\n    if (!isFunction$1(ctor)) {\n        return false;\n    }\n    // Fast path: LightningElement is part of the prototype chain of the constructor.\n    if (ctor.prototype instanceof LightningElement) {\n        return true;\n    }\n    // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n    // climb up the constructor prototype chain to check in case there are circular dependencies\n    // to resolve.\n    let current = ctor;\n    do {\n        if (isCircularModuleDependency(current)) {\n            const circularResolved = resolveCircularModuleDependency(current);\n            // If the circular function returns itself, that's the signal that we have hit the end\n            // of the proto chain, which must always be a valid base constructor.\n            if (circularResolved === current) {\n                return true;\n            }\n            current = circularResolved;\n        }\n        if (current === LightningElement) {\n            return true;\n        }\n    } while (!isNull(current) && (current = getPrototypeOf$1(current)));\n    // Finally return false if the LightningElement is not part of the prototype chain.\n    return false;\n}\nfunction getComponentInternalDef(Ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        Ctor = getComponentOrSwappedComponent(Ctor);\n    }\n    let def = CtorToDefMap.get(Ctor);\n    if (isUndefined$1(def)) {\n        if (isCircularModuleDependency(Ctor)) {\n            const resolvedCtor = resolveCircularModuleDependency(Ctor);\n            def = getComponentInternalDef(resolvedCtor);\n            // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,\n            // look up the definition in cache instead of re-resolving and recreating the def.\n            CtorToDefMap.set(Ctor, def);\n            return def;\n        }\n        if (!isComponentConstructor(Ctor)) {\n            throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n        }\n        def = createComponentDef(Ctor);\n        CtorToDefMap.set(Ctor, def);\n    }\n    return def;\n}\nfunction getComponentHtmlPrototype(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    return def.bridge;\n}\nconst lightingElementDef = {\n    name: LightningElement.name,\n    props: lightningBasedDescriptors,\n    propsConfig: EmptyObject,\n    methods: EmptyObject,\n    renderMode: 1 /* RenderMode.Shadow */,\n    shadowSupportMode: 'reset',\n    formAssociated: undefined,\n    wire: EmptyObject,\n    bridge: BaseBridgeElement,\n    template: defaultEmptyTemplate,\n    render: LightningElement.prototype.render,\n};\n/**\n * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is\n * subject to change or being removed.\n * @param Ctor\n */\nfunction getComponentDef(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    // From the internal def object, we need to extract the info that is useful\n    // for some external services, e.g.: Locker Service, usually, all they care\n    // is about the shape of the constructor, the internals of it are not relevant\n    // because they don't have a way to mess with that.\n    const { ctor, name, props, propsConfig, methods } = def;\n    const publicProps = {};\n    for (const key in props) {\n        // avoid leaking the reference to the public props descriptors\n        publicProps[key] = {\n            config: propsConfig[key] || 0, // a property by default\n            type: 'any', // no type inference for public services\n            attr: htmlPropertyToAttribute(key),\n        };\n    }\n    const publicMethods = {};\n    for (const key in methods) {\n        // avoid leaking the reference to the public method descriptors\n        publicMethods[key] = methods[key].value;\n    }\n    return {\n        ctor,\n        name,\n        props: publicProps,\n        methods: publicMethods,\n    };\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isVBaseElement(vnode) {\n    const { type } = vnode;\n    return type === 2 /* VNodeType.Element */ || type === 3 /* VNodeType.CustomElement */;\n}\nfunction isSameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVCustomElement(vnode) {\n    return vnode.type === 3 /* VNodeType.CustomElement */;\n}\nfunction isVFragment(vnode) {\n    return vnode.type === 5 /* VNodeType.Fragment */;\n}\nfunction isVScopedSlotFragment(vnode) {\n    return vnode.type === 6 /* VNodeType.ScopedSlotFragment */;\n}\nfunction isVStatic(vnode) {\n    return vnode.type === 4 /* VNodeType.Static */;\n}\nfunction isVStaticPartElement(vnode) {\n    return vnode.type === 1 /* VStaticPartType.Element */;\n}\nfunction isVStaticPartText(vnode) {\n    return vnode.type === 0 /* VStaticPartType.Text */;\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst sanitizedHtmlContentSymbol = Symbol('lwc-get-sanitized-html-content');\nfunction isSanitizedHtmlContent(object) {\n    return isObject(object) && !isNull(object) && sanitizedHtmlContentSymbol in object;\n}\nfunction unwrapIfNecessary(object) {\n    return isSanitizedHtmlContent(object) ? object[sanitizedHtmlContentSymbol] : object;\n}\n/**\n * Wrap a pre-sanitized string designated for `.innerHTML` via `lwc:inner-html`\n * as an object with a Symbol that only we have access to.\n * @param sanitizedString\n * @returns SanitizedHtmlContent\n */\nfunction createSanitizedHtmlContent(sanitizedString) {\n    return create(null, {\n        [sanitizedHtmlContentSymbol]: {\n            value: sanitizedString,\n            configurable: false,\n            writable: false,\n        },\n    });\n}\n/**\n * Safely call setProperty on an Element while handling any SanitizedHtmlContent objects correctly\n *\n * @param setProperty - renderer.setProperty\n * @param elm - Element\n * @param key - key to set\n * @param value -  value to set\n */\nfunction safelySetProperty(setProperty, elm, key, value) {\n    // See W-16614337\n    // we support setting innerHTML to `undefined` because it's inherently safe\n    if ((key === 'innerHTML' || key === 'outerHTML') && !isUndefined$1(value)) {\n        if (isSanitizedHtmlContent(value)) {\n            // it's a SanitizedHtmlContent object\n            setProperty(elm, key, value[sanitizedHtmlContentSymbol]);\n        }\n        else {\n            // not a SanitizedHtmlContent object\n            if (process.env.NODE_ENV !== 'production') {\n                logWarn(`Cannot set property \"${key}\". Instead, use lwc:inner-html or lwc:dom-manual.`);\n            }\n        }\n    }\n    else {\n        setProperty(elm, key, value);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ColonCharCode = 58;\nfunction patchAttributes(oldVnode, vnode, renderer) {\n    const { data, elm } = vnode;\n    const { attrs } = data;\n    if (isUndefined$1(attrs)) {\n        return;\n    }\n    const oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;\n    // Attrs may be the same due to the static content optimization, so we can skip diffing\n    if (oldAttrs === attrs) {\n        return;\n    }\n    // Note VStaticPartData does not contain the external property so it will always default to false.\n    const external = 'external' in data ? data.external : false;\n    const { setAttribute, removeAttribute, setProperty } = renderer;\n    for (const key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            let propName;\n            // For external custom elements, sniff to see if the attr should be considered a prop.\n            // Use kebabCaseToCamelCase directly because we don't want to set props like `ariaLabel` or `tabIndex`\n            // on a custom element versus just using the more reliable attribute format.\n            if (external && (propName = kebabCaseToCamelCase(key)) in elm) {\n                safelySetProperty(setProperty, elm, propName, cur);\n            }\n            else if (StringCharCodeAt.call(key, 3) === ColonCharCode) {\n                // Assume xml namespace\n                setAttribute(elm, key, cur, XML_NAMESPACE);\n            }\n            else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {\n                // Assume xlink namespace\n                setAttribute(elm, key, cur, XLINK_NAMESPACE);\n            }\n            else if (isNull(cur) || isUndefined$1(cur)) {\n                removeAttribute(elm, key);\n            }\n            else {\n                setAttribute(elm, key, cur);\n            }\n        }\n    }\n}\nfunction patchSlotAssignment(oldVnode, vnode, renderer) {\n    const { slotAssignment } = vnode;\n    if (oldVnode?.slotAssignment === slotAssignment) {\n        return;\n    }\n    const { elm } = vnode;\n    const { setAttribute, removeAttribute } = renderer;\n    if (isUndefined$1(slotAssignment) || isNull(slotAssignment)) {\n        removeAttribute(elm, 'slot');\n    }\n    else {\n        setAttribute(elm, 'slot', slotAssignment);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isLiveBindingProp(sel, key) {\n    // For properties with live bindings, we read values from the DOM element\n    // instead of relying on internally tracked values.\n    return sel === 'input' && (key === 'value' || key === 'checked');\n}\nfunction patchProps(oldVnode, vnode, renderer) {\n    const { props } = vnode.data;\n    if (isUndefined$1(props)) {\n        return;\n    }\n    let oldProps;\n    if (!isNull(oldVnode)) {\n        oldProps = oldVnode.data.props;\n        // Props may be the same due to the static content optimization, so we can skip diffing\n        if (oldProps === props) {\n            return;\n        }\n        if (isUndefined$1(oldProps)) {\n            oldProps = EmptyObject;\n        }\n    }\n    const isFirstPatch = isNull(oldVnode);\n    const { elm, sel } = vnode;\n    const { getProperty, setProperty } = renderer;\n    for (const key in props) {\n        const cur = props[key];\n        // Set the property if it's the first time is is patched or if the previous property is\n        // different than the one previously set.\n        if (isFirstPatch ||\n            cur !== (isLiveBindingProp(sel, key) ? getProperty(elm, key) : oldProps[key]) ||\n            !(key in oldProps) // this is required because the above case will pass when `cur` is `undefined` and key is missing in `oldProps`\n        ) {\n            // Additional verification if properties are supported by the element\n            // Validation relies on html properties and public properties being defined on the element,\n            // SSR has its own custom validation.\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(key in elm)) {\n                    logWarn(`Unknown public property \"${key}\" of element <${elm.tagName.toLowerCase()}>. This is either a typo on the corresponding attribute \"${htmlPropertyToAttribute(key)}\", or the attribute does not exist in this browser or DOM implementation.`);\n                }\n            }\n            safelySetProperty(setProperty, elm, key, cur);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create(null);\nfunction getMapFromClassName(className) {\n    if (isUndefined$1(className) || isNull(className) || className === '') {\n        return EmptyObject;\n    }\n    // computed class names must be string\n    // This will throw if className is a symbol or null-prototype object\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n    className = isString(className) ? className : className + '';\n    let map = classNameToClassMap[className];\n    if (map) {\n        return map;\n    }\n    map = create(null);\n    let start = 0;\n    let o;\n    const len = className.length;\n    for (o = 0; o < len; o++) {\n        if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {\n            if (o > start) {\n                map[StringSlice.call(className, start, o)] = true;\n            }\n            start = o + 1;\n        }\n    }\n    if (o > start) {\n        map[StringSlice.call(className, start, o)] = true;\n    }\n    classNameToClassMap[className] = map;\n    if (process.env.NODE_ENV !== 'production') {\n        // just to make sure that this object never changes as part of the diffing algo\n        freeze(map);\n    }\n    return map;\n}\nfunction patchClassAttribute(oldVnode, vnode, renderer) {\n    const { elm, data: { className: newClass }, } = vnode;\n    const oldClass = isNull(oldVnode) ? undefined : oldVnode.data.className;\n    if (oldClass === newClass) {\n        return;\n    }\n    const newClassMap = getMapFromClassName(newClass);\n    const oldClassMap = getMapFromClassName(oldClass);\n    if (oldClassMap === newClassMap) {\n        // These objects are cached by className string (`classNameToClassMap`), so we can only get here if there is\n        // a key collision due to types, e.g. oldClass is `undefined` and newClass is `\"\"` (empty string), or oldClass\n        // is `1` (number) and newClass is `\"1\"` (string).\n        return;\n    }\n    const { getClassList } = renderer;\n    const classList = getClassList(elm);\n    let name;\n    for (name in oldClassMap) {\n        // remove only if it is not in the new class collection and it is not set from within the instance\n        if (isUndefined$1(newClassMap[name])) {\n            classList.remove(name);\n        }\n    }\n    for (name in newClassMap) {\n        if (isUndefined$1(oldClassMap[name])) {\n            classList.add(name);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The style property is a string when defined via an expression in the template.\nfunction patchStyleAttribute(oldVnode, vnode, renderer, owner) {\n    const { elm, data: { style: newStyle }, } = vnode;\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isNull(newStyle) && !isUndefined$1(newStyle) && !isString(newStyle)) {\n            logError(`Invalid 'style' attribute passed to <${elm.tagName.toLowerCase()}> is ignored. This attribute must be a string value.`, owner);\n        }\n    }\n    const oldStyle = isNull(oldVnode) ? undefined : oldVnode.data.style;\n    if (oldStyle === newStyle) {\n        return;\n    }\n    const { setAttribute, removeAttribute } = renderer;\n    if (!isString(newStyle) || newStyle === '') {\n        removeAttribute(elm, 'style');\n    }\n    else {\n        setAttribute(elm, 'style', newStyle);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction applyEventListeners(vnode, renderer) {\n    const { elm, data } = vnode;\n    const { on } = data;\n    if (isUndefined$1(on)) {\n        return;\n    }\n    const { addEventListener } = renderer;\n    for (const name in on) {\n        const handler = on[name];\n        addEventListener(elm, name, handler);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\nfunction applyStaticClassAttribute(vnode, renderer) {\n    const { elm, data: { classMap }, } = vnode;\n    if (isUndefined$1(classMap)) {\n        return;\n    }\n    const { getClassList } = renderer;\n    const classList = getClassList(elm);\n    for (const name in classMap) {\n        classList.add(name);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML style property becomes the vnode.data.styleDecls object when defined as a string in the template.\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\nfunction applyStaticStyleAttribute(vnode, renderer) {\n    const { elm, data: { styleDecls }, } = vnode;\n    if (isUndefined$1(styleDecls)) {\n        return;\n    }\n    const { setCSSStyleProperty } = renderer;\n    for (let i = 0; i < styleDecls.length; i++) {\n        const [prop, value, important] = styleDecls[i];\n        setCSSStyleProperty(elm, prop, value, important);\n    }\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Set a ref (lwc:ref) on a VM, from a template API\nfunction applyRefs(vnode, owner) {\n    const { data } = vnode;\n    const { ref } = data;\n    if (isUndefined$1(ref)) {\n        return;\n    }\n    if (process.env.NODE_ENV !== 'production' && isUndefined$1(owner.refVNodes)) {\n        throw new Error('refVNodes must be defined when setting a ref');\n    }\n    // If this method is called, then vm.refVNodes is set as the template has refs.\n    // If not, then something went wrong and we threw an error above.\n    const refVNodes = owner.refVNodes;\n    // In cases of conflict (two elements with the same ref), prefer the last one,\n    // in depth-first traversal order. This happens automatically due to how we render\n    refVNodes[ref] = vnode;\n}\n\n/*\n * Copyright (c) 2024, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchTextVNode(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    if (n2.text !== n1.text) {\n        updateTextContent$1(n2, renderer);\n    }\n}\nfunction patchTextVStaticPart(n1, n2, renderer) {\n    if (isNull(n1) || n2.text !== n1.text) {\n        updateTextContent$1(n2, renderer);\n    }\n}\nfunction updateTextContent$1(vnode, renderer) {\n    const { elm, text } = vnode;\n    const { setText } = renderer;\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    setText(elm, text);\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * Given an array of static parts, mounts the DOM element to the part based on the staticPartId\n * @param root the root element\n * @param parts an array of VStaticParts\n * @param renderer the renderer to use\n */\nfunction traverseAndSetElements(root, parts, renderer) {\n    const numParts = parts.length;\n    // Optimization given that, in most cases, there will be one part, and it's just the root\n    if (numParts === 1) {\n        const firstPart = parts[0];\n        if (firstPart.partId === 0) {\n            // 0 means the root node\n            firstPart.elm = root;\n            return;\n        }\n    }\n    const partIdsToParts = new Map();\n    for (const staticPart of parts) {\n        partIdsToParts.set(staticPart.partId, staticPart);\n    }\n    // Note that we traverse using `*Child`/`*Sibling` rather than `children` because the browser uses a linked\n    // list under the hood to represent the DOM tree, so it's faster to do this than to create an underlying array\n    // by calling `children`.\n    const { nextSibling, getFirstChild, getParentNode } = renderer;\n    let numFoundParts = 0;\n    let partId = -1;\n    // We should never traverse up to the root. We should exit early due to numFoundParts === numParts.\n    // This is just a sanity check, in case the static parts generated by @lwc/template-compiler are wrong.\n    function assertNotRoot(node) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isFalse(node === root, `Reached the root without finding all parts. Found ${numFoundParts}, needed ${numParts}.`);\n        }\n    }\n    // Depth-first traversal. We assign a partId to each element, which is an integer based on traversal order.\n    // This function is very hot, which is why it's micro-optimized. Note we don't use a stack at all; we traverse\n    // using an algorithm that relies on the parentNode getter: https://stackoverflow.com/a/5285417\n    // This is very slightly faster than a TreeWalker (~0.5% on js-framework-benchmark create-10k), but basically\n    // the same idea.\n    let node = root;\n    while (!isNull(node)) {\n        // visit node\n        partId++;\n        const part = partIdsToParts.get(partId);\n        if (!isUndefined$1(part)) {\n            part.elm = node;\n            numFoundParts++;\n            if (numFoundParts === numParts) {\n                return; // perf optimization - stop traversing once we've found everything we need\n            }\n        }\n        const child = getFirstChild(node);\n        if (!isNull(child)) {\n            // walk down\n            node = child;\n        }\n        else {\n            let sibling;\n            while (isNull((sibling = nextSibling(node)))) {\n                // we never want to walk up from the root\n                assertNotRoot(node);\n                // walk up\n                node = getParentNode(node);\n            }\n            // we never want to walk right from the root\n            assertNotRoot(node);\n            // walk right\n            node = sibling;\n        }\n    }\n    /* istanbul ignore next */\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(numFoundParts === numParts, `Should have found all parts by now. Found ${numFoundParts}, needed ${numParts}.`);\n    }\n}\n/**\n * Given an array of static parts, do all the mounting required for these parts.\n * @param root the root element\n * @param vnode the parent VStatic\n * @param renderer the renderer to use\n */\nfunction mountStaticParts(root, vnode, renderer) {\n    const { parts, owner } = vnode;\n    if (isUndefined$1(parts)) {\n        return;\n    }\n    // This adds `part.elm` to each `part`. We have to do this on every mount because the `parts`\n    // array is recreated from scratch every time, so each `part.elm` is now undefined.\n    traverseAndSetElements(root, parts, renderer);\n    // Currently only event listeners and refs are supported for static vnodes\n    for (const part of parts) {\n        if (isVStaticPartElement(part)) {\n            // Event listeners only need to be applied once when mounting\n            applyEventListeners(part, renderer);\n            // Refs must be updated after every render due to refVNodes getting reset before every render\n            applyRefs(part, owner);\n            patchAttributes(null, part, renderer);\n            patchClassAttribute(null, part, renderer);\n            patchStyleAttribute(null, part, renderer, owner);\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production' && !isVStaticPartText(part)) {\n                throw new Error(`LWC internal error, encountered unknown static part type: ${part.type}`);\n            }\n            patchTextVStaticPart(null, part, renderer);\n        }\n    }\n}\n/**\n * Updates the static elements based on the content of the VStaticParts\n * @param n1 the previous VStatic vnode\n * @param n2 the current VStatic vnode\n * @param renderer the renderer to use\n */\nfunction patchStaticParts(n1, n2, renderer) {\n    const { parts: currParts, owner: currPartsOwner } = n2;\n    if (isUndefined$1(currParts)) {\n        return;\n    }\n    const { parts: prevParts } = n1;\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(currParts.length === prevParts?.length, 'Expected static parts to be the same for the same element. This is an error with the LWC framework itself.');\n    }\n    for (let i = 0; i < currParts.length; i++) {\n        const prevPart = prevParts[i];\n        const part = currParts[i];\n        // Patch only occurs if the vnode is newly generated, which means the part.elm is always undefined\n        // Since the vnode and elements are the same we can safely assume that prevParts[i].elm is defined.\n        part.elm = prevPart.elm;\n        if (process.env.NODE_ENV !== 'production' && prevPart.type !== part.type) {\n            throw new Error(`LWC internal error, static part types do not match. Previous type was ${prevPart.type} and current type is ${part.type}`);\n        }\n        if (isVStaticPartElement(part)) {\n            // Refs must be updated after every render due to refVNodes getting reset before every render\n            applyRefs(part, currPartsOwner);\n            patchAttributes(prevPart, part, renderer);\n            patchClassAttribute(prevPart, part, renderer);\n            patchStyleAttribute(prevPart, part, renderer, currPartsOwner);\n        }\n        else {\n            patchTextVStaticPart(null, part, renderer);\n        }\n    }\n}\n/**\n * Mounts the hydration specific attributes\n * @param vnode the parent VStatic node\n * @param renderer the renderer to use\n */\nfunction hydrateStaticParts(vnode, renderer) {\n    const { parts, owner } = vnode;\n    if (isUndefined$1(parts)) {\n        return;\n    }\n    // Note, hydration doesn't patch attributes because hydration validation occurs before this routine\n    // which guarantees that the elements are the same.\n    // We only need to apply the parts for things that cannot be done on the server.\n    for (const part of parts) {\n        if (isVStaticPartElement(part)) {\n            // Event listeners only need to be applied once when mounting\n            applyEventListeners(part, renderer);\n            // Refs must be updated after every render due to refVNodes getting reset before every render\n            applyRefs(part, owner);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchChildren(c1, c2, parent, renderer) {\n    if (hasDynamicChildren(c2)) {\n        updateDynamicChildren(c1, c2, parent, renderer);\n    }\n    else {\n        updateStaticChildren(c1, c2, parent, renderer);\n    }\n}\nfunction patch(n1, n2, parent, renderer) {\n    if (n1 === n2) {\n        return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isSameVnode(n1, n2) &&\n            // Currently the only scenario when patch does not receive the same vnodes are for\n            // dynamic components. When a dynamic component's constructor changes, the value of its\n            // tag name (sel) will be different. The engine will unmount the previous element\n            // and mount the new one using the new constructor in patchCustomElement.\n            !(isVCustomElement(n1) && isVCustomElement(n2))) {\n            throw new Error('Expected these VNodes to be the same: ' +\n                JSON.stringify({ sel: n1.sel, key: n1.key }) +\n                ', ' +\n                JSON.stringify({ sel: n2.sel, key: n2.key }));\n        }\n    }\n    switch (n2.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            patchTextVNode(n1, n2, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            patchComment(n1, n2, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            patchStatic(n1, n2, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            patchFragment(n1, n2, parent, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            patchElement(n1, n2, n2.data.renderer ?? renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            patchCustomElement(n1, n2, parent, n2.data.renderer ?? renderer);\n            break;\n    }\n}\nfunction mount(node, parent, renderer, anchor) {\n    switch (node.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            mountText(node, parent, anchor, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            mountComment(node, parent, anchor, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            // VStatic cannot have a custom renderer associated to them, using owner's renderer\n            mountStatic(node, parent, anchor, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            mountFragment(node, parent, anchor, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            // If the vnode data has a renderer override use it, else fallback to owner's renderer\n            mountElement(node, parent, anchor, node.data.renderer ?? renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            // If the vnode data has a renderer override use it, else fallback to owner's renderer\n            mountCustomElement(node, parent, anchor, node.data.renderer ?? renderer);\n            break;\n    }\n}\nfunction mountText(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { createText } = renderer;\n    const textNode = (vnode.elm = createText(vnode.text));\n    linkNodeToShadow(textNode, owner, renderer);\n    insertNode(textNode, parent, anchor, renderer);\n}\nfunction patchComment(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    // FIXME: Comment nodes should be static, we shouldn't need to diff them together. However\n    // it is the case today.\n    if (n2.text !== n1.text) {\n        updateTextContent$1(n2, renderer);\n    }\n}\nfunction mountComment(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { createComment } = renderer;\n    const commentNode = (vnode.elm = createComment(vnode.text));\n    linkNodeToShadow(commentNode, owner, renderer);\n    insertNode(commentNode, parent, anchor, renderer);\n}\nfunction mountFragment(vnode, parent, anchor, renderer) {\n    const { children } = vnode;\n    mountVNodes(children, parent, renderer, anchor);\n    vnode.elm = vnode.leading.elm;\n}\nfunction patchFragment(n1, n2, parent, renderer) {\n    const { children, stable } = n2;\n    if (stable) {\n        updateStaticChildren(n1.children, children, parent, renderer);\n    }\n    else {\n        updateDynamicChildren(n1.children, children, parent, renderer);\n    }\n    // Note: not reusing n1.elm, because during patching, it may be patched with another text node.\n    n2.elm = n2.leading.elm;\n}\nfunction mountElement(vnode, parent, anchor, renderer) {\n    const { sel, owner, data: { svg }, } = vnode;\n    const { createElement } = renderer;\n    const namespace = isTrue(svg) ? SVG_NAMESPACE : undefined;\n    const elm = (vnode.elm = createElement(sel, namespace));\n    linkNodeToShadow(elm, owner, renderer);\n    applyStyleScoping(elm, owner, renderer);\n    applyDomManual(elm, vnode);\n    applyElementRestrictions(elm, vnode);\n    patchElementPropsAndAttrsAndRefs$1(null, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n    mountVNodes(vnode.children, elm, renderer, null);\n}\nfunction patchStatic(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    // slotAssignments can only apply to the top level element, never to a static part.\n    patchSlotAssignment(n1, n2, renderer);\n    // The `refs` object is blown away in every re-render, so we always need to re-apply them\n    patchStaticParts(n1, n2, renderer);\n}\nfunction patchElement(n1, n2, renderer) {\n    const elm = (n2.elm = n1.elm);\n    patchElementPropsAndAttrsAndRefs$1(n1, n2, renderer);\n    patchChildren(n1.children, n2.children, elm, renderer);\n}\nfunction mountStatic(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { cloneNode, isSyntheticShadowDefined } = renderer;\n    const elm = (vnode.elm = cloneNode(vnode.fragment, true));\n    // Define the root node shadow resolver\n    linkNodeToShadow(elm, owner, renderer);\n    applyElementRestrictions(elm, vnode);\n    const { renderMode, shadowMode } = owner;\n    if (isSyntheticShadowDefined) {\n        // Marks this node as Static to propagate the shadow resolver. must happen after elm is assigned to the proper shadow\n        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n            elm[KEY__SHADOW_STATIC] = true;\n        }\n    }\n    // slotAssignments can only apply to the top level element, never to a static part.\n    patchSlotAssignment(null, vnode, renderer);\n    mountStaticParts(elm, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n}\nfunction mountCustomElement(vnode, parent, anchor, renderer) {\n    const { sel, owner, ctor } = vnode;\n    const { createCustomElement } = renderer;\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    let vm;\n    const upgradeCallback = (elm) => {\n        // the custom element from the registry is expecting an upgrade callback\n        vm = createViewModelHook(elm, vnode, renderer);\n    };\n    // Should never get a tag with upper case letter at this point; the compiler\n    // should produce only tags with lowercase letters. However, the Java\n    // compiler may generate tagnames with uppercase letters so - for backwards\n    // compatibility, we lower case the tagname here.\n    const normalizedTagname = sel.toLowerCase();\n    const useNativeLifecycle = !lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE;\n    const isFormAssociated = shouldBeFormAssociated(ctor);\n    const elm = createCustomElement(normalizedTagname, upgradeCallback, useNativeLifecycle, isFormAssociated);\n    vnode.elm = elm;\n    vnode.vm = vm;\n    linkNodeToShadow(elm, owner, renderer);\n    applyStyleScoping(elm, owner, renderer);\n    if (vm) {\n        allocateChildren(vnode, vm);\n    }\n    patchElementPropsAndAttrsAndRefs$1(null, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n    if (vm) {\n        {\n            if (!useNativeLifecycle) {\n                if (process.env.NODE_ENV !== 'production') {\n                    // With synthetic lifecycle callbacks, it's possible for elements to be removed without the engine\n                    // noticing it (e.g. `appendChild` the same host element twice). This test ensures we don't regress.\n                    assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);\n                }\n                runConnectedCallback(vm);\n            }\n        }\n    }\n    mountVNodes(vnode.children, elm, renderer, null);\n    if (vm) {\n        appendVM(vm);\n    }\n}\nfunction patchCustomElement(n1, n2, parent, renderer) {\n    // TODO [#3331]: This if branch should be removed in 246 with lwc:dynamic\n    if (n1.ctor !== n2.ctor) {\n        // If the constructor differs, unmount the current component and mount a new one using the new\n        // constructor.\n        const anchor = renderer.nextSibling(n1.elm);\n        unmount(n1, parent, renderer, true);\n        mountCustomElement(n2, parent, anchor, renderer);\n    }\n    else {\n        // Otherwise patch the existing component with new props/attrs/etc.\n        const elm = (n2.elm = n1.elm);\n        const vm = (n2.vm = n1.vm);\n        patchElementPropsAndAttrsAndRefs$1(n1, n2, renderer);\n        if (!isUndefined$1(vm)) {\n            // in fallback mode, the allocation will always set children to\n            // empty and delegate the real allocation to the slot elements\n            allocateChildren(n2, vm);\n            // Solves an edge case with slotted VFragments in native shadow mode.\n            //\n            // During allocation, in native shadow, slotted VFragment nodes are flattened and their text delimiters are removed\n            // to avoid interfering with native slot behavior. When this happens, if any of the fragments\n            // were not stable, the children must go through the dynamic diffing algo.\n            //\n            // If the new children (n2.children) contain no VFragments, but the previous children (n1.children) were dynamic,\n            // the new nodes must be marked dynamic so that all nodes are properly updated. The only indicator that the new\n            // nodes need to be dynamic comes from the previous children, so we check that to determine whether we need to\n            // mark the new children dynamic.\n            //\n            // Example:\n            // n1.children: [div, VFragment('', div, null, ''), div] => [div, div, null, div]; // marked dynamic\n            // n2.children: [div, null, div] => [div, null, div] // marked ???\n            const { shadowMode, renderMode } = vm;\n            if (shadowMode == 0 /* ShadowMode.Native */ &&\n                renderMode !== 0 /* RenderMode.Light */ &&\n                hasDynamicChildren(n1.children)) {\n                // No-op if children has already been marked dynamic by 'allocateChildren()'.\n                markAsDynamicChildren(n2.children);\n            }\n        }\n        // in fallback mode, the children will be always empty, so, nothing\n        // will happen, but in native, it does allocate the light dom\n        patchChildren(n1.children, n2.children, elm, renderer);\n        if (!isUndefined$1(vm)) {\n            // this will probably update the shadowRoot, but only if the vm is in a dirty state\n            // this is important to preserve the top to bottom synchronous rendering phase.\n            rerenderVM(vm);\n        }\n    }\n}\nfunction mountVNodes(vnodes, parent, renderer, anchor, start = 0, end = vnodes.length) {\n    for (; start < end; ++start) {\n        const vnode = vnodes[start];\n        if (isVNode(vnode)) {\n            mount(vnode, parent, renderer, anchor);\n        }\n    }\n}\nfunction unmount(vnode, parent, renderer, doRemove = false) {\n    const { type, elm, sel } = vnode;\n    // When unmounting a VNode subtree not all the elements have to removed from the DOM. The\n    // subtree root, is the only element worth unmounting from the subtree.\n    if (doRemove && type !== 5 /* VNodeType.Fragment */) {\n        // The vnode might or might not have a data.renderer associated to it\n        // but the removal used here is from the owner instead.\n        removeNode(elm, parent, renderer);\n    }\n    switch (type) {\n        case 5 /* VNodeType.Fragment */: {\n            unmountVNodes(vnode.children, parent, renderer, doRemove);\n            break;\n        }\n        case 2 /* VNodeType.Element */: {\n            // Slot content is removed to trigger slotchange event when removing slot.\n            // Only required for synthetic shadow.\n            const shouldRemoveChildren = sel === 'slot' && vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;\n            unmountVNodes(vnode.children, elm, renderer, shouldRemoveChildren);\n            break;\n        }\n        case 3 /* VNodeType.CustomElement */: {\n            const { vm } = vnode;\n            // No need to unmount the children here, `removeVM` will take care of removing the\n            // children.\n            if (!isUndefined$1(vm)) {\n                removeVM(vm);\n            }\n        }\n    }\n}\nfunction unmountVNodes(vnodes, parent, renderer, doRemove = false, start = 0, end = vnodes.length) {\n    for (; start < end; ++start) {\n        const ch = vnodes[start];\n        if (isVNode(ch)) {\n            unmount(ch, parent, renderer, doRemove);\n        }\n    }\n}\nfunction isVNode(vnode) {\n    return vnode != null;\n}\nfunction linkNodeToShadow(elm, owner, renderer) {\n    const { renderRoot, renderMode, shadowMode } = owner;\n    const { isSyntheticShadowDefined } = renderer;\n    // TODO [#1164]: this should eventually be done by the polyfill directly\n    if (isSyntheticShadowDefined) {\n        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n            elm[KEY__SHADOW_RESOLVER] = renderRoot[KEY__SHADOW_RESOLVER];\n        }\n    }\n}\nfunction insertFragmentOrNode(vnode, parent, anchor, renderer) {\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    if (isVFragment(vnode)) {\n        const children = vnode.children;\n        for (let i = 0; i < children.length; i += 1) {\n            const child = children[i];\n            if (!isNull(child)) {\n                renderer.insert(child.elm, parent, anchor);\n            }\n        }\n    }\n    else {\n        renderer.insert(vnode.elm, parent, anchor);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\nfunction insertNode(node, parent, anchor, renderer) {\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    renderer.insert(node, parent, anchor);\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\nfunction removeNode(node, parent, renderer) {\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    renderer.remove(node, parent);\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\nfunction patchElementPropsAndAttrsAndRefs$1(oldVnode, vnode, renderer) {\n    if (isNull(oldVnode)) {\n        applyEventListeners(vnode, renderer);\n        applyStaticClassAttribute(vnode, renderer);\n        applyStaticStyleAttribute(vnode, renderer);\n    }\n    const { owner } = vnode;\n    // Attrs need to be applied to element before props IE11 will wipe out value on radio inputs if\n    // value is set before type=radio.\n    patchClassAttribute(oldVnode, vnode, renderer);\n    patchStyleAttribute(oldVnode, vnode, renderer, owner);\n    patchAttributes(oldVnode, vnode, renderer);\n    patchProps(oldVnode, vnode, renderer);\n    patchSlotAssignment(oldVnode, vnode, renderer);\n    // The `refs` object is blown away in every re-render, so we always need to re-apply them\n    applyRefs(vnode, owner);\n}\nfunction applyStyleScoping(elm, owner, renderer) {\n    const { getClassList } = renderer;\n    // Set the class name for `*.scoped.css` style scoping.\n    const scopeToken = getScopeTokenClass(owner, /* legacy */ false);\n    if (!isNull(scopeToken)) {\n        // TODO [#2762]: this dot notation with add is probably problematic\n        // probably we should have a renderer api for just the add operation\n        getClassList(elm).add(scopeToken);\n    }\n    // TODO [#3733]: remove support for legacy scope tokens\n    if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {\n        const legacyScopeToken = getScopeTokenClass(owner, /* legacy */ true);\n        if (!isNull(legacyScopeToken)) {\n            // TODO [#2762]: this dot notation with add is probably problematic\n            // probably we should have a renderer api for just the add operation\n            getClassList(elm).add(legacyScopeToken);\n        }\n    }\n    // Set property element for synthetic shadow DOM style scoping.\n    const { stylesheetToken: syntheticToken } = owner.context;\n    if (owner.shadowMode === 1 /* ShadowMode.Synthetic */) {\n        if (!isUndefined$1(syntheticToken)) {\n            elm.$shadowToken$ = syntheticToken;\n        }\n        if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {\n            const legacyToken = owner.context.legacyStylesheetToken;\n            if (!isUndefined$1(legacyToken)) {\n                elm.$legacyShadowToken$ = legacyToken;\n            }\n        }\n    }\n}\nfunction applyDomManual(elm, vnode) {\n    const { owner, data: { context }, } = vnode;\n    if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && context?.lwc?.dom === 'manual') {\n        elm.$domManual$ = true;\n    }\n}\nfunction applyElementRestrictions(elm, vnode) {\n    if (process.env.NODE_ENV !== 'production') {\n        const isSynthetic = vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;\n        const isPortal = vnode.type === 2 /* VNodeType.Element */ && vnode.data.context?.lwc?.dom === 'manual';\n        const isLight = vnode.owner.renderMode === 0 /* RenderMode.Light */;\n        patchElementWithRestrictions(elm, {\n            isPortal,\n            isLight,\n            isSynthetic,\n        });\n    }\n}\nfunction allocateChildren(vnode, vm) {\n    // A component with slots will re-render because:\n    // 1- There is a change of the internal state.\n    // 2- There is a change on the external api (ex: slots)\n    //\n    // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the\n    // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children\n    // in a reused VCustomElement, there won't be any slotted children.\n    // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.\n    //\n    // In case #2, we will always get a fresh VCustomElement.\n    const children = vnode.aChildren || vnode.children;\n    const { renderMode, shadowMode } = vm;\n    if (process.env.NODE_ENV !== 'production') {\n        // If any of the children being allocated is a scoped slot fragment, make sure the receiving\n        // component is a light DOM component. This is mainly to validate light dom parent running\n        // in native shadow mode.\n        if (renderMode !== 0 /* RenderMode.Light */ &&\n            ArraySome.call(children, (child) => !isNull(child) && isVScopedSlotFragment(child))) {\n            logError(`Invalid usage of 'lwc:slot-data' on ${getComponentTag(vm)} tag. Scoped slot content can only be passed to a light dom child.`);\n        }\n    }\n    // If any of the children being allocated are VFragments, we remove the text delimiters and flatten all immediate\n    // children VFragments to avoid them interfering with default slot behavior.\n    const allocatedChildren = flattenFragmentsInChildren(children);\n    vnode.children = allocatedChildren;\n    vm.aChildren = allocatedChildren;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n        // slow path\n        allocateInSlot(vm, allocatedChildren, vnode.owner);\n        // save the allocated children in case this vnode is reused.\n        vnode.aChildren = allocatedChildren;\n        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n        vnode.children = EmptyArray;\n    }\n}\n/**\n * Flattens the contents of all VFragments in an array of VNodes, removes the text delimiters on those VFragments, and\n * marks the resulting children array as dynamic. Uses a stack (array) to iteratively traverse the nested VFragments\n * and avoid the perf overhead of creating/destroying throwaway arrays/objects in a recursive approach.\n *\n * With the delimiters removed, the contents are marked dynamic so they are diffed correctly.\n *\n * This function is used for slotted VFragments to avoid the text delimiters interfering with slotting functionality.\n * @param children\n */\nfunction flattenFragmentsInChildren(children) {\n    const flattenedChildren = [];\n    // Initialize our stack with the direct children of the custom component and check whether we have a VFragment.\n    // If no VFragment is found in children, we don't need to traverse anything or mark the children dynamic and can return early.\n    const nodeStack = [];\n    let fragmentFound = false;\n    for (let i = children.length - 1; i > -1; i -= 1) {\n        const child = children[i];\n        ArrayPush$1.call(nodeStack, child);\n        fragmentFound = fragmentFound || !!(child && isVFragment(child));\n    }\n    if (!fragmentFound) {\n        return children;\n    }\n    let currentNode;\n    while (!isUndefined$1((currentNode = ArrayPop.call(nodeStack)))) {\n        if (!isNull(currentNode) && isVFragment(currentNode)) {\n            const fChildren = currentNode.children;\n            // Ignore the start and end text node delimiters\n            for (let i = fChildren.length - 2; i > 0; i -= 1) {\n                ArrayPush$1.call(nodeStack, fChildren[i]);\n            }\n        }\n        else {\n            ArrayPush$1.call(flattenedChildren, currentNode);\n        }\n    }\n    // We always mark the children as dynamic because nothing generates stable VFragments yet.\n    // If/when stable VFragments are generated by the compiler, this code should be updated to\n    // not mark dynamic if all flattened VFragments were stable.\n    markAsDynamicChildren(flattenedChildren);\n    return flattenedChildren;\n}\nfunction createViewModelHook(elm, vnode, renderer) {\n    let vm = getAssociatedVMIfPresent(elm);\n    // There is a possibility that a custom element is registered under tagName, in which case, the\n    // initialization is already carry on, and there is nothing else to do here since this hook is\n    // called right after invoking `document.createElement`.\n    if (!isUndefined$1(vm)) {\n        return vm;\n    }\n    const { sel, mode, ctor, owner } = vnode;\n    vm = createVM(elm, ctor, renderer, {\n        mode,\n        owner,\n        tagName: sel,\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    return vm;\n}\nfunction allocateInSlot(vm, children, owner) {\n    const { cmpSlots: { slotAssignments: oldSlotsMapping }, } = vm;\n    const cmpSlotsMapping = create(null);\n    // Collect all slots into cmpSlotsMapping\n    for (let i = 0, len = children.length; i < len; i += 1) {\n        const vnode = children[i];\n        if (isNull(vnode)) {\n            continue;\n        }\n        let slotName = '';\n        if (isVBaseElement(vnode) || isVStatic(vnode)) {\n            slotName = vnode.slotAssignment ?? '';\n        }\n        else if (isVScopedSlotFragment(vnode)) {\n            slotName = vnode.slotName;\n        }\n        // Can't use toString here because Symbol(1).toString() is 'Symbol(1)'\n        // but elm.setAttribute('slot', Symbol(1)) is an error.\n        // the following line also throws same error for symbols\n        // Similar for Object.create(null)\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        const normalizedSlotName = '' + slotName;\n        const vnodes = (cmpSlotsMapping[normalizedSlotName] =\n            cmpSlotsMapping[normalizedSlotName] || []);\n        ArrayPush$1.call(vnodes, vnode);\n    }\n    vm.cmpSlots = { owner, slotAssignments: cmpSlotsMapping };\n    if (isFalse(vm.isDirty)) {\n        // We need to determine if the old allocation is really different from the new one\n        // and mark the vm as dirty\n        const oldKeys = keys(oldSlotsMapping);\n        if (oldKeys.length !== keys(cmpSlotsMapping).length) {\n            markComponentAsDirty(vm);\n            return;\n        }\n        for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n            const key = oldKeys[i];\n            if (isUndefined$1(cmpSlotsMapping[key]) ||\n                oldSlotsMapping[key].length !== cmpSlotsMapping[key].length) {\n                markComponentAsDirty(vm);\n                return;\n            }\n            const oldVNodes = oldSlotsMapping[key];\n            const vnodes = cmpSlotsMapping[key];\n            for (let j = 0, a = cmpSlotsMapping[key].length; j < a; j += 1) {\n                if (oldVNodes[j] !== vnodes[j]) {\n                    markComponentAsDirty(vm);\n                    return;\n                }\n            }\n        }\n    }\n}\nconst DynamicChildren = new WeakSet();\n// dynamic children means it was either generated by an iteration in a template\n// or part of an unstable fragment, and will require a more complex diffing algo.\nfunction markAsDynamicChildren(children) {\n    DynamicChildren.add(children);\n}\nfunction hasDynamicChildren(children) {\n    return DynamicChildren.has(children);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    const map = {};\n    // TODO [#1637]: simplify this by assuming that all vnodes has keys\n    for (let j = beginIdx; j <= endIdx; ++j) {\n        const ch = children[j];\n        if (isVNode(ch)) {\n            const { key } = ch;\n            if (key !== undefined) {\n                map[key] = j;\n            }\n        }\n    }\n    return map;\n}\nfunction updateDynamicChildren(oldCh, newCh, parent, renderer) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    const newChEnd = newCh.length - 1;\n    let newEndIdx = newChEnd;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx;\n    let idxInOld;\n    let elmToMove;\n    let before;\n    let clonedOldCh = false;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (!isVNode(oldStartVnode)) {\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n        }\n        else if (!isVNode(oldEndVnode)) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (!isVNode(newStartVnode)) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (!isVNode(newEndVnode)) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode, parent, renderer);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode, parent, renderer);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            patch(oldStartVnode, newEndVnode, parent, renderer);\n            // In the case of fragments, the `elm` property of a vfragment points to the leading\n            // anchor. To determine the next sibling of the whole fragment, we need to use the\n            // trailing anchor as the argument to nextSibling():\n            // [..., [leading, ...content, trailing], nextSibling, ...]\n            let anchor;\n            if (isVFragment(oldEndVnode)) {\n                anchor = renderer.nextSibling(oldEndVnode.trailing.elm);\n            }\n            else {\n                anchor = renderer.nextSibling(oldEndVnode.elm);\n            }\n            insertFragmentOrNode(oldStartVnode, parent, anchor, renderer);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            patch(oldEndVnode, newStartVnode, parent, renderer);\n            insertFragmentOrNode(newStartVnode, parent, oldStartVnode.elm, renderer);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            if (oldKeyToIdx === undefined) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key];\n            if (isUndefined$1(idxInOld)) {\n                // New element\n                mount(newStartVnode, parent, renderer, oldStartVnode.elm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                elmToMove = oldCh[idxInOld];\n                if (isVNode(elmToMove)) {\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        // New element\n                        mount(newStartVnode, parent, renderer, oldStartVnode.elm);\n                    }\n                    else {\n                        patch(elmToMove, newStartVnode, parent, renderer);\n                        // Delete the old child, but copy the array since it is read-only.\n                        // The `oldCh` will be GC'ed after `updateDynamicChildren` is complete,\n                        // so we only care about the `oldCh` object inside this function.\n                        // To avoid cloning over and over again, we check `clonedOldCh`\n                        // and only clone once.\n                        if (!clonedOldCh) {\n                            clonedOldCh = true;\n                            oldCh = [...oldCh];\n                        }\n                        // We've already cloned at least once, so it's no longer read-only\n                        oldCh[idxInOld] = undefined;\n                        insertFragmentOrNode(elmToMove, parent, oldStartVnode.elm, renderer);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n        if (oldStartIdx > oldEndIdx) {\n            // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an\n            // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.\n            let i = newEndIdx;\n            let n;\n            do {\n                n = newCh[++i];\n            } while (!isVNode(n) && i < newChEnd);\n            before = isVNode(n) ? n.elm : null;\n            mountVNodes(newCh, parent, renderer, before, newStartIdx, newEndIdx + 1);\n        }\n        else {\n            unmountVNodes(oldCh, parent, renderer, true, oldStartIdx, oldEndIdx + 1);\n        }\n    }\n}\nfunction updateStaticChildren(c1, c2, parent, renderer) {\n    const c1Length = c1.length;\n    const c2Length = c2.length;\n    if (c1Length === 0) {\n        // the old list is empty, we can directly insert anything new\n        mountVNodes(c2, parent, renderer, null);\n        return;\n    }\n    if (c2Length === 0) {\n        // the old list is nonempty and the new list is empty so we can directly remove all old nodes\n        // this is the case in which the dynamic children of an if-directive should be removed\n        unmountVNodes(c1, parent, renderer, true);\n        return;\n    }\n    // if the old list is not empty, the new list MUST have the same\n    // amount of nodes, that's why we call this static children\n    let anchor = null;\n    for (let i = c2Length - 1; i >= 0; i -= 1) {\n        const n1 = c1[i];\n        const n2 = c2[i];\n        if (n2 !== n1) {\n            if (isVNode(n1)) {\n                if (isVNode(n2)) {\n                    if (isSameVnode(n1, n2)) {\n                        // both vnodes are equivalent, and we just need to patch them\n                        patch(n1, n2, parent, renderer);\n                        anchor = n2.elm;\n                    }\n                    else {\n                        // removing the old vnode since the new one is different\n                        unmount(n1, parent, renderer, true);\n                        mount(n2, parent, renderer, anchor);\n                        anchor = n2.elm;\n                    }\n                }\n                else {\n                    // removing the old vnode since the new one is null\n                    unmount(n1, parent, renderer, true);\n                }\n            }\n            else if (isVNode(n2)) {\n                mount(n2, parent, renderer, anchor);\n                anchor = n2.elm;\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst SymbolIterator = Symbol.iterator;\nfunction addVNodeToChildLWC(vnode) {\n    ArrayPush$1.call(getVMBeingRendered().velements, vnode);\n}\n// [s]tatic [p]art\nfunction sp(partId, data, text) {\n    // Static part will always have either text or data, it's guaranteed by the compiler.\n    const type = isNull(text) ? 1 /* VStaticPartType.Element */ : 0 /* VStaticPartType.Text */;\n    return {\n        type,\n        partId,\n        data,\n        text,\n        elm: undefined, // elm is defined later\n    };\n}\n// [s]coped [s]lot [f]actory\nfunction ssf(slotName, factory) {\n    return {\n        type: 6 /* VNodeType.ScopedSlotFragment */,\n        factory,\n        owner: getVMBeingRendered(),\n        elm: undefined,\n        sel: '__scoped_slot_fragment__',\n        key: undefined,\n        slotName,\n    };\n}\n// [st]atic node\nfunction st(fragmentFactory, key, parts) {\n    const owner = getVMBeingRendered();\n    const fragment = fragmentFactory(parts);\n    const vnode = {\n        type: 4 /* VNodeType.Static */,\n        sel: '__static__',\n        key,\n        elm: undefined,\n        fragment,\n        owner,\n        parts,\n        slotAssignment: undefined,\n    };\n    return vnode;\n}\n// [fr]agment node\nfunction fr(key, children, stable) {\n    const owner = getVMBeingRendered();\n    const useCommentNodes = isAPIFeatureEnabled(5 /* APIFeature.USE_COMMENTS_FOR_FRAGMENT_BOOKENDS */, owner.apiVersion);\n    const leading = useCommentNodes ? co('') : t('');\n    const trailing = useCommentNodes ? co('') : t('');\n    return {\n        type: 5 /* VNodeType.Fragment */,\n        sel: '__fragment__',\n        key,\n        elm: undefined,\n        children: [leading, ...children, trailing],\n        stable,\n        owner,\n        leading,\n        trailing,\n    };\n}\n// [h]tml node\nfunction h(sel, data, children = EmptyArray) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);\n        assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n        assert.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);\n        forEach.call(children, (childVnode) => {\n            if (childVnode != null) {\n                assert.isTrue('type' in childVnode &&\n                    'sel' in childVnode &&\n                    'elm' in childVnode &&\n                    'key' in childVnode, `${childVnode} is not a vnode.`);\n            }\n        });\n    }\n    const { key, slotAssignment } = data;\n    const vnode = {\n        type: 2 /* VNodeType.Element */,\n        sel,\n        data,\n        children,\n        elm: undefined,\n        key,\n        owner: vmBeingRendered,\n        slotAssignment,\n    };\n    return vnode;\n}\n// [t]ab[i]ndex function\nfunction ti(value) {\n    // if value is greater than 0, we normalize to 0\n    // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n    // If value is less than -1, we don't care\n    const shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));\n    if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        if (shouldNormalize) {\n            logError(`Invalid tabindex value \\`${toString(value)}\\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);\n        }\n    }\n    return shouldNormalize ? 0 : value;\n}\n// [s]lot element node\nfunction s(slotName, data, children, slotset) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n        assert.isTrue(isObject(data), `s() 2nd argument data must be an object.`);\n        assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n    }\n    const vmBeingRendered = getVMBeingRendered();\n    const { renderMode, apiVersion } = vmBeingRendered;\n    if (!isUndefined$1(slotset) &&\n        !isUndefined$1(slotset.slotAssignments) &&\n        !isUndefined$1(slotset.slotAssignments[slotName]) &&\n        slotset.slotAssignments[slotName].length !== 0) {\n        const newChildren = [];\n        const slotAssignments = slotset.slotAssignments[slotName];\n        for (let i = 0; i < slotAssignments.length; i++) {\n            const vnode = slotAssignments[i];\n            if (!isNull(vnode)) {\n                const assignedNodeIsScopedSlot = isVScopedSlotFragment(vnode);\n                // The only sniff test for a scoped <slot> element is the presence of `slotData`\n                const isScopedSlotElement = !isUndefined$1(data.slotData);\n                // Check if slot types of parent and child are matching\n                if (assignedNodeIsScopedSlot !== isScopedSlotElement) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logError(`Mismatched slot types for ${slotName === '' ? '(default)' : slotName} slot. Both parent and child component must use standard type or scoped type for a given slot.`, slotset.owner);\n                    }\n                    // Ignore slot content from parent\n                    continue;\n                }\n                // If the passed slot content is factory, evaluate it and add the produced vnodes\n                if (assignedNodeIsScopedSlot) {\n                    // Evaluate in the scope of the slot content's owner\n                    // if a slotset is provided, there will always be an owner. The only case where owner is\n                    // undefined is for root components, but root components cannot accept slotted content\n                    setVMBeingRendered(slotset.owner);\n                    try {\n                        // The factory function is a template snippet from the slot set owner's template,\n                        // hence switch over to the slot set owner's template reactive observer\n                        const { tro } = slotset.owner;\n                        tro.observe(() => {\n                            ArrayPush$1.call(newChildren, vnode.factory(data.slotData, data.key));\n                        });\n                    }\n                    finally {\n                        setVMBeingRendered(vmBeingRendered);\n                    }\n                }\n                else {\n                    // This block is for standard slots (non-scoped slots)\n                    let clonedVNode;\n                    if (renderMode === 0 /* RenderMode.Light */ &&\n                        isAPIFeatureEnabled(6 /* APIFeature.USE_LIGHT_DOM_SLOT_FORWARDING */, apiVersion) &&\n                        (isVBaseElement(vnode) || isVStatic(vnode)) &&\n                        vnode.slotAssignment !== data.slotAssignment) {\n                        // When the light DOM slot assignment (slot attribute) changes, we can't use the same reference\n                        // to the vnode because the current way the diffing algo works, it will replace the original\n                        // reference to the host element with a new one. This means the new element will be mounted and\n                        // immediately unmounted. Creating a copy of the vnode preserves a reference to the previous\n                        // host element.\n                        clonedVNode = { ...vnode, slotAssignment: data.slotAssignment };\n                        // For disconnectedCallback to work correctly in synthetic lifecycle mode, we need to link the\n                        // current VM's velements to the clone, so that when the VM unmounts, the clone also unmounts.\n                        // Note this only applies to VCustomElements, since those are the elements that we manually need\n                        // to call disconnectedCallback for, when running in synthetic lifecycle mode.\n                        //\n                        // You might think it would make more sense to add the clonedVNode to the same velements array\n                        // as the original vnode's VM (i.e. `vnode.owner.velements`) rather than the current VM (i.e.\n                        // `vmBeingRendered.velements`), but this actually might not trigger disconnectedCallback\n                        // in synthetic lifecycle mode. The reason for this is that a reactivity change may cause\n                        // the slottable component to unmount, but _not_ the slotter component (see issue #4446).\n                        //\n                        // If this occurs, then the slottable component (i.e .this component we are rendering right\n                        // now) is the one that needs to own the clone. Whereas if a reactivity change higher in the\n                        // tree causes the slotter to unmount, then the slottable will also unmount. So using the\n                        // current VM works either way.\n                        if (isVCustomElement(vnode)) {\n                            addVNodeToChildLWC(clonedVNode);\n                        }\n                    }\n                    // If the slot content is standard type, the content is static, no additional\n                    // processing needed on the vnode\n                    ArrayPush$1.call(newChildren, clonedVNode ?? vnode);\n                }\n            }\n        }\n        children = newChildren;\n    }\n    const { shadowMode } = vmBeingRendered;\n    if (renderMode === 0 /* RenderMode.Light */) {\n        // light DOM slots - backwards-compatible behavior uses flattening, new behavior uses fragments\n        if (isAPIFeatureEnabled(2 /* APIFeature.USE_FRAGMENTS_FOR_LIGHT_DOM_SLOTS */, apiVersion)) {\n            return fr(data.key, children, 0);\n        }\n        else {\n            sc(children);\n            return children;\n        }\n    }\n    if (shadowMode === 1 /* ShadowMode.Synthetic */) {\n        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n        sc(children);\n    }\n    return h('slot', data, children);\n}\n// [c]ustom element node\nfunction c(sel, Ctor, data, children = EmptyArray) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n        assert.isTrue(isFunction$1(Ctor), `c() 2nd argument Ctor must be a function.`);\n        assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `c() 4nd argument data must be an array.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n        }\n        if (arguments.length === 4) {\n            forEach.call(children, (childVnode) => {\n                if (childVnode != null) {\n                    assert.isTrue('type' in childVnode &&\n                        'sel' in childVnode &&\n                        'elm' in childVnode &&\n                        'key' in childVnode, `${childVnode} is not a vnode.`);\n                }\n            });\n        }\n    }\n    const { key, slotAssignment } = data;\n    let elm, aChildren, vm;\n    const vnode = {\n        type: 3 /* VNodeType.CustomElement */,\n        sel,\n        data,\n        children,\n        elm,\n        key,\n        slotAssignment,\n        ctor: Ctor,\n        owner: vmBeingRendered,\n        mode: 'open', // TODO [#1294]: this should be defined in Ctor\n        aChildren,\n        vm,\n    };\n    addVNodeToChildLWC(vnode);\n    return vnode;\n}\n// [i]terable node\nfunction i(iterable, factory) {\n    const list = [];\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(list);\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(iterable) || isNull(iterable)) {\n        if (process.env.NODE_ENV !== 'production') {\n            logError(`Invalid template iteration for value \\`${toString(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object.`, vmBeingRendered);\n        }\n        return list;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isFalse(isUndefined$1(iterable[SymbolIterator]), `Invalid template iteration for value \\`${toString(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object.`);\n    }\n    const iterator = iterable[SymbolIterator]();\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(iterator && isFunction$1(iterator.next), `Invalid iterator function for \"${toString(iterable)}\" in ${vmBeingRendered}.`);\n    }\n    let next = iterator.next();\n    let j = 0;\n    let { value, done: last } = next;\n    let keyMap;\n    let iterationError;\n    if (process.env.NODE_ENV !== 'production') {\n        keyMap = create(null);\n    }\n    while (last === false) {\n        // implementing a look-back-approach because we need to know if the element is the last\n        next = iterator.next();\n        last = next.done;\n        // template factory logic based on the previous collected value\n        const vnode = factory(value, j, j === 0, last === true);\n        if (isArray$1(vnode)) {\n            ArrayPush$1.apply(list, vnode);\n        }\n        else {\n            // `isArray` doesn't narrow this block properly...\n            ArrayPush$1.call(list, vnode);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const vnodes = isArray$1(vnode) ? vnode : [vnode];\n            forEach.call(vnodes, (childVnode) => {\n                // Check that the child vnode is either an element or VStatic\n                if (!isNull(childVnode) && (isVBaseElement(childVnode) || isVStatic(childVnode))) {\n                    const { key } = childVnode;\n                    // In @lwc/engine-server the fragment doesn't have a tagName, default to the VM's tagName.\n                    const { tagName } = vmBeingRendered;\n                    if (isString(key) || isNumber(key)) {\n                        if (keyMap[key] === 1 && isUndefined$1(iterationError)) {\n                            iterationError = `Duplicated \"key\" attribute value in \"<${tagName}>\" for item number ${j}. A key with value \"${key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n                        }\n                        keyMap[key] = 1;\n                    }\n                    else if (isUndefined$1(iterationError)) {\n                        iterationError = `Invalid \"key\" attribute value in \"<${tagName}>\" for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n                    }\n                }\n            });\n        }\n        // preparing next value\n        j += 1;\n        value = next.value;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isUndefined$1(iterationError)) {\n            logError(iterationError, vmBeingRendered);\n        }\n    }\n    return list;\n}\n/**\n * [f]lattening\n * @param items\n */\nfunction f(items) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');\n    }\n    const len = items.length;\n    const flattened = [];\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(flattened);\n    for (let j = 0; j < len; j += 1) {\n        const item = items[j];\n        if (isArray$1(item)) {\n            ArrayPush$1.apply(flattened, item);\n        }\n        else {\n            // `isArray` doesn't narrow this block properly...\n            ArrayPush$1.call(flattened, item);\n        }\n    }\n    return flattened;\n}\n// [t]ext node\nfunction t(text) {\n    let key, elm;\n    return {\n        type: 0 /* VNodeType.Text */,\n        sel: '__text__',\n        text,\n        elm,\n        key,\n        owner: getVMBeingRendered(),\n    };\n}\n// [co]mment node\nfunction co(text) {\n    let elm, key;\n    return {\n        type: 1 /* VNodeType.Comment */,\n        sel: '__comment__',\n        text,\n        elm,\n        key,\n        owner: getVMBeingRendered(),\n    };\n}\n// [d]ynamic text\nfunction d(value) {\n    return value == null ? '' : String(value);\n}\n// [b]ind function\nfunction b(fn) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isNull(vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = vmBeingRendered;\n    return function (event) {\n        invokeEventListener(vm, fn, vm.component, event);\n    };\n}\n// [k]ey function\nfunction k(compilerKey, obj) {\n    switch (typeof obj) {\n        case 'number':\n        case 'string':\n            return compilerKey + ':' + obj;\n        case 'object':\n            if (process.env.NODE_ENV !== 'production') {\n                logError(`Invalid key value \"${obj}\" in ${getVMBeingRendered()}. Key must be a string or number.`);\n            }\n    }\n}\n// [g]lobal [id] function\nfunction gid(id) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(id) || id === '') {\n        return id;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (isNull(id)) {\n        return null;\n    }\n    const { idx, shadowMode } = vmBeingRendered;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */) {\n        return StringReplace.call(id, /\\S+/g, (id) => `${id}-${idx}`);\n    }\n    return id;\n}\n// [f]ragment [id] function\nfunction fid(url) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(url) || url === '') {\n        return url;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (isNull(url)) {\n        return null;\n    }\n    const { idx, shadowMode } = vmBeingRendered;\n    // Apply transformation only for fragment-only-urls, and only in shadow DOM\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ && /^#/.test(url)) {\n        return `${url}-${idx}`;\n    }\n    return url;\n}\n/**\n * [ddc] - create a (deprecated) dynamic component via `<x-foo lwc:dynamic={Ctor}>`\n *\n * TODO [#3331]: remove usage of lwc:dynamic in 246\n * @param sel\n * @param Ctor\n * @param data\n * @param children\n */\nfunction ddc(sel, Ctor, data, children = EmptyArray) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `dc() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 4nd argument data must be an array.`);\n    }\n    // null or undefined values should produce a null value in the VNodes\n    if (isNull(Ctor) || isUndefined$1(Ctor)) {\n        return null;\n    }\n    if (!isComponentConstructor(Ctor)) {\n        throw new Error(`Invalid LWC Constructor ${toString(Ctor)} for custom element <${sel}>.`);\n    }\n    return c(sel, Ctor, data, children);\n}\n/**\n * [dc] - create a dynamic component via `<lwc:component lwc:is={Ctor}>`\n * @param Ctor\n * @param data\n * @param children\n */\nfunction dc(Ctor, data, children = EmptyArray) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isObject(data), `dc() 2nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 3rd argument data must be an array.`);\n    }\n    // Null or undefined values should produce a null value in the VNodes.\n    // This is the only value at compile time as the constructor will not be known.\n    if (isNull(Ctor) || isUndefined$1(Ctor)) {\n        return null;\n    }\n    if (!isComponentConstructor(Ctor)) {\n        throw new Error(`Invalid constructor: \"${toString(Ctor)}\" is not a LightningElement constructor.`);\n    }\n    // Look up the dynamic component's name at runtime once the constructor is available.\n    // This information is only known at runtime and is stored as part of registerComponent.\n    const sel = getComponentRegisteredName(Ctor);\n    if (isUndefined$1(sel) || sel === '') {\n        throw new Error(`Invalid LWC constructor ${toString(Ctor)} does not have a registered name`);\n    }\n    return c(sel, Ctor, data, children);\n}\n/**\n * slow children collection marking mechanism. this API allows the compiler to signal\n * to the engine that a particular collection of children must be diffed using the slow\n * algo based on keys due to the nature of the list. E.g.:\n *\n * - slot element's children: the content of the slot has to be dynamic when in synthetic\n * shadow mode because the `vnode.children` might be the slotted\n * content vs default content, in which case the size and the\n * keys are not matching.\n * - children that contain dynamic components\n * - children that are produced by iteration\n * @param vnodes\n */\nfunction sc(vnodes) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');\n    }\n    // We have to mark the vnodes collection as dynamic so we can later on\n    // choose to use the snabbdom virtual dom diffing algo instead of our\n    // static dummy algo.\n    markAsDynamicChildren(vnodes);\n    return vnodes;\n}\n// [s]anitize [h]tml [c]ontent\nfunction shc(content) {\n    const sanitizedString = sanitizeHtmlContent(content);\n    return createSanitizedHtmlContent(sanitizedString);\n}\nconst ncls = normalizeClass;\nconst api = freeze({\n    s,\n    h,\n    c,\n    i,\n    f,\n    t,\n    d,\n    b,\n    k,\n    co,\n    dc,\n    fr,\n    ti,\n    st,\n    gid,\n    fid,\n    shc,\n    ssf,\n    ddc,\n    sp,\n    ncls,\n});\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst operationIdNameMapping = [\n    'constructor',\n    'render',\n    'patch',\n    'connectedCallback',\n    'renderedCallback',\n    'disconnectedCallback',\n    'errorCallback',\n    'lwc-render',\n    'lwc-rerender',\n    'lwc-ssr-hydrate',\n];\nconst operationTooltipMapping = [\n    // constructor\n    'component constructor()',\n    // render\n    'component render() and virtual DOM rendered',\n    // patch\n    'component DOM rendered',\n    // connectedCallback\n    'component connectedCallback()',\n    // renderedCallback\n    'component renderedCallback()',\n    // disconnectedCallback\n    'component disconnectedCallback()',\n    // errorCallback\n    'component errorCallback()',\n    // lwc-render\n    'component first rendered',\n    // lwc-rerender\n    'component re-rendered',\n    // lwc-ssr-hydrate\n    'component hydrated from server-rendered HTML',\n];\n// Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\nconst isUserTimingSupported = typeof performance !== 'undefined' &&\n    typeof performance.mark === 'function' &&\n    typeof performance.clearMarks === 'function' &&\n    typeof performance.measure === 'function' &&\n    typeof performance.clearMeasures === 'function';\nconst start = !isUserTimingSupported\n    ? noop\n    : (markName) => {\n        performance.mark(markName);\n    };\nconst end = !isUserTimingSupported\n    ? noop\n    : (measureName, markName, devtools) => {\n        performance.measure(measureName, {\n            start: markName,\n            detail: {\n                devtools: {\n                    dataType: 'track-entry',\n                    track: 'âš¡ï¸ Lightning Web Components',\n                    ...devtools,\n                },\n            },\n        });\n        // Clear the created marks and measure to avoid filling the performance entries buffer.\n        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n        performance.clearMarks(markName);\n        performance.clearMeasures(measureName);\n    };\nfunction getOperationName(opId) {\n    return operationIdNameMapping[opId];\n}\nfunction getMeasureName(opId, vm) {\n    return `${getComponentTag(vm)} - ${getOperationName(opId)}`;\n}\nfunction getMarkName(opId, vm) {\n    // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce\n    // the right measures for components that are recursive.\n    return `${getMeasureName(opId, vm)} - ${vm.idx}`;\n}\nfunction getProperties(vm) {\n    return [\n        ['Tag Name', vm.tagName],\n        ['Component ID', String(vm.idx)],\n        ['Render Mode', vm.renderMode === 0 /* RenderMode.Light */ ? 'light DOM' : 'shadow DOM'],\n        ['Shadow Mode', vm.shadowMode === 0 /* ShadowMode.Native */ ? 'native' : 'synthetic'],\n    ];\n}\nfunction getColor(opId) {\n    // As of Sept 2024: primary (dark blue), secondary (light blue), tertiary (green)\n    switch (opId) {\n        // GlobalSsrHydrate, GlobalRender, and Constructor tend to occur at the top level\n        case 7 /* OperationId.GlobalRender */:\n        case 9 /* OperationId.GlobalSsrHydrate */:\n        case 0 /* OperationId.Constructor */:\n            return 'primary';\n        // GlobalRerender also occurs at the top level, but we want to use tertiary (green) because it's easier to\n        // distinguish from primary, and at a glance you should be able to easily tell re-renders from first renders.\n        case 8 /* OperationId.GlobalRerender */:\n            return 'tertiary';\n        // Everything else (patch/render/callbacks)\n        default:\n            return 'secondary';\n    }\n}\n// Create a list of tag names to the properties that were mutated, to help answer the question of\n// \"why did this component re-render?\"\nfunction getMutationProperties(mutationLogs) {\n    // `mutationLogs` should never have length 0, but bail out if it does for whatever reason\n    if (isUndefined$1(mutationLogs)) {\n        return EmptyArray;\n    }\n    if (!mutationLogs.length) {\n        // Currently this only occurs for experimental signals, because those mutations are not triggered by accessors\n        // TODO [#4546]: support signals in mutation logging\n        return EmptyArray;\n    }\n    // Keep track of unique IDs per tag name so we can just report a raw count at the end, e.g.\n    // `<x-foo> (x2)` to indicate that two instances of `<x-foo>` were rendered.\n    const tagNamesToIdsAndProps = new Map();\n    for (const { vm: { tagName, idx }, prop, } of mutationLogs) {\n        let idsAndProps = tagNamesToIdsAndProps.get(tagName);\n        if (isUndefined$1(idsAndProps)) {\n            idsAndProps = { ids: new Set(), keys: new Set() };\n            tagNamesToIdsAndProps.set(tagName, idsAndProps);\n        }\n        idsAndProps.ids.add(idx);\n        idsAndProps.keys.add(prop);\n    }\n    // Sort by tag name\n    const entries = ArraySort.call([...tagNamesToIdsAndProps], (a, b) => a[0].localeCompare(b[0]));\n    const tagNames = ArrayMap.call(entries, (item) => item[0]);\n    // Show e.g. `<x-foo>` for one instance, or `<x-foo> (x2)` for two instances. (\\u00D7 is multiplication symbol)\n    const tagNamesToDisplayTagNames = new Map();\n    for (const tagName of tagNames) {\n        const { ids } = tagNamesToIdsAndProps.get(tagName);\n        const displayTagName = `<${tagName}>${ids.size > 1 ? ` (\\u00D7${ids.size})` : ''}`;\n        tagNamesToDisplayTagNames.set(tagName, displayTagName);\n    }\n    // Summary row\n    const usePlural = tagNames.length > 1 || tagNamesToIdsAndProps.get(tagNames[0]).ids.size > 1;\n    const result = [\n        [\n            `Component${usePlural ? 's' : ''}`,\n            ArrayJoin.call(ArrayMap.call(tagNames, (_) => tagNamesToDisplayTagNames.get(_)), ', '),\n        ],\n    ];\n    // Detail rows\n    for (const [prettyTagName, { keys }] of entries) {\n        const displayTagName = tagNamesToDisplayTagNames.get(prettyTagName);\n        ArrayPush$1.call(result, [displayTagName, ArrayJoin.call(ArraySort.call([...keys]), ', ')]);\n    }\n    return result;\n}\nfunction getTooltipText(measureName, opId) {\n    return `${measureName} - ${operationTooltipMapping[opId]}`;\n}\n/** Indicates if operations should be logged via the User Timing API. */\nconst isMeasureEnabled = process.env.NODE_ENV !== 'production';\n/** Indicates if operations should be logged by the profiler. */\nlet isProfilerEnabled = false;\n/** The currently assigned profiler dispatcher. */\nlet currentDispatcher = noop;\nconst profilerControl = {\n    enableProfiler() {\n        isProfilerEnabled = true;\n    },\n    disableProfiler() {\n        isProfilerEnabled = false;\n    },\n    attachDispatcher(dispatcher) {\n        currentDispatcher = dispatcher;\n        this.enableProfiler();\n    },\n    detachDispatcher() {\n        const dispatcher = currentDispatcher;\n        currentDispatcher = noop;\n        this.disableProfiler();\n        return dispatcher;\n    },\n};\nfunction logOperationStart(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logOperationEnd(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        const measureName = getMeasureName(opId, vm);\n        end(measureName, markName, {\n            color: getColor(opId),\n            tooltipText: getTooltipText(measureName, opId),\n            properties: getProperties(vm),\n        });\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logGlobalOperationStart(opId) {\n    if (isMeasureEnabled) {\n        const markName = getOperationName(opId);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */);\n    }\n}\nfunction logGlobalOperationStartWithVM(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logGlobalOperationEnd(opId, mutationLogs) {\n    if (isMeasureEnabled) {\n        const opName = getOperationName(opId);\n        const markName = opName;\n        end(opName, markName, {\n            color: getColor(opId),\n            tooltipText: getTooltipText(opName, opId),\n            properties: getMutationProperties(mutationLogs),\n        });\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */);\n    }\n}\nfunction logGlobalOperationEndWithVM(opId, vm) {\n    if (isMeasureEnabled) {\n        const opName = getOperationName(opId);\n        const markName = getMarkName(opId, vm);\n        end(opName, markName, {\n            color: getColor(opId),\n            tooltipText: getTooltipText(opName, opId),\n            properties: getProperties(vm),\n        });\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// HAS_SCOPED_STYLE | SHADOW_MODE_SYNTHETIC = 3\nconst MAX_CACHE_KEY = 3;\n// Mapping of cacheKeys to `string[]` (assumed to come from a tagged template literal) to an Element.\n// Note that every unique tagged template literal will have a unique `string[]`. So by using `string[]`\n// as the WeakMap key, we effectively associate each Element with a unique tagged template literal.\n// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates\n// Also note that this array only needs to be large enough to account for the maximum possible cache key\nconst fragmentCache = ArrayFrom({ length: MAX_CACHE_KEY + 1 }, () => new WeakMap());\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    window.__lwcResetFragmentCache = () => {\n        for (let i = 0; i < fragmentCache.length; i++) {\n            fragmentCache[i] = new WeakMap();\n        }\n    };\n}\nfunction getFromFragmentCache(cacheKey, strings) {\n    return fragmentCache[cacheKey].get(strings);\n}\nfunction setInFragmentCache(cacheKey, strings, element) {\n    fragmentCache[cacheKey].set(strings, element);\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isUpdatingTemplate = false;\nlet vmBeingRendered = null;\nfunction getVMBeingRendered() {\n    return vmBeingRendered;\n}\nfunction setVMBeingRendered(vm) {\n    vmBeingRendered = vm;\n}\nconst VALID_SCOPE_TOKEN_REGEX = /^[a-zA-Z0-9\\-_]+$/;\n// See W-16614556\n// TODO [#2826]: freeze the template object\nfunction isValidScopeToken(token) {\n    return isString(token) && VALID_SCOPE_TOKEN_REGEX.test(token);\n}\nfunction validateSlots(vm) {\n    assertNotProd(); // this method should never leak to prod\n    const { cmpSlots } = vm;\n    for (const slotName in cmpSlots.slotAssignments) {\n        assert.isTrue(isArray$1(cmpSlots.slotAssignments[slotName]), `Slots can only be set to an array, instead received ${toString(cmpSlots.slotAssignments[slotName])} for slot \"${slotName}\" in ${vm}.`);\n    }\n}\nfunction checkHasMatchingRenderMode(template, vm) {\n    // don't validate in prod environments where reporting is disabled\n    if (process.env.NODE_ENV === 'production' && !isReportingEnabled()) {\n        return;\n    }\n    // don't validate the default empty template - it is not inherently light or shadow\n    if (template === defaultEmptyTemplate) {\n        return;\n    }\n    // TODO [#4663]: `renderMode` mismatch between template and component causes `console.error` but no error\n    // Note that `undefined` means shadow in this case, because shadow is the default.\n    const vmIsLight = vm.renderMode === 0 /* RenderMode.Light */;\n    const templateIsLight = template.renderMode === 'light';\n    if (vmIsLight !== templateIsLight) {\n        report(\"RenderModeMismatch\" /* ReportingEventId.RenderModeMismatch */, {\n            tagName: vm.tagName,\n            mode: vm.renderMode,\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            const tagName = getComponentTag(vm);\n            const message = vmIsLight\n                ? `Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode=\"light\"' directive to the root template tag of ${tagName}.`\n                : `Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ${tagName} or set it to 'lwc:render-mode=\"shadow\"`;\n            logError(message);\n        }\n    }\n}\nconst browserExpressionSerializer = (partToken, classAttrToken) => {\n    // This will insert the scoped style token as a static class attribute in the fragment\n    // bypassing the need to call applyStyleScoping when mounting static parts.\n    const type = StringCharAt.call(partToken, 0);\n    switch (type) {\n        case \"c\" /* STATIC_PART_TOKEN_ID.CLASS */:\n            return classAttrToken;\n        case \"t\" /* STATIC_PART_TOKEN_ID.TEXT */:\n            // Using a single space here gives us a single empty text node\n            return ' ';\n        default:\n            return '';\n    }\n};\n// This function serializes the expressions generated by static content optimization.\n// Currently this is only needed for SSR.\n// TODO [#4078]: Split the implementation between @lwc/engine-dom and @lwc/engine-server\nfunction buildSerializeExpressionFn(parts) {\n    {\n        return browserExpressionSerializer;\n    }\n}\nfunction buildParseFragmentFn(createFragmentFn) {\n    return function parseFragment(strings, ...keys) {\n        return function applyFragmentParts(parts) {\n            const { context: { hasScopedStyles, stylesheetToken, legacyStylesheetToken }, shadowMode, renderer, } = getVMBeingRendered();\n            const hasStyleToken = !isUndefined$1(stylesheetToken);\n            const isSyntheticShadow = shadowMode === 1 /* ShadowMode.Synthetic */;\n            const hasLegacyToken = lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS && !isUndefined$1(legacyStylesheetToken);\n            let cacheKey = 0;\n            if (hasStyleToken && hasScopedStyles) {\n                cacheKey |= 1 /* FragmentCacheKey.HAS_SCOPED_STYLE */;\n            }\n            if (hasStyleToken && isSyntheticShadow) {\n                cacheKey |= 2 /* FragmentCacheKey.SHADOW_MODE_SYNTHETIC */;\n            }\n            // Cache is only here to prevent calling innerHTML multiple times which doesn't happen on the server.\n            {\n                // Disable this on the server to prevent cache poisoning when expressions are used.\n                const cached = getFromFragmentCache(cacheKey, strings);\n                if (!isUndefined$1(cached)) {\n                    return cached;\n                }\n            }\n            // See W-16614556\n            if ((hasStyleToken && !isValidScopeToken(stylesheetToken)) ||\n                (hasLegacyToken && !isValidScopeToken(legacyStylesheetToken))) {\n                throw new Error('stylesheet token must be a valid string');\n            }\n            // If legacy stylesheet tokens are required, then add them to the rendered string\n            const stylesheetTokenToRender = stylesheetToken + (hasLegacyToken ? ` ${legacyStylesheetToken}` : '');\n            const classToken = hasScopedStyles && hasStyleToken ? ' ' + stylesheetTokenToRender : '';\n            const classAttrToken = hasScopedStyles && hasStyleToken ? ` class=\"${stylesheetTokenToRender}\"` : '';\n            const attrToken = hasStyleToken && isSyntheticShadow ? ' ' + stylesheetTokenToRender : '';\n            // In the browser, we provide the entire class attribute as a perf optimization to avoid applying it on mount.\n            // The remaining class expression will be applied when the static parts are mounted.\n            // In SSR, the entire class attribute (expression included) is assembled along with the fragment.\n            // This is why in the browser we provide the entire class attribute and in SSR we only provide the class token.\n            const exprClassToken = classAttrToken ;\n            // TODO [#3624]: The implementation of this function should be specific to @lwc/engine-dom and @lwc/engine-server.\n            // Find a way to split this in a future refactor.\n            const serializeExpression = buildSerializeExpressionFn();\n            let htmlFragment = '';\n            for (let i = 0, n = keys.length; i < n; i++) {\n                switch (keys[i]) {\n                    case 0: // styleToken in existing class attr\n                        htmlFragment += strings[i] + classToken;\n                        break;\n                    case 1: // styleToken for added class attr\n                        htmlFragment += strings[i] + classAttrToken;\n                        break;\n                    case 2: // styleToken as attr\n                        htmlFragment += strings[i] + attrToken;\n                        break;\n                    case 3: // ${1}${2}\n                        htmlFragment += strings[i] + classAttrToken + attrToken;\n                        break;\n                    default: // expressions ${partId:attributeName/textId}\n                        htmlFragment +=\n                            strings[i] + serializeExpression(keys[i], exprClassToken);\n                        break;\n                }\n            }\n            htmlFragment += strings[strings.length - 1];\n            const element = createFragmentFn(htmlFragment, renderer);\n            // Cache is only here to prevent calling innerHTML multiple times which doesn't happen on the server.\n            {\n                setInFragmentCache(cacheKey, strings, element);\n            }\n            return element;\n        };\n    };\n}\n// Note: at the moment this code executes, we don't have a renderer yet.\nconst parseFragment = buildParseFragmentFn((html, renderer) => {\n    const { createFragment } = renderer;\n    return createFragment(html);\n});\nconst parseSVGFragment = buildParseFragmentFn((html, renderer) => {\n    const { createFragment, getFirstChild } = renderer;\n    const fragment = createFragment('<svg>' + html + '</svg>');\n    return getFirstChild(fragment);\n});\nfunction evaluateTemplate(vm, html) {\n    if (process.env.NODE_ENV !== 'production') {\n        // in dev-mode, we support hot swapping of templates, which means that\n        // the component instance might be attempting to use an old version of\n        // the template, while internally, we have a replacement for it.\n        html = getTemplateOrSwappedTemplate(html);\n    }\n    const isUpdatingTemplateInception = isUpdatingTemplate;\n    const vmOfTemplateBeingUpdatedInception = vmBeingRendered;\n    let vnodes = [];\n    runWithBoundaryProtection(vm, vm.owner, () => {\n        // pre\n        vmBeingRendered = vm;\n        logOperationStart(1 /* OperationId.Render */, vm);\n    }, () => {\n        // job\n        const { component, context, cmpSlots, cmpTemplate, tro } = vm;\n        tro.observe(() => {\n            // Reset the cache memoizer for template when needed.\n            if (html !== cmpTemplate) {\n                // Check that the template was built by the compiler.\n                if (!isTemplateRegistered(html)) {\n                    throw new TypeError(`Invalid template returned by the render() method on ${vm.tagName}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString(html)}.`);\n                }\n                checkHasMatchingRenderMode(html, vm);\n                // Perf opt: do not reset the shadow root during the first rendering (there is\n                // nothing to reset).\n                if (!isNull(cmpTemplate)) {\n                    // It is important to reset the content to avoid reusing similar elements\n                    // generated from a different template, because they could have similar IDs,\n                    // and snabbdom just rely on the IDs.\n                    resetComponentRoot(vm);\n                }\n                vm.cmpTemplate = html;\n                // Create a brand new template cache for the swapped templated.\n                context.tplCache = create(null);\n                // Set the computeHasScopedStyles property in the context, to avoid recomputing it repeatedly.\n                context.hasScopedStyles = computeHasScopedStyles(html, vm);\n                // Update the scoping token on the host element.\n                updateStylesheetToken(vm, html, /* legacy */ false);\n                if (lwcRuntimeFlags.ENABLE_LEGACY_SCOPE_TOKENS) {\n                    updateStylesheetToken(vm, html, /* legacy */ true);\n                }\n                // Evaluate, create stylesheet and cache the produced VNode for future\n                // re-rendering.\n                const stylesheetsContent = getStylesheetsContent(vm, html);\n                context.styleVNodes =\n                    stylesheetsContent.length === 0\n                        ? null\n                        : createStylesheet(vm, stylesheetsContent);\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                // validating slots in every rendering since the allocated content might change over time\n                validateSlots(vm);\n                // add the VM to the list of host VMs that can be re-rendered if html is swapped\n                setActiveVM(vm);\n            }\n            // right before producing the vnodes, we clear up all internal references\n            // to custom elements from the template.\n            vm.velements = [];\n            // Set the global flag that template is being updated\n            isUpdatingTemplate = true;\n            vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);\n            const { styleVNodes } = context;\n            if (!isNull(styleVNodes)) {\n                // It's important here not to mutate the underlying `vnodes` returned from `html.call()`.\n                // The reason for this is because, due to the static content optimization, the vnodes array\n                // may be a static array shared across multiple component instances. E.g. this occurs in the\n                // case of an empty `<template></template>` in a `component.html` file, due to the underlying\n                // children being `[]` (no children). If we append the `<style>` vnode to this array, then the same\n                // array will be reused for every component instance, i.e. whenever `tmpl()` is called.\n                vnodes = [...styleVNodes, ...vnodes];\n            }\n        });\n    }, () => {\n        // post\n        isUpdatingTemplate = isUpdatingTemplateInception;\n        vmBeingRendered = vmOfTemplateBeingUpdatedInception;\n        logOperationEnd(1 /* OperationId.Render */, vm);\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isArray$1(vnodes)) {\n            logError(`Compiler should produce html functions that always return an array.`);\n        }\n    }\n    return vnodes;\n}\nfunction computeHasScopedStylesInStylesheets(stylesheets) {\n    if (hasStyles(stylesheets)) {\n        for (let i = 0; i < stylesheets.length; i++) {\n            if (isTrue(stylesheets[i][KEY__SCOPED_CSS])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction computeHasScopedStyles(template, vm) {\n    const { stylesheets } = template;\n    const vmStylesheets = !isUndefined$1(vm) ? vm.stylesheets : null;\n    return (computeHasScopedStylesInStylesheets(stylesheets) ||\n        computeHasScopedStylesInStylesheets(vmStylesheets));\n}\nfunction hasStyles(stylesheets) {\n    return !isUndefined$1(stylesheets) && !isNull(stylesheets) && stylesheets.length > 0;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isInvokingRender = false;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n    return vmBeingConstructed === vm;\n}\nfunction invokeComponentCallback(vm, fn, args) {\n    const { component, callHook, owner } = vm;\n    runWithBoundaryProtection(vm, owner, noop, () => {\n        callHook(component, fn, args);\n    }, noop);\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n    const vmBeingConstructedInception = vmBeingConstructed;\n    let error;\n    logOperationStart(0 /* OperationId.Constructor */, vm);\n    vmBeingConstructed = vm;\n    /**\n     * Constructors don't need to be wrapped with a boundary because for root elements\n     * it should throw, while elements from template are already wrapped by a boundary\n     * associated to the diffing algo.\n     */\n    try {\n        // job\n        const result = new Ctor();\n        // Check indirectly if the constructor result is an instance of LightningElement. Using\n        // the \"instanceof\" operator would not work here since Locker Service provides its own\n        // implementation of LightningElement, so we indirectly check if the base constructor is\n        // invoked by accessing the component on the vm.\n        // TODO [W-17769475]: Restore this fix when we can reliably detect Locker enabled\n        // const isInvalidConstructor = lwcRuntimeFlags.LEGACY_LOCKER_ENABLED\n        //     ? vmBeingConstructed.component !== result\n        //     : !(result instanceof LightningElement);\n        const isInvalidConstructor = vmBeingConstructed.component !== result;\n        if (isInvalidConstructor) {\n            throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n        }\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        logOperationEnd(0 /* OperationId.Constructor */, vm);\n        vmBeingConstructed = vmBeingConstructedInception;\n        if (!isUndefined$1(error)) {\n            addErrorComponentStack(vm, error);\n            // re-throwing the original error annotated after restoring the context\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n}\nfunction invokeComponentRenderMethod(vm) {\n    const { def: { render }, callHook, component, owner, } = vm;\n    const isRenderBeingInvokedInception = isInvokingRender;\n    const vmBeingRenderedInception = getVMBeingRendered();\n    let html;\n    let renderInvocationSuccessful = false;\n    runWithBoundaryProtection(vm, owner, () => {\n        // pre\n        isInvokingRender = true;\n        setVMBeingRendered(vm);\n    }, () => {\n        // job\n        vm.tro.observe(() => {\n            html = callHook(component, render);\n            renderInvocationSuccessful = true;\n        });\n    }, () => {\n        // post\n        isInvokingRender = isRenderBeingInvokedInception;\n        setVMBeingRendered(vmBeingRenderedInception);\n    });\n    // If render() invocation failed, process errorCallback in boundary and return an empty template\n    return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n    const { callHook, owner } = vm;\n    runWithBoundaryProtection(vm, owner, noop, () => {\n        // job\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isTrue(isFunction$1(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n        }\n        callHook(thisValue, fn, [event]);\n    }, noop);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst registeredComponentMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n * @param Ctor\n * @param metadata\n */\nfunction registerComponent(\n// We typically expect a LightningElementConstructor, but technically you can call this with anything\nCtor, metadata) {\n    if (isFunction$1(Ctor)) {\n        if (process.env.NODE_ENV !== 'production') {\n            // There is no point in running this in production, because the version mismatch check relies\n            // on code comments which are stripped out in production by minifiers\n            checkVersionMismatch(Ctor, 'component');\n        }\n        // TODO [#3331]: add validation to check the value of metadata.sel is not an empty string.\n        registeredComponentMap.set(Ctor, metadata);\n    }\n    // chaining this method as a way to wrap existing assignment of component constructor easily,\n    // without too much transformation\n    return Ctor;\n}\nfunction getComponentRegisteredTemplate(Ctor) {\n    return registeredComponentMap.get(Ctor)?.tmpl;\n}\nfunction getComponentRegisteredName(Ctor) {\n    return registeredComponentMap.get(Ctor)?.sel;\n}\nfunction getComponentAPIVersion(Ctor) {\n    const metadata = registeredComponentMap.get(Ctor);\n    const apiVersion = metadata?.apiVersion;\n    if (isUndefined$1(apiVersion)) {\n        // This should only occur in our Karma tests; in practice every component\n        // is registered, and so this code path should not get hit. But to be safe,\n        // return the lowest possible version.\n        return LOWEST_API_VERSION;\n    }\n    return apiVersion;\n}\nfunction getTemplateReactiveObserver(vm) {\n    const reactiveObserver = createReactiveObserver(() => {\n        const { isDirty } = vm;\n        if (isFalse(isDirty)) {\n            markComponentAsDirty(vm);\n            scheduleRehydration(vm);\n        }\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        associateReactiveObserverWithVM(reactiveObserver, vm);\n    }\n    return reactiveObserver;\n}\nfunction resetTemplateObserverAndUnsubscribe(vm) {\n    const { tro, component } = vm;\n    tro.reset();\n    // Unsubscribe every time the template reactive observer is reset.\n    if (lwcRuntimeFlags.ENABLE_EXPERIMENTAL_SIGNALS) {\n        unsubscribeFromSignals(component);\n    }\n}\nfunction renderComponent(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n    }\n    // The engine should only hold a subscription to a signal if it is rendered in the template.\n    // Because of the potential presence of conditional rendering logic, we unsubscribe on each render\n    // in the scenario where it is present in one condition but not the other.\n    // For example:\n    // 1. There is an lwc:if=true conditional where the signal is present on the template.\n    // 2. The lwc:if changes to false and the signal is no longer present on the template.\n    // If the signal is still subscribed to, the template will re-render when it receives a notification\n    // from the signal, even though we won't be using the new value.\n    resetTemplateObserverAndUnsubscribe(vm);\n    const vnodes = invokeComponentRenderMethod(vm);\n    vm.isDirty = false;\n    vm.isScheduled = false;\n    return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n        assert.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n        assert.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);\n    }\n    vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n    if (!isFunction$1(listener)) {\n        throw new TypeError('Expected an EventListener but received ' + typeof listener); // avoiding problems with non-valid listeners\n    }\n    let wrappedListener = cmpEventListenerMap.get(listener);\n    if (isUndefined$1(wrappedListener)) {\n        wrappedListener = function (event) {\n            invokeEventListener(vm, listener, undefined, event);\n        };\n        cmpEventListenerMap.set(listener, wrappedListener);\n    }\n    return wrappedListener;\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet idx = 0;\n/** The internal slot used to associate different objects the engine manipulates with the VM */\nconst ViewModelReflection = new WeakMap();\nfunction callHook(cmp, fn, args = []) {\n    return fn.apply(cmp, args);\n}\nfunction setHook(cmp, prop, newValue) {\n    cmp[prop] = newValue;\n}\nfunction getHook(cmp, prop) {\n    return cmp[prop];\n}\nfunction rerenderVM(vm) {\n    rehydrate(vm);\n}\nfunction connectRootElement(elm) {\n    const vm = getAssociatedVM(elm);\n    if (process.env.NODE_ENV !== 'production') {\n        // Flush any logs for this VM so that the initial properties from the constructor don't \"count\"\n        // in subsequent re-renders (lwc-rerender). Right now we're at the first render (lwc-hydrate).\n        flushMutationLogsForVM(vm);\n    }\n    logGlobalOperationStartWithVM(7 /* OperationId.GlobalRender */, vm);\n    // Usually means moving the element from one place to another, which is observable via\n    // life-cycle hooks.\n    if (vm.state === 1 /* VMState.connected */) {\n        disconnectRootElement(elm);\n    }\n    runConnectedCallback(vm);\n    rehydrate(vm);\n    logGlobalOperationEndWithVM(7 /* OperationId.GlobalRender */, vm);\n}\nfunction disconnectRootElement(elm) {\n    const vm = getAssociatedVM(elm);\n    resetComponentStateWhenRemoved(vm);\n}\nfunction appendVM(vm) {\n    rehydrate(vm);\n}\n// just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\nfunction resetComponentStateWhenRemoved(vm) {\n    const { state } = vm;\n    if (state !== 2 /* VMState.disconnected */) {\n        // Making sure that any observing record will not trigger the rehydrated on this vm\n        resetTemplateObserverAndUnsubscribe(vm);\n        runDisconnectedCallback(vm);\n        // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n        runChildNodesDisconnectedCallback(vm);\n        runLightChildNodesDisconnectedCallback(vm);\n    }\n}\n// this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\nfunction removeVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n            // With native lifecycle, we cannot be certain that connectedCallback was called before a component\n            // was removed from the VDOM. If the component is disconnected, then connectedCallback will not fire\n            // in native mode, although it will fire in synthetic mode due to appendChild triggering it.\n            // See: W-14037619 for details\n            assert.isTrue(vm.state === 1 /* VMState.connected */ || vm.state === 2 /* VMState.disconnected */, `${vm} must have been connected.`);\n        }\n    }\n    resetComponentStateWhenRemoved(vm);\n}\nfunction getNearestShadowAncestor(owner) {\n    let ancestor = owner;\n    while (!isNull(ancestor) && ancestor.renderMode === 0 /* RenderMode.Light */) {\n        ancestor = ancestor.owner;\n    }\n    return ancestor;\n}\nfunction createVM(elm, ctor, renderer, options) {\n    const { mode, owner, tagName, hydrated } = options;\n    const def = getComponentInternalDef(ctor);\n    const apiVersion = getComponentAPIVersion(ctor);\n    const vm = {\n        elm,\n        def,\n        idx: idx++,\n        state: 0 /* VMState.created */,\n        isScheduled: false,\n        isDirty: true,\n        tagName,\n        mode,\n        owner,\n        refVNodes: null,\n        children: EmptyArray,\n        aChildren: EmptyArray,\n        velements: EmptyArray,\n        cmpProps: create(null),\n        cmpFields: create(null),\n        cmpSlots: { slotAssignments: create(null) },\n        cmpTemplate: null,\n        hydrated: Boolean(hydrated),\n        renderMode: def.renderMode,\n        context: {\n            stylesheetToken: undefined,\n            hasTokenInClass: undefined,\n            hasTokenInAttribute: undefined,\n            legacyStylesheetToken: undefined,\n            hasLegacyTokenInClass: undefined,\n            hasLegacyTokenInAttribute: undefined,\n            hasScopedStyles: undefined,\n            styleVNodes: null,\n            tplCache: EmptyObject,\n            wiredConnecting: EmptyArray,\n            wiredDisconnecting: EmptyArray,\n        },\n        // Properties set right after VM creation.\n        tro: null,\n        shadowMode: null,\n        shadowMigrateMode: false,\n        stylesheets: null,\n        // Properties set by the LightningElement constructor.\n        component: null,\n        shadowRoot: null,\n        renderRoot: null,\n        callHook,\n        setHook,\n        getHook,\n        renderer,\n        apiVersion,\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        vm.debugInfo = create(null);\n    }\n    vm.stylesheets = computeStylesheets(vm, def.ctor);\n    const computedShadowMode = computeShadowMode(def, vm.owner, renderer, hydrated);\n    if (lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE) {\n        vm.shadowMode = 0 /* ShadowMode.Native */;\n        vm.shadowMigrateMode = computedShadowMode === 1 /* ShadowMode.Synthetic */;\n    }\n    else {\n        vm.shadowMode = computedShadowMode;\n    }\n    vm.tro = getTemplateReactiveObserver(vm);\n    // We don't need to report the shadow mode if we're rendering in light DOM\n    if (isReportingEnabled() && vm.renderMode === 1 /* RenderMode.Shadow */) {\n        report(\"ShadowModeUsage\" /* ReportingEventId.ShadowModeUsage */, {\n            tagName: vm.tagName,\n            mode: vm.shadowMode,\n        });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        vm.toString = () => {\n            return `[object:vm ${def.name} (${vm.idx})]`;\n        };\n    }\n    // Create component instance associated to the vm and the element.\n    invokeComponentConstructor(vm, def.ctor);\n    // Initializing the wire decorator per instance only when really needed\n    if (hasWireAdapters(vm)) {\n        installWireAdapters(vm);\n    }\n    return vm;\n}\nfunction validateComponentStylesheets(vm, stylesheets) {\n    let valid = true;\n    const validate = (arrayOrStylesheet) => {\n        if (isArray$1(arrayOrStylesheet)) {\n            for (let i = 0; i < arrayOrStylesheet.length; i++) {\n                validate(arrayOrStylesheet[i]);\n            }\n        }\n        else if (!isFunction$1(arrayOrStylesheet)) {\n            // function assumed to be a stylesheet factory\n            valid = false;\n        }\n    };\n    if (!isArray$1(stylesheets)) {\n        valid = false;\n    }\n    else {\n        validate(stylesheets);\n    }\n    return valid;\n}\n// Validate and flatten any stylesheets defined as `static stylesheets`\nfunction computeStylesheets(vm, ctor) {\n    warnOnStylesheetsMutation(ctor);\n    const { stylesheets } = ctor;\n    if (!isUndefined$1(stylesheets)) {\n        const valid = validateComponentStylesheets(vm, stylesheets);\n        if (valid) {\n            return flattenStylesheets(stylesheets);\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            logError(`static stylesheets must be an array of CSS stylesheets. Found invalid stylesheets on <${vm.tagName}>`, vm);\n        }\n    }\n    return null;\n}\nfunction warnOnStylesheetsMutation(ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        let { stylesheets } = ctor;\n        defineProperty(ctor, 'stylesheets', {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return stylesheets;\n            },\n            set(newValue) {\n                logWarnOnce(`Dynamically setting the \"stylesheets\" static property on ${ctor.name} ` +\n                    'will not affect the stylesheets injected.');\n                stylesheets = newValue;\n            },\n        });\n    }\n}\n// Compute the shadowMode/renderMode without creating a VM. This is used in some scenarios like hydration.\nfunction computeShadowAndRenderMode(Ctor, renderer) {\n    const def = getComponentInternalDef(Ctor);\n    const { renderMode } = def;\n    // Assume null `owner` - this is what happens in hydration cases anyway\n    // Also assume we are not in hydration mode for this exported API\n    const shadowMode = computeShadowMode(def, /* owner */ null, renderer, false);\n    return { renderMode, shadowMode };\n}\nfunction computeShadowMode(def, owner, renderer, hydrated) {\n    if (\n    // Force the shadow mode to always be native. Used for running tests with synthetic shadow patches\n    // on, but components running in actual native shadow mode\n    (process.env.NODE_ENV === 'test-karma-lwc' &&\n        process.env.FORCE_NATIVE_SHADOW_MODE_FOR_TEST) ||\n        // If synthetic shadow is explicitly disabled, use pure-native\n        lwcRuntimeFlags.DISABLE_SYNTHETIC_SHADOW ||\n        // hydration only supports native shadow\n        isTrue(hydrated)) {\n        return 0 /* ShadowMode.Native */;\n    }\n    const { isSyntheticShadowDefined } = renderer;\n    let shadowMode;\n    if (isSyntheticShadowDefined || lwcRuntimeFlags.ENABLE_FORCE_SHADOW_MIGRATE_MODE) {\n        if (def.renderMode === 0 /* RenderMode.Light */) {\n            // ShadowMode.Native implies \"not synthetic shadow\" which is consistent with how\n            // everything defaults to native when the synthetic shadow polyfill is unavailable.\n            shadowMode = 0 /* ShadowMode.Native */;\n        }\n        else if (def.shadowSupportMode === 'native') {\n            shadowMode = 0 /* ShadowMode.Native */;\n        }\n        else {\n            const shadowAncestor = getNearestShadowAncestor(owner);\n            if (!isNull(shadowAncestor) && shadowAncestor.shadowMode === 0 /* ShadowMode.Native */) {\n                // Transitive support for native Shadow DOM. A component in native mode\n                // transitively opts all of its descendants into native.\n                shadowMode = 0 /* ShadowMode.Native */;\n            }\n            else {\n                // Synthetic if neither this component nor any of its ancestors are configured\n                // to be native.\n                shadowMode = 1 /* ShadowMode.Synthetic */;\n            }\n        }\n    }\n    else {\n        // Native if the synthetic shadow polyfill is unavailable.\n        shadowMode = 0 /* ShadowMode.Native */;\n    }\n    return shadowMode;\n}\nfunction assertIsVM(obj) {\n    if (!isObject(obj) || isNull(obj) || !('renderRoot' in obj)) {\n        throw new TypeError(`${obj} is not a VM.`);\n    }\n}\nfunction associateVM(obj, vm) {\n    ViewModelReflection.set(obj, vm);\n}\nfunction getAssociatedVM(obj) {\n    const vm = ViewModelReflection.get(obj);\n    if (process.env.NODE_ENV !== 'production') {\n        assertIsVM(vm);\n    }\n    return vm;\n}\nfunction getAssociatedVMIfPresent(obj) {\n    const maybeVm = ViewModelReflection.get(obj);\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isUndefined$1(maybeVm)) {\n            assertIsVM(maybeVm);\n        }\n    }\n    return maybeVm;\n}\nfunction rehydrate(vm) {\n    if (isTrue(vm.isDirty)) {\n        const children = renderComponent(vm);\n        patchShadowRoot(vm, children);\n    }\n}\nfunction patchShadowRoot(vm, newCh) {\n    const { renderRoot, children: oldCh, renderer } = vm;\n    // reset the refs; they will be set during `patchChildren`\n    resetRefVNodes(vm);\n    // caching the new children collection\n    vm.children = newCh;\n    if (newCh.length > 0 || oldCh.length > 0) {\n        // patch function mutates vnodes by adding the element reference,\n        // however, if patching fails it contains partial changes.\n        if (oldCh !== newCh) {\n            runWithBoundaryProtection(vm, vm, () => {\n                // pre\n                logOperationStart(2 /* OperationId.Patch */, vm);\n            }, () => {\n                // job\n                patchChildren(oldCh, newCh, renderRoot, renderer);\n            }, () => {\n                // post\n                logOperationEnd(2 /* OperationId.Patch */, vm);\n            });\n        }\n    }\n    if (vm.state === 1 /* VMState.connected */) {\n        // If the element is connected, that means connectedCallback was already issued, and\n        // any successive rendering should finish with the call to renderedCallback, otherwise\n        // the connectedCallback will take care of calling it in the right order at the end of\n        // the current rehydration process.\n        runRenderedCallback(vm);\n    }\n}\nfunction runRenderedCallback(vm) {\n    const { def: { renderedCallback }, } = vm;\n    if (!isUndefined$1(renderedCallback)) {\n        logOperationStart(4 /* OperationId.RenderedCallback */, vm);\n        invokeComponentCallback(vm, renderedCallback);\n        logOperationEnd(4 /* OperationId.RenderedCallback */, vm);\n    }\n}\nlet rehydrateQueue = [];\nfunction flushRehydrationQueue() {\n    // Gather the logs before rehydration starts so they can be reported at the end of rehydration.\n    // Note that we also clear all existing logs at this point so that subsequent re-renders start from a clean slate.\n    const mutationLogs = process.env.NODE_ENV === 'production' ? undefined : getAndFlushMutationLogs();\n    logGlobalOperationStart(8 /* OperationId.GlobalRerender */);\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n    }\n    const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n    rehydrateQueue = []; // reset to a new queue\n    for (let i = 0, len = vms.length; i < len; i += 1) {\n        const vm = vms[i];\n        try {\n            rehydrate(vm);\n        }\n        catch (error) {\n            if (i + 1 < len) {\n                // pieces of the queue are still pending to be rehydrated, those should have priority\n                if (rehydrateQueue.length === 0) {\n                    addCallbackToNextTick(flushRehydrationQueue);\n                }\n                ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, i + 1));\n            }\n            // we need to end the measure before throwing.\n            logGlobalOperationEnd(8 /* OperationId.GlobalRerender */, mutationLogs);\n            // re-throwing the original error will break the current tick, but since the next tick is\n            // already scheduled, it should continue patching the rest.\n            throw error;\n        }\n    }\n    logGlobalOperationEnd(8 /* OperationId.GlobalRerender */, mutationLogs);\n}\nfunction runConnectedCallback(vm) {\n    const { state } = vm;\n    if (state === 1 /* VMState.connected */) {\n        return; // nothing to do since it was already connected\n    }\n    vm.state = 1 /* VMState.connected */;\n    if (hasWireAdapters(vm)) {\n        connectWireAdapters(vm);\n    }\n    const { connectedCallback } = vm.def;\n    if (!isUndefined$1(connectedCallback)) {\n        logOperationStart(3 /* OperationId.ConnectedCallback */, vm);\n        invokeComponentCallback(vm, connectedCallback);\n        logOperationEnd(3 /* OperationId.ConnectedCallback */, vm);\n    }\n    // This test only makes sense in the browser, with synthetic lifecycle, and when reporting is enabled or\n    // we're in dev mode. This is to detect a particular issue with synthetic lifecycle.\n    if (lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE &&\n        (process.env.NODE_ENV !== 'production' || isReportingEnabled())) {\n        if (!vm.renderer.isConnected(vm.elm)) {\n            if (process.env.NODE_ENV !== 'production') {\n                logWarnOnce(`Element <${vm.tagName}> ` +\n                    `fired a \\`connectedCallback\\` and rendered, but was not connected to the DOM. ` +\n                    `Please ensure all components are actually connected to the DOM, e.g. using ` +\n                    `\\`document.body.appendChild(element)\\`. This will not be supported in future versions of ` +\n                    `LWC and could cause component errors. For details, see: https://sfdc.co/synthetic-lifecycle`);\n            }\n            report(\"ConnectedCallbackWhileDisconnected\" /* ReportingEventId.ConnectedCallbackWhileDisconnected */, {\n                tagName: vm.tagName,\n            });\n        }\n    }\n}\nfunction hasWireAdapters(vm) {\n    return getOwnPropertyNames$1(vm.def.wire).length > 0;\n}\nfunction runDisconnectedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(vm.state !== 2 /* VMState.disconnected */, `${vm} must be inserted.`);\n    }\n    if (isFalse(vm.isDirty)) {\n        // this guarantees that if the component is reused/reinserted,\n        // it will be re-rendered because we are disconnecting the reactivity\n        // linking, so mutations are not automatically reflected on the state\n        // of disconnected components.\n        vm.isDirty = true;\n    }\n    vm.state = 2 /* VMState.disconnected */;\n    if (hasWireAdapters(vm)) {\n        disconnectWireAdapters(vm);\n    }\n    const { disconnectedCallback } = vm.def;\n    if (!isUndefined$1(disconnectedCallback)) {\n        logOperationStart(5 /* OperationId.DisconnectedCallback */, vm);\n        invokeComponentCallback(vm, disconnectedCallback);\n        logOperationEnd(5 /* OperationId.DisconnectedCallback */, vm);\n    }\n}\nfunction runChildNodesDisconnectedCallback(vm) {\n    const { velements: vCustomElementCollection } = vm;\n    // Reporting disconnection for every child in inverse order since they are\n    // inserted in reserved order.\n    for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n        const { elm } = vCustomElementCollection[i];\n        // There are two cases where the element could be undefined:\n        // * when there is an error during the construction phase, and an error\n        //   boundary picks it, there is a possibility that the VCustomElement\n        //   is not properly initialized, and therefore is should be ignored.\n        // * when slotted custom element is not used by the element where it is\n        //   slotted into it, as  a result, the custom element was never\n        //   initialized.\n        if (!isUndefined$1(elm)) {\n            const childVM = getAssociatedVMIfPresent(elm);\n            // The VM associated with the element might be associated undefined\n            // in the case where the VM failed in the middle of its creation,\n            // eg: constructor throwing before invoking super().\n            if (!isUndefined$1(childVM)) {\n                resetComponentStateWhenRemoved(childVM);\n            }\n        }\n    }\n}\nfunction runLightChildNodesDisconnectedCallback(vm) {\n    const { aChildren: adoptedChildren } = vm;\n    recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n * @param vnodes\n */\nfunction recursivelyDisconnectChildren(vnodes) {\n    for (let i = 0, len = vnodes.length; i < len; i += 1) {\n        const vnode = vnodes[i];\n        if (!isNull(vnode) && !isUndefined$1(vnode.elm)) {\n            switch (vnode.type) {\n                case 2 /* VNodeType.Element */:\n                    recursivelyDisconnectChildren(vnode.children);\n                    break;\n                case 3 /* VNodeType.CustomElement */: {\n                    const vm = getAssociatedVM(vnode.elm);\n                    resetComponentStateWhenRemoved(vm);\n                    break;\n                }\n            }\n        }\n    }\n}\n// This is a super optimized mechanism to remove the content of the root node (shadow root\n// for shadow DOM components and the root element itself for light DOM) without having to go\n// into snabbdom. Especially useful when the reset is a consequence of an error, in which case the\n// children VNodes might not be representing the current state of the DOM.\nfunction resetComponentRoot(vm) {\n    recursivelyRemoveChildren(vm.children, vm);\n    vm.children = EmptyArray;\n    runChildNodesDisconnectedCallback(vm);\n    vm.velements = EmptyArray;\n}\n// Helper function to remove all children of the root node.\n// If the set of children includes VFragment nodes, we need to remove the children of those nodes too.\n// Since VFragments can contain other VFragments, we need to traverse the entire of tree of VFragments.\n// If the set contains no VFragment nodes, no traversal is needed.\nfunction recursivelyRemoveChildren(vnodes, vm) {\n    const { renderRoot, renderer: { remove }, } = vm;\n    for (let i = 0, len = vnodes.length; i < len; i += 1) {\n        const vnode = vnodes[i];\n        if (!isNull(vnode)) {\n            // VFragments are special; their .elm property does not point to the root element since they have no single root.\n            if (isVFragment(vnode)) {\n                recursivelyRemoveChildren(vnode.children, vm);\n            }\n            else if (!isUndefined$1(vnode.elm)) {\n                remove(vnode.elm, renderRoot);\n            }\n        }\n    }\n}\nfunction scheduleRehydration(vm) {\n    if (isTrue(vm.isScheduled)) {\n        return;\n    }\n    vm.isScheduled = true;\n    if (rehydrateQueue.length === 0) {\n        addCallbackToNextTick(flushRehydrationQueue);\n    }\n    ArrayPush$1.call(rehydrateQueue, vm);\n}\nfunction getErrorBoundaryVM(vm) {\n    let currentVm = vm;\n    while (!isNull(currentVm)) {\n        if (!isUndefined$1(currentVm.def.errorCallback)) {\n            return currentVm;\n        }\n        currentVm = currentVm.owner;\n    }\n}\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n    let error;\n    pre();\n    try {\n        job();\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        post();\n        if (!isUndefined$1(error)) {\n            addErrorComponentStack(vm, error);\n            const errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);\n            // Error boundaries are not in effect when server-side rendering. `errorCallback`\n            // is intended to allow recovery from errors - changing the state of a component\n            // and instigating a re-render. That is at odds with the single-pass, synchronous\n            // nature of SSR. For that reason, all errors bubble up to the `renderComponent`\n            // call site.\n            if (isUndefined$1(errorBoundaryVm)) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n            resetComponentRoot(vm); // remove offenders\n            logOperationStart(6 /* OperationId.ErrorCallback */, vm);\n            // error boundaries must have an ErrorCallback\n            const errorCallback = errorBoundaryVm.def.errorCallback;\n            invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n            logOperationEnd(6 /* OperationId.ErrorCallback */, vm);\n        }\n    }\n}\nfunction forceRehydration(vm) {\n    // if we must reset the shadowRoot content and render the template\n    // from scratch on an active instance, the way to force the reset\n    // is by replacing the value of old template, which is used during\n    // to determine if the template has changed or not during the rendering\n    // process. If the template returned by render() is different from the\n    // previous stored template, the styles will be reset, along with the\n    // content of the shadowRoot, this way we can guarantee that all children\n    // elements will be throw away, and new instances will be created.\n    vm.cmpTemplate = () => [];\n    if (isFalse(vm.isDirty)) {\n        // forcing the vm to rehydrate in the next tick\n        markComponentAsDirty(vm);\n        scheduleRehydration(vm);\n    }\n}\nfunction runFormAssociatedCustomElementCallback(vm, faceCb, args) {\n    const { renderMode, shadowMode } = vm;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ && renderMode !== 0 /* RenderMode.Light */) {\n        throw new Error('Form associated lifecycle methods are not available in synthetic shadow. Please use native shadow or light DOM.');\n    }\n    invokeComponentCallback(vm, faceCb, args);\n}\nfunction runFormAssociatedCallback(elm, form) {\n    const vm = getAssociatedVM(elm);\n    const { formAssociatedCallback } = vm.def;\n    if (!isUndefined$1(formAssociatedCallback)) {\n        runFormAssociatedCustomElementCallback(vm, formAssociatedCallback, [form]);\n    }\n}\nfunction runFormDisabledCallback(elm, disabled) {\n    const vm = getAssociatedVM(elm);\n    const { formDisabledCallback } = vm.def;\n    if (!isUndefined$1(formDisabledCallback)) {\n        runFormAssociatedCustomElementCallback(vm, formDisabledCallback, [disabled]);\n    }\n}\nfunction runFormResetCallback(elm) {\n    const vm = getAssociatedVM(elm);\n    const { formResetCallback } = vm.def;\n    if (!isUndefined$1(formResetCallback)) {\n        runFormAssociatedCustomElementCallback(vm, formResetCallback);\n    }\n}\nfunction runFormStateRestoreCallback(elm, state, reason) {\n    const vm = getAssociatedVM(elm);\n    const { formStateRestoreCallback } = vm.def;\n    if (!isUndefined$1(formStateRestoreCallback)) {\n        runFormAssociatedCustomElementCallback(vm, formStateRestoreCallback, [state, reason]);\n    }\n}\nfunction resetRefVNodes(vm) {\n    const { cmpTemplate } = vm;\n    vm.refVNodes = !isNull(cmpTemplate) && cmpTemplate.hasRefs ? create(null) : null;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// The goal of this code is to detect invalid cross-root ARIA references in synthetic shadow DOM.\n// These invalid references should be fixed before the offending components can be migrated to native shadow DOM.\n// When invalid usage is detected, we warn in dev mode and call the reporting API if enabled.\n// See: https://sfdc.co/synthetic-aria\n//\n// Use the unpatched native getElementById/querySelectorAll rather than the synthetic one\nconst getElementById = globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];\nconst querySelectorAll = globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];\n// This is a \"handoff\" from synthetic-shadow to engine-core â€“ we want to clean up after ourselves\n// so nobody else can misuse these global APIs.\ndelete globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];\ndelete globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];\nfunction isSyntheticShadowRootInstance(rootNode) {\n    return rootNode !== document && isTrue(rootNode.synthetic);\n}\nfunction reportViolation$1(source, target, attrName) {\n    // The vm is either for the source, the target, or both. Either one or both must be using synthetic\n    // shadow for a violation to be detected.\n    let vm = getAssociatedVMIfPresent(source.getRootNode().host);\n    if (isUndefined$1(vm)) {\n        vm = getAssociatedVMIfPresent(target.getRootNode().host);\n    }\n    if (isUndefined$1(vm)) {\n        // vm should never be undefined here, but just to be safe, bail out and don't report\n        return;\n    }\n    report(\"CrossRootAriaInSyntheticShadow\" /* ReportingEventId.CrossRootAriaInSyntheticShadow */, {\n        tagName: vm.tagName,\n        attributeName: attrName,\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        // Avoid excessively logging to the console in the case of duplicates.\n        logWarnOnce(`Element <${source.tagName.toLowerCase()}> uses attribute \"${attrName}\" to reference element ` +\n            `<${target.tagName.toLowerCase()}>, which is not in the same shadow root. This will break in native shadow DOM. ` +\n            `For details, see: https://sfdc.co/synthetic-aria`, vm);\n    }\n}\nfunction parseIdRefAttributeValue(attrValue) {\n    // split on whitespace and skip empty strings after splitting\n    return isString(attrValue) ? ArrayFilter.call(StringSplit.call(attrValue, /\\s+/), Boolean) : [];\n}\nfunction detectSyntheticCrossRootAria(elm, attrName, attrValue) {\n    const root = elm.getRootNode();\n    if (!isSyntheticShadowRootInstance(root)) {\n        return;\n    }\n    if (attrName === 'id') {\n        // elm is the target, find the source\n        if (!isString(attrValue) || attrValue.length === 0) {\n            // if our id is null or empty, nobody can reference us\n            return;\n        }\n        for (const idRefAttrName of ID_REFERENCING_ATTRIBUTES_SET) {\n            // Query all global elements with this attribute. The attribute selector syntax `~=` is for values\n            // that reference multiple IDs, separated by whitespace.\n            const query = `[${idRefAttrName}~=\"${CSS.escape(attrValue)}\"]`;\n            const sourceElements = querySelectorAll.call(document, query);\n            for (let i = 0; i < sourceElements.length; i++) {\n                const sourceElement = sourceElements[i];\n                const sourceRoot = sourceElement.getRootNode();\n                if (sourceRoot !== root) {\n                    reportViolation$1(sourceElement, elm, idRefAttrName);\n                    break;\n                }\n            }\n        }\n    }\n    else {\n        // elm is the source, find the target\n        const ids = parseIdRefAttributeValue(attrValue);\n        for (const id of ids) {\n            const target = getElementById.call(document, id);\n            if (!isNull(target)) {\n                const targetRoot = target.getRootNode();\n                if (targetRoot !== root) {\n                    // target element's shadow root is not the same as ours\n                    reportViolation$1(elm, target, attrName);\n                }\n            }\n        }\n    }\n}\nlet enabled = false;\n// We want to avoid patching globals whenever possible, so this should be tree-shaken out in prod-mode and if\n// reporting is not enabled. It should also only run once\nfunction enableDetection$1() {\n    if (enabled) {\n        return; // don't double-apply the patches\n    }\n    enabled = true;\n    const { setAttribute } = Element.prototype;\n    // Detect calling `setAttribute` to set an idref or an id\n    assign(Element.prototype, {\n        setAttribute(attrName, attrValue) {\n            setAttribute.call(this, attrName, attrValue);\n            if (attrName === 'id' || ID_REFERENCING_ATTRIBUTES_SET.has(attrName)) {\n                detectSyntheticCrossRootAria(this, attrName, attrValue);\n            }\n        },\n    });\n    // Detect `elm.id = 'foo'`\n    const idDescriptor = getOwnPropertyDescriptor$1(Element.prototype, 'id');\n    if (!isUndefined$1(idDescriptor)) {\n        const { get, set } = idDescriptor;\n        // These should always be a getter and a setter, but if someone is monkeying with the global descriptor, ignore it\n        if (isFunction$1(get) && isFunction$1(set)) {\n            defineProperty(Element.prototype, 'id', {\n                get() {\n                    return get.call(this);\n                },\n                set(value) {\n                    set.call(this, value);\n                    detectSyntheticCrossRootAria(this, 'id', value);\n                },\n                // On the default descriptor for 'id', enumerable and configurable are true\n                enumerable: true,\n                configurable: true,\n            });\n        }\n    }\n}\n// Our detection logic relies on some modern browser features. We can just skip reporting the data\n// for unsupported browsers\nfunction supportsCssEscape() {\n    return typeof CSS !== 'undefined' && isFunction$1(CSS.escape);\n}\n// If this page is not using synthetic shadow, then we don't need to install detection. Note\n// that we are assuming synthetic shadow is loaded before LWC.\nfunction isSyntheticShadowLoaded() {\n    // We should probably be calling `renderer.isSyntheticShadowDefined`, but 1) we don't have access to the renderer,\n    // and 2) this code needs to run in @lwc/engine-core, so it can access `logWarn()` and `report()`.\n    return hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN);\n}\n// Detecting cross-root ARIA in synthetic shadow only makes sense for the browser\nif (supportsCssEscape() && isSyntheticShadowLoaded()) {\n    // Always run detection in dev mode, so we can at least print to the console\n    if (process.env.NODE_ENV !== 'production') {\n        enableDetection$1();\n    }\n    else {\n        // In prod mode, only enable detection if reporting is enabled\n        onReportingEnabled(enableDetection$1);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// The goal of this code is to detect usages of non-standard reflected ARIA properties. These are caused by\n// legacy non-standard Element.prototype extensions added by the @lwc/aria-reflection package.\n//\n// See the README for @lwc/aria-reflection\nconst NON_STANDARD_ARIA_PROPS = [\n    'ariaActiveDescendant',\n    'ariaControls',\n    'ariaDescribedBy',\n    'ariaDetails',\n    'ariaErrorMessage',\n    'ariaFlowTo',\n    'ariaLabelledBy',\n    'ariaOwns',\n];\nfunction isGlobalAriaPolyfillLoaded() {\n    // Sniff for the legacy polyfill being loaded. The reason this works is because ariaActiveDescendant is a\n    // non-standard ARIA property reflection that is only supported in our legacy polyfill. See\n    // @lwc/aria-reflection/README.md for details.\n    return !isUndefined$1(getOwnPropertyDescriptor$1(Element.prototype, 'ariaActiveDescendant'));\n}\nfunction findVM(elm) {\n    // If it's a shadow DOM component, then it has a host\n    const { host } = elm.getRootNode();\n    const vm = isUndefined$1(host) ? undefined : getAssociatedVMIfPresent(host);\n    if (!isUndefined$1(vm)) {\n        return vm;\n    }\n    // Else it might be a light DOM component. Walk up the tree trying to find the owner\n    let parentElement = elm;\n    while (!isNull((parentElement = parentElement.parentElement))) {\n        if (parentElement instanceof BaseBridgeElement) {\n            // parentElement is an LWC component\n            const vm = getAssociatedVMIfPresent(parentElement);\n            if (!isUndefined$1(vm)) {\n                return vm;\n            }\n        }\n    }\n    // If we return undefined, it's because the element was rendered wholly outside a LightningElement\n}\nfunction checkAndReportViolation(elm, prop, isSetter, setValue) {\n    const vm = findVM(elm);\n    if (process.env.NODE_ENV !== 'production') {\n        logWarnOnce(`Element <${elm.tagName.toLowerCase()}> ` +\n            (isUndefined$1(vm) ? '' : `owned by <${vm.elm.tagName.toLowerCase()}> `) +\n            `uses non-standard property \"${prop}\". This will be removed in a future version of LWC. ` +\n            `See https://sfdc.co/deprecated-aria`);\n    }\n    let setValueType;\n    if (isSetter) {\n        // `typeof null` is \"object\" which is not very useful for detecting null.\n        // We mostly want to know null vs undefined vs other types here, due to\n        // https://github.com/salesforce/lwc/issues/3284\n        setValueType = isNull(setValue) ? 'null' : typeof setValue;\n    }\n    report(\"NonStandardAriaReflection\" /* ReportingEventId.NonStandardAriaReflection */, {\n        tagName: vm?.tagName,\n        propertyName: prop,\n        isSetter,\n        setValueType,\n    });\n}\nfunction enableDetection() {\n    const { prototype } = Element;\n    for (const prop of NON_STANDARD_ARIA_PROPS) {\n        const descriptor = getOwnPropertyDescriptor$1(prototype, prop);\n        // The descriptor should exist because the @lwc/aria-reflection polyfill has run by now.\n        // This happens automatically because of the ordering of imports.\n        if (process.env.NODE_ENV !== 'production') {\n            /* istanbul ignore if */\n            if (isUndefined$1(descriptor) ||\n                isUndefined$1(descriptor.get) ||\n                isUndefined$1(descriptor.set)) {\n                // should never happen\n                throw new Error('detect-non-standard-aria.ts loaded before @lwc/aria-reflection');\n            }\n        }\n        const { get, set } = descriptor;\n        // It's important for this defineProperty call to happen _after_ ARIA accessors are applied to the\n        // BaseBridgeElement and LightningElement prototypes. Otherwise, we will log/report for access of non-standard\n        // props on these prototypes, which we actually don't want. We only care about access on generic HTMLElements.\n        defineProperty(prototype, prop, {\n            get() {\n                checkAndReportViolation(this, prop, false, undefined);\n                return get.call(this);\n            },\n            set(val) {\n                checkAndReportViolation(this, prop, true, val);\n                return set.call(this, val);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    }\n}\n// No point in running this code if we're not in a browser, or if the global polyfill is not loaded\nif (isGlobalAriaPolyfillLoaded()) {\n    // Always run detection in dev mode, so we can at least print to the console\n    if (process.env.NODE_ENV !== 'production') {\n        enableDetection();\n    }\n    else {\n        // In prod mode, only enable detection if reporting is enabled\n        onReportingEnabled(enableDetection);\n    }\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Errors that occured during the hydration process\nlet hydrationErrors = [];\n/*\n    Prints attributes as null or \"value\"\n*/\nfunction prettyPrintAttribute(attribute, value) {\n    assertNotProd(); // this method should never leak to prod\n    return `${attribute}=${isNull(value) || isUndefined$1(value) ? value : `\"${value}\"`}`;\n}\n/*\n    Sorts and stringifies classes\n*/\nfunction prettyPrintClasses(classes) {\n    assertNotProd(); // this method should never leak to prod\n    const value = JSON.stringify(ArrayJoin.call(ArraySort.call(ArrayFrom(classes)), ' '));\n    return `class=${value}`;\n}\n/*\n    Hydration errors occur before the source node has been fully hydrated,\n    queue them so they can be logged later against the mounted node.\n*/\nfunction queueHydrationError(type, serverRendered, clientExpected) {\n    assertNotProd(); // this method should never leak to prod\n    ArrayPush$1.call(hydrationErrors, { type, serverRendered, clientExpected });\n}\n/*\n    Flushes (logs) any queued errors after the source node has been mounted.\n */\nfunction flushHydrationErrors(source) {\n    assertNotProd(); // this method should never leak to prod\n    for (const hydrationError of hydrationErrors) {\n        logHydrationWarning(`Hydration ${hydrationError.type} mismatch on:`, source, `\\n- rendered on server:`, hydrationError.serverRendered, `\\n- expected on client:`, hydrationError.clientExpected || source);\n    }\n    hydrationErrors = [];\n}\nfunction isTypeElement(node) {\n    const isCorrectType = node?.nodeType === 1 /* EnvNodeTypes.ELEMENT */;\n    if (process.env.NODE_ENV !== 'production' && !isCorrectType) {\n        queueHydrationError('node', node);\n    }\n    return isCorrectType;\n}\nfunction isTypeText(node) {\n    const isCorrectType = node?.nodeType === 3 /* EnvNodeTypes.TEXT */;\n    if (process.env.NODE_ENV !== 'production' && !isCorrectType) {\n        queueHydrationError('node', node);\n    }\n    return isCorrectType;\n}\nfunction isTypeComment(node) {\n    const isCorrectType = node?.nodeType === 8 /* EnvNodeTypes.COMMENT */;\n    if (process.env.NODE_ENV !== 'production' && !isCorrectType) {\n        queueHydrationError('node', node);\n    }\n    return isCorrectType;\n}\n/*\n    logger.ts converts all args to a string, losing object referenences and has\n    legacy bloat which would have meant more pathing.\n*/\nfunction logHydrationWarning(...args) {\n    assertNotProd(); // this method should never leak to prod\n    /* eslint-disable-next-line no-console */\n    console.warn('[LWC warn:', ...args);\n}\n\n/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Used as a perf optimization to avoid creating and discarding sets unnecessarily.\nconst EMPTY_SET = new Set();\n// flag indicating if the hydration recovered from the DOM mismatch\nlet hasMismatch = false;\nfunction hydrateRoot(vm) {\n    hasMismatch = false;\n    logGlobalOperationStartWithVM(9 /* OperationId.GlobalSsrHydrate */, vm);\n    runConnectedCallback(vm);\n    hydrateVM(vm);\n    if (process.env.NODE_ENV !== 'production') {\n        /*\n            Errors are queued as they occur and then logged with the source element once it has been hydrated and mounted to the DOM.\n            Means the element in the console matches what is on the page and the highlighting works properly when you hover over the elements in the console.\n        */\n        flushHydrationErrors(vm.renderRoot);\n        if (hasMismatch) {\n            logHydrationWarning('Hydration completed with errors.');\n        }\n    }\n    logGlobalOperationEndWithVM(9 /* OperationId.GlobalSsrHydrate */, vm);\n}\nfunction hydrateVM(vm) {\n    const children = renderComponent(vm);\n    vm.children = children;\n    // reset the refs; they will be set during `hydrateChildren`\n    resetRefVNodes(vm);\n    const { renderRoot: parentNode, renderer: { getFirstChild }, } = vm;\n    logOperationStart(2 /* OperationId.Patch */, vm);\n    hydrateChildren(getFirstChild(parentNode), children, parentNode, vm, false);\n    logOperationEnd(2 /* OperationId.Patch */, vm);\n    runRenderedCallback(vm);\n}\nfunction hydrateNode(node, vnode, renderer) {\n    let hydratedNode;\n    switch (vnode.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            hydratedNode = hydrateText(node, vnode, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            hydratedNode = hydrateComment(node, vnode, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            // VStatic are cacheable and cannot have custom renderer associated to them\n            hydratedNode = hydrateStaticElement(node, vnode, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            // a fragment does not represent any element, therefore there is no need to use a custom renderer.\n            hydratedNode = hydrateFragment(node, vnode, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            hydratedNode = hydrateElement(node, vnode, vnode.data.renderer ?? renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            hydratedNode = hydrateCustomElement(node, vnode, vnode.data.renderer ?? renderer);\n            break;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        /*\n            Errors are queued as they occur and then logged with the source element once it has been hydrated and mounted to the DOM.\n            Means the element in the console matches what is on the page and the highlighting works properly when you hover over the elements in the console.\n        */\n        flushHydrationErrors(hydratedNode);\n    }\n    return renderer.nextSibling(hydratedNode);\n}\nconst NODE_VALUE_PROP = 'nodeValue';\nfunction validateTextNodeEquality(node, vnode, renderer) {\n    const { getProperty } = renderer;\n    const nodeValue = getProperty(node, NODE_VALUE_PROP);\n    if (nodeValue !== vnode.text &&\n        // Special case for empty text nodes â€“ these are serialized differently on the server\n        // See https://github.com/salesforce/lwc/pull/2656\n        (nodeValue !== '\\u200D' || vnode.text !== '')) {\n        queueHydrationError('text content', nodeValue, vnode.text);\n    }\n}\n// The validationOptOut static property can be an array of attribute names.\n// Any attribute names specified in that array will not be validated, and the\n// LWC runtime will assume that VDOM attrs and DOM attrs are in sync.\nfunction getValidationPredicate(elm, renderer, optOutStaticProp) {\n    // `data-lwc-host-mutated` is a special attribute added by the SSR engine itself, which automatically detects\n    // host mutations during `connectedCallback`.\n    const hostMutatedValue = renderer.getAttribute(elm, 'data-lwc-host-mutated');\n    const detectedHostMutations = isString(hostMutatedValue)\n        ? new Set(StringSplit.call(hostMutatedValue, / /))\n        : undefined;\n    // If validationOptOut is true, no attributes will be checked for correctness\n    // and the runtime will assume VDOM attrs and DOM attrs are in sync.\n    const fullOptOut = isTrue(optOutStaticProp);\n    // If validationOptOut is an array of strings, attributes specified in the array will be \"opted out\". Attributes\n    // not specified in the array will still be validated.\n    const isValidArray = isArray$1(optOutStaticProp) && arrayEvery(optOutStaticProp, isString);\n    const conditionalOptOut = isValidArray ? new Set(optOutStaticProp) : undefined;\n    if (process.env.NODE_ENV !== 'production' &&\n        !isUndefined$1(optOutStaticProp) &&\n        !isTrue(optOutStaticProp) &&\n        !isValidArray) {\n        logHydrationWarning('`validationOptOut` must be `true` or an array of attributes that should not be validated.');\n    }\n    return (attrName) => {\n        // Component wants to opt out of all validation\n        if (fullOptOut) {\n            return false;\n        }\n        // Mutations were automatically detected and should be ignored\n        if (!isUndefined$1(detectedHostMutations) && detectedHostMutations.has(attrName)) {\n            return false;\n        }\n        // Component explicitly wants to opt out of certain validations, regardless of auto-detection\n        if (!isUndefined$1(conditionalOptOut) && conditionalOptOut.has(attrName)) {\n            return false;\n        }\n        // Attribute must be validated\n        return true;\n    };\n}\nfunction hydrateText(node, vnode, renderer) {\n    if (!isTypeText(node)) {\n        return handleMismatch(node, vnode, renderer);\n    }\n    return updateTextContent(node, vnode, renderer);\n}\nfunction updateTextContent(node, vnode, renderer) {\n    if (process.env.NODE_ENV !== 'production') {\n        validateTextNodeEquality(node, vnode, renderer);\n    }\n    const { setText } = renderer;\n    setText(node, vnode.text ?? null);\n    vnode.elm = node;\n    return node;\n}\nfunction hydrateComment(node, vnode, renderer) {\n    if (!isTypeComment(node)) {\n        return handleMismatch(node, vnode, renderer);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        const { getProperty } = renderer;\n        const nodeValue = getProperty(node, NODE_VALUE_PROP);\n        if (nodeValue !== vnode.text) {\n            queueHydrationError('comment', nodeValue, vnode.text);\n        }\n    }\n    const { setProperty } = renderer;\n    // We only set the `nodeValue` property here (on a comment), so we don't need\n    // to sanitize the content as HTML using `safelySetProperty`\n    setProperty(node, NODE_VALUE_PROP, vnode.text ?? null);\n    vnode.elm = node;\n    return node;\n}\nfunction hydrateStaticElement(elm, vnode, renderer) {\n    if (isTypeElement(elm) &&\n        isTypeElement(vnode.fragment) &&\n        areStaticElementsCompatible(vnode.fragment, elm, vnode, renderer)) {\n        return hydrateStaticElementParts(elm, vnode, renderer);\n    }\n    return handleMismatch(elm, vnode, renderer);\n}\nfunction hydrateStaticElementParts(elm, vnode, renderer) {\n    const { parts } = vnode;\n    if (!isUndefined$1(parts)) {\n        // Elements must first be set on the static part to validate against.\n        traverseAndSetElements(elm, parts, renderer);\n    }\n    if (!haveCompatibleStaticParts(vnode, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    vnode.elm = elm;\n    // Hydration only requires applying event listeners and refs.\n    // All other expressions should be applied during SSR or through the handleMismatch routine.\n    hydrateStaticParts(vnode, renderer);\n    return elm;\n}\nfunction hydrateFragment(elm, vnode, renderer) {\n    const { children, owner } = vnode;\n    hydrateChildren(elm, children, renderer.getProperty(elm, 'parentNode'), owner, true);\n    return (vnode.elm = children[children.length - 1].elm);\n}\nfunction hydrateElement(elm, vnode, renderer) {\n    if (!isTypeElement(elm) || !isMatchingElement(vnode, elm, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    vnode.elm = elm;\n    const { owner } = vnode;\n    const { context } = vnode.data;\n    const isDomManual = Boolean(!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === 'manual');\n    if (isDomManual) {\n        // it may be that this element has lwc:inner-html, we need to diff and in case are the same,\n        // remove the innerHTML from props so it reuses the existing dom elements.\n        const { data: { props }, } = vnode;\n        const { getProperty } = renderer;\n        if (!isUndefined$1(props) && !isUndefined$1(props.innerHTML)) {\n            const unwrappedServerInnerHTML = unwrapIfNecessary(getProperty(elm, 'innerHTML'));\n            const unwrappedClientInnerHTML = unwrapIfNecessary(props.innerHTML);\n            if (unwrappedServerInnerHTML === unwrappedClientInnerHTML) {\n                // Do a shallow clone since VNodeData may be shared across VNodes due to hoist optimization\n                vnode.data = {\n                    ...vnode.data,\n                    props: cloneAndOmitKey(props, 'innerHTML'),\n                };\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                queueHydrationError('innerHTML', unwrappedServerInnerHTML, unwrappedClientInnerHTML);\n            }\n        }\n    }\n    patchElementPropsAndAttrsAndRefs(vnode, renderer);\n    if (!isDomManual) {\n        const { getFirstChild } = renderer;\n        hydrateChildren(getFirstChild(elm), vnode.children, elm, owner, false);\n    }\n    return elm;\n}\nfunction hydrateCustomElement(elm, vnode, renderer) {\n    const { validationOptOut } = vnode.ctor;\n    const shouldValidateAttr = getValidationPredicate(elm, renderer, validationOptOut);\n    // The validationOptOut static property can be an array of attribute names.\n    // Any attribute names specified in that array will not be validated, and the\n    // LWC runtime will assume that VDOM attrs and DOM attrs are in sync.\n    //\n    // If validationOptOut is true, no attributes will be checked for correctness\n    // and the runtime will assume VDOM attrs and DOM attrs are in sync.\n    //\n    // Therefore, if validationOptOut is falsey or an array of strings, we need to\n    // examine some or all of the custom element's attributes.\n    if (!isTypeElement(elm) || !isMatchingElement(vnode, elm, renderer, shouldValidateAttr)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    const { sel, mode, ctor, owner } = vnode;\n    const { defineCustomElement, getTagName } = renderer;\n    const isFormAssociated = shouldBeFormAssociated(ctor);\n    defineCustomElement(StringToLowerCase.call(getTagName(elm)), isFormAssociated);\n    const vm = createVM(elm, ctor, renderer, {\n        mode,\n        owner,\n        tagName: sel,\n        hydrated: true,\n    });\n    vnode.elm = elm;\n    vnode.vm = vm;\n    allocateChildren(vnode, vm);\n    patchElementPropsAndAttrsAndRefs(vnode, renderer);\n    // Insert hook section:\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);\n    }\n    runConnectedCallback(vm);\n    if (vm.renderMode !== 0 /* RenderMode.Light */) {\n        const { getFirstChild } = renderer;\n        // VM is not rendering in Light DOM, we can proceed and hydrate the slotted content.\n        // Note: for Light DOM, this is handled while hydrating the VM\n        hydrateChildren(getFirstChild(elm), vnode.children, elm, vm, false);\n    }\n    hydrateVM(vm);\n    return elm;\n}\nfunction hydrateChildren(node, children, parentNode, owner, \n// When rendering the children of a VFragment, additional siblings may follow the\n// last node of the fragment. Hydration should not fail if a trailing sibling is\n// found in this case.\nexpectAddlSiblings) {\n    let mismatchedChildren = false;\n    let nextNode = node;\n    const { renderer } = owner;\n    const { getChildNodes, cloneNode } = renderer;\n    const serverNodes = process.env.NODE_ENV !== 'production'\n        ? Array.from(getChildNodes(parentNode), (node) => cloneNode(node, true))\n        : null;\n    for (let i = 0; i < children.length; i++) {\n        const childVnode = children[i];\n        if (!isNull(childVnode)) {\n            if (nextNode) {\n                nextNode = hydrateNode(nextNode, childVnode, renderer);\n            }\n            else {\n                mismatchedChildren = true;\n                mount(childVnode, parentNode, renderer, nextNode);\n                nextNode = renderer.nextSibling(childVnode.type === 5 /* VNodeType.Fragment */ ? childVnode.trailing : childVnode.elm);\n            }\n        }\n    }\n    const useCommentsForBookends = isAPIFeatureEnabled(5 /* APIFeature.USE_COMMENTS_FOR_FRAGMENT_BOOKENDS */, owner.apiVersion);\n    if (\n    // If 1) comments are used for bookends, and 2) we're not expecting additional siblings,\n    // and 3) there exists an additional sibling, that's a hydration failure.\n    //\n    // This preserves the previous behavior for text-node bookends where mismatches\n    // would incorrectly occur but which is unfortunately baked into the SSR hydration\n    // contract. It also preserves the behavior of valid hydration failures where the server\n    // rendered more nodes than the client.\n    (!useCommentsForBookends || !expectAddlSiblings) &&\n        nextNode) {\n        mismatchedChildren = true;\n        // nextSibling is mostly harmless, and since we don't have\n        // a good reference to what element to act upon, we instead\n        // rely on the vm's associated renderer for navigating to the\n        // next node in the list to be hydrated.\n        const { nextSibling } = renderer;\n        do {\n            const current = nextNode;\n            nextNode = nextSibling(nextNode);\n            removeNode(current, parentNode, renderer);\n        } while (nextNode);\n    }\n    if (mismatchedChildren) {\n        hasMismatch = true;\n        // We can't know exactly which node(s) caused the delta, but we can provide context (parent) and the mismatched sets\n        if (process.env.NODE_ENV !== 'production') {\n            const clientNodes = ArrayMap.call(children, (c) => c?.elm);\n            queueHydrationError('child node', serverNodes, clientNodes);\n        }\n    }\n}\nfunction handleMismatch(node, vnode, renderer) {\n    hasMismatch = true;\n    const { getProperty } = renderer;\n    const parentNode = getProperty(node, 'parentNode');\n    mount(vnode, parentNode, renderer, node);\n    removeNode(node, parentNode, renderer);\n    return vnode.elm;\n}\nfunction patchElementPropsAndAttrsAndRefs(vnode, renderer) {\n    applyEventListeners(vnode, renderer);\n    patchProps(null, vnode, renderer);\n    // The `refs` object is blown away in every re-render, so we always need to re-apply them\n    applyRefs(vnode, vnode.owner);\n}\nfunction isMatchingElement(vnode, elm, renderer, shouldValidateAttr = () => true) {\n    const { getProperty } = renderer;\n    if (vnode.sel.toLowerCase() !== getProperty(elm, 'tagName').toLowerCase()) {\n        if (process.env.NODE_ENV !== 'production') {\n            queueHydrationError('node', elm);\n        }\n        return false;\n    }\n    const { data } = vnode;\n    const hasCompatibleAttrs = validateAttrs(elm, data, renderer, shouldValidateAttr);\n    const hasCompatibleClass = shouldValidateAttr('class')\n        ? validateClassAttr(vnode, elm, data, renderer)\n        : true;\n    const hasCompatibleStyle = shouldValidateAttr('style')\n        ? validateStyleAttr(elm, data, renderer)\n        : true;\n    return hasCompatibleAttrs && hasCompatibleClass && hasCompatibleStyle;\n}\nfunction attributeValuesAreEqual(vnodeValue, value) {\n    const vnodeValueAsString = String(vnodeValue);\n    if (vnodeValueAsString === value) {\n        return true;\n    }\n    // If the expected value is null, this means that the attribute does not exist. In that case,\n    // we accept any nullish value (undefined or null).\n    if (isNull(value) && (isUndefined$1(vnodeValue) || isNull(vnodeValue))) {\n        return true;\n    }\n    // In all other cases, the two values are not considered equal\n    return false;\n}\nfunction validateAttrs(elm, data, renderer, shouldValidateAttr) {\n    const { attrs = {} } = data;\n    let nodesAreCompatible = true;\n    // Validate attributes, though we could always recovery from those by running the update mods.\n    // Note: intentionally ONLY matching vnodes.attrs to elm.attrs, in case SSR is adding extra attributes.\n    for (const [attrName, attrValue] of Object.entries(attrs)) {\n        if (!shouldValidateAttr(attrName)) {\n            continue;\n        }\n        const { getAttribute } = renderer;\n        const elmAttrValue = getAttribute(elm, attrName);\n        if (!attributeValuesAreEqual(attrValue, elmAttrValue)) {\n            if (process.env.NODE_ENV !== 'production') {\n                queueHydrationError('attribute', prettyPrintAttribute(attrName, elmAttrValue), prettyPrintAttribute(attrName, attrValue));\n            }\n            nodesAreCompatible = false;\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction checkClassesCompatibility(first, second) {\n    if (first.size !== second.size) {\n        return false;\n    }\n    for (const f of first) {\n        if (!second.has(f)) {\n            return false;\n        }\n    }\n    for (const s of second) {\n        if (!first.has(s)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction validateClassAttr(vnode, elm, data, renderer) {\n    const { owner } = vnode;\n    // classMap is never available on VStaticPartData so it can default to undefined\n    // casting to prevent TS error.\n    const { className, classMap } = data;\n    // ---------- Step 1: get the classes from the element and the vnode\n    // Use a Set because we don't care to validate mismatches for 1) different ordering in SSR vs CSR, or 2)\n    // duplicated class names. These don't have an effect on rendered styles.\n    const elmClasses = elm.classList.length ? new Set(ArrayFrom(elm.classList)) : EMPTY_SET;\n    let vnodeClasses;\n    if (!isUndefined$1(className)) {\n        // ignore empty spaces entirely, filter them out using `filter(..., Boolean)`\n        const classes = ArrayFilter.call(StringSplit.call(className, /\\s+/), Boolean);\n        vnodeClasses = classes.length ? new Set(classes) : EMPTY_SET;\n    }\n    else if (!isUndefined$1(classMap)) {\n        const classes = keys(classMap);\n        vnodeClasses = classes.length ? new Set(classes) : EMPTY_SET;\n    }\n    else {\n        vnodeClasses = EMPTY_SET;\n    }\n    // ---------- Step 2: handle the scope tokens\n    // we don't care about legacy for hydration. it's a new use case\n    const scopeToken = getScopeTokenClass(owner, /* legacy */ false);\n    // Classnames for scoped CSS are added directly to the DOM during rendering,\n    // or to the VDOM on the server in the case of SSR. As such, these classnames\n    // are never present in VDOM nodes in the browser.\n    //\n    // Consequently, hydration mismatches will occur if scoped CSS token classnames\n    // are rendered during SSR. This needs to be accounted for when validating.\n    if (!isNull(scopeToken)) {\n        if (vnodeClasses === EMPTY_SET) {\n            vnodeClasses = new Set([scopeToken]);\n        }\n        else {\n            vnodeClasses.add(scopeToken);\n        }\n    }\n    // This tells us which `*-host` scope token was rendered to the element's class.\n    // For now we just ignore any mismatches involving this class.\n    // TODO [#4866]: correctly validate the host scope token class\n    const elmHostScopeToken = renderer.getAttribute(elm, 'data-lwc-host-scope-token');\n    if (!isNull(elmHostScopeToken)) {\n        elmClasses.delete(elmHostScopeToken);\n        vnodeClasses.delete(elmHostScopeToken);\n    }\n    // ---------- Step 3: check for compatibility\n    const classesAreCompatible = checkClassesCompatibility(vnodeClasses, elmClasses);\n    if (process.env.NODE_ENV !== 'production' && !classesAreCompatible) {\n        queueHydrationError('attribute', prettyPrintClasses(elmClasses), prettyPrintClasses(vnodeClasses));\n    }\n    return classesAreCompatible;\n}\nfunction validateStyleAttr(elm, data, renderer) {\n    // Note styleDecls is always undefined for VStaticPartData, casting here to default it to undefined\n    const { style, styleDecls } = data;\n    const { getAttribute } = renderer;\n    const elmStyle = getAttribute(elm, 'style') || '';\n    let vnodeStyle;\n    let nodesAreCompatible = true;\n    if (!isUndefined$1(style) && style !== elmStyle) {\n        nodesAreCompatible = false;\n        vnodeStyle = style;\n    }\n    else if (!isUndefined$1(styleDecls)) {\n        const parsedVnodeStyle = parseStyleText(elmStyle);\n        const expectedStyle = [];\n        // styleMap is used when style is set to static value.\n        for (let i = 0, n = styleDecls.length; i < n; i++) {\n            const [prop, value, important] = styleDecls[i];\n            expectedStyle.push(`${prop}: ${value + (important ? ' !important' : '')};`);\n            const parsedPropValue = parsedVnodeStyle[prop];\n            if (isUndefined$1(parsedPropValue)) {\n                nodesAreCompatible = false;\n            }\n            else if (!parsedPropValue.startsWith(value)) {\n                nodesAreCompatible = false;\n            }\n            else if (important && !parsedPropValue.endsWith('!important')) {\n                nodesAreCompatible = false;\n            }\n        }\n        if (keys(parsedVnodeStyle).length > styleDecls.length) {\n            nodesAreCompatible = false;\n        }\n        vnodeStyle = ArrayJoin.call(expectedStyle, ' ');\n    }\n    if (process.env.NODE_ENV !== 'production' && !nodesAreCompatible) {\n        queueHydrationError('attribute', prettyPrintAttribute('style', elmStyle), prettyPrintAttribute('style', vnodeStyle));\n    }\n    return nodesAreCompatible;\n}\nfunction areStaticElementsCompatible(clientElement, serverElement, vnode, renderer) {\n    const { getProperty, getAttribute } = renderer;\n    const { parts } = vnode;\n    let isCompatibleElements = true;\n    if (getProperty(clientElement, 'tagName') !== getProperty(serverElement, 'tagName')) {\n        if (process.env.NODE_ENV !== 'production') {\n            queueHydrationError('node', serverElement);\n        }\n        return false;\n    }\n    const clientAttrsNames = getProperty(clientElement, 'getAttributeNames').call(clientElement);\n    clientAttrsNames.forEach((attrName) => {\n        const clientAttributeValue = getAttribute(clientElement, attrName);\n        const serverAttributeValue = getAttribute(serverElement, attrName);\n        if (clientAttributeValue !== serverAttributeValue) {\n            // Check if the root element attributes have expressions, if it does then we need to delegate hydration\n            // validation to haveCompatibleStaticParts.\n            // Note if there are no parts then it is a fully static fragment.\n            // partId === 0 will always refer to the root element, this is guaranteed by the compiler.\n            if (parts?.[0].partId !== 0) {\n                if (process.env.NODE_ENV !== 'production') {\n                    queueHydrationError('attribute', prettyPrintAttribute(attrName, serverAttributeValue), prettyPrintAttribute(attrName, clientAttributeValue));\n                }\n                isCompatibleElements = false;\n            }\n        }\n    });\n    return isCompatibleElements;\n}\nfunction haveCompatibleStaticParts(vnode, renderer) {\n    const { parts } = vnode;\n    if (isUndefined$1(parts)) {\n        return true;\n    }\n    const shouldValidateAttr = (data, attrName) => attrName in data;\n    // The validation here relies on 2 key invariants:\n    // 1. It's never the case that `parts` is undefined on the server but defined on the client (or vice-versa)\n    // 2. It's never the case that `parts` has one length on the server but another on the client\n    for (const part of parts) {\n        const { elm } = part;\n        if (isVStaticPartElement(part)) {\n            if (!isTypeElement(elm)) {\n                return false;\n            }\n            const { data } = part;\n            const hasMatchingAttrs = validateAttrs(elm, data, renderer, () => true);\n            // Explicitly skip hydration validation when static parts don't contain `style` or `className`.\n            // This means the style/class attributes are either static or don't exist on the element and\n            // cannot be affected by hydration.\n            // We need to do class first, style second to match the ordering of non-static-optimized nodes,\n            // otherwise the ordering of console errors is different between the two.\n            const hasMatchingClass = shouldValidateAttr(data, 'className')\n                ? validateClassAttr(vnode, elm, data, renderer)\n                : true;\n            const hasMatchingStyleAttr = shouldValidateAttr(data, 'style')\n                ? validateStyleAttr(elm, data, renderer)\n                : true;\n            if (isFalse(hasMatchingAttrs && hasMatchingClass && hasMatchingStyleAttr)) {\n                return false;\n            }\n        }\n        else {\n            // VStaticPartText\n            if (!isTypeText(elm)) {\n                return false;\n            }\n            updateTextContent(elm, part, renderer);\n        }\n    }\n    return true;\n}\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// See @lwc/engine-core/src/framework/template.ts\nconst TEMPLATE_PROPS = [\n    'slots',\n    'stylesheetToken',\n    'stylesheets',\n    'renderMode',\n    'legacyStylesheetToken',\n];\n// Expandos that may be placed on a stylesheet factory function, and which are meaningful to LWC at runtime\nconst STYLESHEET_PROPS = [KEY__SCOPED_CSS, KEY__NATIVE_ONLY_CSS];\n// Via https://www.npmjs.com/package/object-observer\nconst ARRAY_MUTATION_METHODS = [\n    'pop',\n    'push',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'fill',\n    'splice',\n    'copyWithin',\n];\nlet mutationTrackingDisabled = false;\nfunction getOriginalArrayMethod(prop) {\n    switch (prop) {\n        case 'pop':\n            return ArrayPop;\n        case 'push':\n            return ArrayPush$1;\n        case 'shift':\n            return ArrayShift;\n        case 'unshift':\n            return ArrayUnshift;\n        case 'reverse':\n            return ArrayReverse;\n        case 'sort':\n            return ArraySort;\n        case 'fill':\n            return ArrayFill;\n        case 'splice':\n            return ArraySplice;\n        case 'copyWithin':\n            return ArrayCopyWithin;\n    }\n}\nfunction reportViolation(type, eventId, prop) {\n    if (process.env.NODE_ENV !== 'production') {\n        logWarnOnce(`Mutating the \"${prop}\" property on a ${type} ` +\n            `is deprecated and will be removed in a future version of LWC. ` +\n            `See: https://sfdc.co/template-mutation`);\n    }\n    report(eventId, { propertyName: prop });\n}\nfunction reportTemplateViolation(prop) {\n    reportViolation('template', \"TemplateMutation\" /* ReportingEventId.TemplateMutation */, prop);\n}\nfunction reportStylesheetViolation(prop) {\n    reportViolation('stylesheet', \"StylesheetMutation\" /* ReportingEventId.StylesheetMutation */, prop);\n}\n// Warn if the user tries to mutate a stylesheets array, e.g.:\n// `tmpl.stylesheets.push(someStylesheetFunction)`\nfunction warnOnArrayMutation(stylesheets) {\n    // We can't handle users calling Array.prototype.slice.call(tmpl.stylesheets), but\n    // we can at least warn when they use the most common mutation methods.\n    for (const prop of ARRAY_MUTATION_METHODS) {\n        const originalArrayMethod = getOriginalArrayMethod(prop);\n        // Assertions used here because TypeScript can't handle mapping over our types\n        stylesheets[prop] = function arrayMutationWarningWrapper() {\n            reportTemplateViolation('stylesheets');\n            return originalArrayMethod.apply(this, arguments);\n        };\n    }\n}\n// Warn if the user tries to mutate a stylesheet factory function, e.g.:\n// `stylesheet.$scoped$ = true`\nfunction warnOnStylesheetFunctionMutation(stylesheet) {\n    for (const prop of STYLESHEET_PROPS) {\n        let value = stylesheet[prop];\n        defineProperty(stylesheet, prop, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                reportStylesheetViolation(prop);\n                value = newValue;\n            },\n        });\n    }\n}\n// Warn on either array or stylesheet (function) mutation, in a deeply-nested array\nfunction trackStylesheetsMutation(stylesheets) {\n    traverseStylesheets(stylesheets, (subStylesheets) => {\n        if (isArray$1(subStylesheets)) {\n            warnOnArrayMutation(subStylesheets);\n        }\n        else {\n            warnOnStylesheetFunctionMutation(subStylesheets);\n        }\n    });\n}\n// Deeply freeze the entire array (of arrays) of stylesheet factory functions\nfunction deepFreeze(stylesheets) {\n    traverseStylesheets(stylesheets, (subStylesheets) => {\n        freeze(subStylesheets);\n    });\n}\n// Deep-traverse an array (of arrays) of stylesheet factory functions, and call the callback for every array/function\nfunction traverseStylesheets(stylesheets, callback) {\n    callback(stylesheets);\n    for (let i = 0; i < stylesheets.length; i++) {\n        const stylesheet = stylesheets[i];\n        if (isArray$1(stylesheet)) {\n            traverseStylesheets(stylesheet, callback);\n        }\n        else {\n            callback(stylesheet);\n        }\n    }\n}\nfunction trackMutations(tmpl) {\n    if (!isUndefined$1(tmpl.stylesheets)) {\n        trackStylesheetsMutation(tmpl.stylesheets);\n    }\n    for (const prop of TEMPLATE_PROPS) {\n        let value = tmpl[prop];\n        defineProperty(tmpl, prop, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                if (!mutationTrackingDisabled) {\n                    reportTemplateViolation(prop);\n                }\n                value = newValue;\n            },\n        });\n    }\n    const originalDescriptor = getOwnPropertyDescriptor$1(tmpl, 'stylesheetTokens');\n    defineProperty(tmpl, 'stylesheetTokens', {\n        enumerable: true,\n        configurable: true,\n        get: originalDescriptor.get,\n        set(value) {\n            reportTemplateViolation('stylesheetTokens');\n            // Avoid logging/reporting twice (for both stylesheetToken and stylesheetTokens)\n            mutationTrackingDisabled = true;\n            originalDescriptor.set.call(this, value);\n            mutationTrackingDisabled = false;\n        },\n    });\n}\nfunction addLegacyStylesheetTokensShim(tmpl) {\n    // When ENABLE_FROZEN_TEMPLATE is false, then we shim stylesheetTokens on top of stylesheetToken for anyone who\n    // is accessing the old internal API (backwards compat). Details: W-14210169\n    defineProperty(tmpl, 'stylesheetTokens', {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { stylesheetToken } = this;\n            if (isUndefined$1(stylesheetToken)) {\n                return stylesheetToken;\n            }\n            // Shim for the old `stylesheetTokens` property\n            // See https://github.com/salesforce/lwc/pull/2332/files#diff-7901555acef29969adaa6583185b3e9bce475cdc6f23e799a54e0018cb18abaa\n            return {\n                hostAttribute: `${stylesheetToken}-host`,\n                shadowAttribute: stylesheetToken,\n            };\n        },\n        set(value) {\n            // If the value is null or some other exotic object, you would be broken anyway in the past\n            // because the engine would try to access hostAttribute/shadowAttribute, which would throw an error.\n            // However it may be undefined in newer versions of LWC, so we need to guard against that case.\n            this.stylesheetToken = isUndefined$1(value) ? undefined : value.shadowAttribute;\n        },\n    });\n}\nfunction freezeTemplate(tmpl) {\n    // TODO [#2782]: remove this flag and delete the legacy behavior\n    if (lwcRuntimeFlags.ENABLE_FROZEN_TEMPLATE) {\n        // Deep freeze the template\n        freeze(tmpl);\n        if (!isUndefined$1(tmpl.stylesheets)) {\n            deepFreeze(tmpl.stylesheets);\n        }\n    }\n    else {\n        // template is not frozen - shim, report, and warn\n        // this shim should be applied in both dev and prod\n        addLegacyStylesheetTokensShim(tmpl);\n        // When ENABLE_FROZEN_TEMPLATE is false, we want to warn in dev mode whenever someone is mutating the template\n        if (process.env.NODE_ENV !== 'production') {\n            trackMutations(tmpl);\n        }\n        else {\n            // In prod mode, we only track mutations if reporting is enabled\n            onReportingEnabled(() => {\n                trackMutations(tmpl);\n            });\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.\n * This API is subject to change or being removed.\n * @param elm\n */\nfunction getComponentConstructor(elm) {\n    let ctor = null;\n    // intentionally checking for undefined due to some funky libraries patching weakmap.get\n    // to throw when undefined.\n    if (!isUndefined$1(elm)) {\n        const vm = getAssociatedVMIfPresent(elm);\n        if (!isUndefined$1(vm)) {\n            ctor = vm.def.ctor;\n        }\n    }\n    return ctor;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n * @param obj\n */\nfunction readonly(obj) {\n    if (process.env.NODE_ENV !== 'production') {\n        // TODO [#1292]: Remove the readonly decorator\n        if (arguments.length !== 1) {\n            logError('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n        }\n    }\n    return getReadOnlyProxy(obj);\n}\n/** version: 8.13.2 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * Displays the header for a custom element.\n * @param ce The custom element to get the header for.\n * @param componentInstance component instance associated with the custom element.\n */\nfunction getHeaderForCustomElement(ce, componentInstance) {\n    // [element]\n    // LWC component instance: [vm.component]\n    return [\n        'div',\n        {},\n        ['object', { object: ce, config: { skip: true } }],\n        [\n            'div',\n            {},\n            ['span', { style: 'margin: 0 5px; color: red' }, 'LWC:'],\n            ['object', { object: componentInstance }],\n        ],\n    ];\n}\nfunction getHeaderForComponentInstance(componentInstance, debugInfo) {\n    if (keys(debugInfo).length === 0) {\n        // there is no debug information, no need to customize this component instance\n        return null;\n    }\n    // [component]\n    // Debug information: [vm.debugInfo]\n    return [\n        'div',\n        {},\n        ['object', { object: componentInstance, config: { skip: true } }],\n        [\n            'div',\n            {},\n            ['span', { style: 'margin: 0 5px; color: red' }, 'Debug:'],\n            ['object', { object: debugInfo }],\n        ],\n    ];\n}\nconst LightningElementFormatter = {\n    name: 'LightningElementFormatter',\n    header(obj, config) {\n        const vm = getAssociatedVMIfPresent(obj);\n        if (!isUndefined$1(vm) && (isUndefined$1(config) || !config.skip)) {\n            if (obj instanceof HTMLElement) {\n                return getHeaderForCustomElement(obj, vm.component);\n            }\n            else {\n                return getHeaderForComponentInstance(obj, vm.debugInfo);\n            }\n        }\n        return null;\n    },\n    hasBody() {\n        return false;\n    },\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction init() {\n    const devtoolsFormatters = globalThis.devtoolsFormatters || [];\n    ArrayPush$1.call(devtoolsFormatters, LightningElementFormatter);\n    globalThis.devtoolsFormatters = devtoolsFormatters;\n}\nif (process.env.NODE_ENV !== 'production') {\n    init();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// Feature detection\n//\n// This check for constructable style sheets is similar to Fast's:\n// https://github.com/microsoft/fast/blob/d49d1ec/packages/web-components/fast-element/src/dom.ts#L51-L53\n// See also: https://github.com/whatwg/webidl/issues/1027#issuecomment-934510070\nconst supportsConstructableStylesheets = isFunction$1(CSSStyleSheet.prototype.replaceSync) && isArray$1(document.adoptedStyleSheets);\nconst stylesheetCache = new Map();\n//\n// Test utilities\n//\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    window.__lwcResetGlobalStylesheets = () => {\n        stylesheetCache.clear();\n    };\n}\nfunction createFreshStyleElement(content) {\n    const elm = document.createElement('style');\n    elm.type = 'text/css';\n    elm.textContent = content;\n    // Add an attribute to distinguish global styles added by LWC as opposed to other frameworks/libraries on the page\n    elm.setAttribute('data-rendered-by-lwc', '');\n    return elm;\n}\nfunction createStyleElement(content, cacheData) {\n    const { element, usedElement } = cacheData;\n    // If the <style> was already used, then we should clone it. We cannot insert\n    // the same <style> in two places in the DOM.\n    if (usedElement) {\n        // This `<style>` may be repeated multiple times in the DOM, so cache it. It's a bit\n        // faster to call `cloneNode()` on an existing node than to recreate it every time.\n        return element.cloneNode(true);\n    }\n    // We don't clone every time, because that would be a perf tax on the first time\n    cacheData.usedElement = true;\n    return element;\n}\nfunction createConstructableStylesheet(content) {\n    const stylesheet = new CSSStyleSheet();\n    stylesheet.replaceSync(content);\n    return stylesheet;\n}\nfunction insertConstructableStylesheet(content, target, cacheData, signal) {\n    const { adoptedStyleSheets } = target;\n    const { stylesheet } = cacheData;\n    // The reason we prefer .push() rather than reassignment is for perf: https://github.com/salesforce/lwc/pull/2683\n    adoptedStyleSheets.push(stylesheet);\n    if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (isUndefined$1(signal)) {\n            throw new Error('Expected AbortSignal to be defined in dev mode');\n        }\n        // TODO [#4155]: unrendering should account for stylesheet content collisions\n        signal.addEventListener('abort', () => {\n            adoptedStyleSheets.splice(adoptedStyleSheets.indexOf(stylesheet), 1);\n            stylesheetCache.delete(content);\n        });\n    }\n}\nfunction insertStyleElement(content, target, cacheData, signal) {\n    const elm = createStyleElement(content, cacheData);\n    target.appendChild(elm);\n    if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (isUndefined$1(signal)) {\n            throw new Error('Expected AbortSignal to be defined in dev mode');\n        }\n        // TODO [#4155]: unrendering should account for stylesheet content collisions\n        signal.addEventListener('abort', () => {\n            target.removeChild(elm);\n            stylesheetCache.delete(content);\n        });\n    }\n}\nfunction getCacheData(content, useConstructableStylesheet) {\n    let cacheData = stylesheetCache.get(content);\n    if (isUndefined$1(cacheData)) {\n        cacheData = {\n            stylesheet: undefined,\n            element: undefined,\n            roots: undefined,\n            global: false,\n            usedElement: false,\n        };\n        stylesheetCache.set(content, cacheData);\n    }\n    // Create <style> elements or CSSStyleSheets on-demand, as needed\n    if (useConstructableStylesheet && isUndefined$1(cacheData.stylesheet)) {\n        cacheData.stylesheet = createConstructableStylesheet(content);\n    }\n    else if (!useConstructableStylesheet && isUndefined$1(cacheData.element)) {\n        cacheData.element = createFreshStyleElement(content);\n    }\n    return cacheData;\n}\nfunction insertGlobalStylesheet(content, signal) {\n    // Force a <style> element for global stylesheets. See comment below.\n    const cacheData = getCacheData(content, false);\n    if (cacheData.global) {\n        // already inserted\n        return;\n    }\n    cacheData.global = true; // mark inserted\n    // TODO [#2922]: use document.adoptedStyleSheets in supported browsers. Currently we can't, due to backwards compat.\n    insertStyleElement(content, document.head, cacheData, signal);\n}\nfunction insertLocalStylesheet(content, target, signal) {\n    const cacheData = getCacheData(content, supportsConstructableStylesheets);\n    let { roots } = cacheData;\n    if (isUndefined$1(roots)) {\n        roots = cacheData.roots = new WeakSet(); // lazily initialize (not needed for global styles)\n    }\n    else if (roots.has(target)) {\n        // already inserted\n        return;\n    }\n    roots.add(target); // mark inserted\n    // Constructable stylesheets are only supported in certain browsers:\n    // https://caniuse.com/mdn-api_document_adoptedstylesheets\n    // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2460\n    if (supportsConstructableStylesheets) {\n        insertConstructableStylesheet(content, target, cacheData, signal);\n    }\n    else {\n        // Fall back to <style> element\n        insertStyleElement(content, target, cacheData, signal);\n    }\n}\n/**\n * Injects a stylesheet into the global (document) level or inside a shadow root.\n * @param content CSS content to insert\n * @param target ShadowRoot to insert into, or undefined if global (document) level\n * @param signal AbortSignal for aborting the stylesheet render. Used in dev mode for HMR to unrender stylesheets.\n */\nfunction insertStylesheet(content, target, signal) {\n    if (isUndefined$1(target)) {\n        // global\n        insertGlobalStylesheet(content, signal);\n    }\n    else {\n        // local\n        insertLocalStylesheet(content, target, signal);\n    }\n}\n\n/*\n * Copyright (c) 2023, Salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst cachedConstructors = new Map();\nconst nativeLifecycleElementsToUpgradedByLWC = new WeakMap();\nlet elementBeingUpgradedByLWC = false;\nlet BaseUpgradableConstructor;\nlet BaseHTMLElement;\nfunction createBaseUpgradableConstructor() {\n    // Creates a constructor that is intended to be used directly as a custom element, except that the upgradeCallback is\n    // passed in to the constructor so LWC can reuse the same custom element constructor for multiple components.\n    // Another benefit is that only LWC can create components that actually do anything â€“ if you do\n    // `customElements.define('x-foo')`, then you don't have access to the upgradeCallback, so it's a dummy custom element.\n    // This class should be created once per tag name.\n    // TODO [#2972]: this class should expose observedAttributes as necessary\n    BaseUpgradableConstructor = class TheBaseUpgradableConstructor extends HTMLElement {\n        constructor(upgradeCallback, useNativeLifecycle) {\n            super();\n            if (useNativeLifecycle) {\n                // When in native lifecycle mode, we need to keep track of instances that were created outside LWC\n                // (i.e. not created by `lwc.createElement()`). If the element uses synthetic lifecycle, then we don't\n                // need to track this.\n                nativeLifecycleElementsToUpgradedByLWC.set(this, elementBeingUpgradedByLWC);\n            }\n            // If the element is not created using lwc.createElement(), e.g. `document.createElement('x-foo')`,\n            // then elementBeingUpgradedByLWC will be false\n            if (elementBeingUpgradedByLWC) {\n                upgradeCallback(this);\n            }\n            // TODO [#2970]: LWC elements cannot be upgraded via new Ctor()\n            // Do we want to support this? Throw an error? Currently for backwards compat it's a no-op.\n        }\n        connectedCallback() {\n            // native `connectedCallback`/`disconnectedCallback` are only enabled in native lifecycle mode\n            if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {\n                connectRootElement(this);\n            }\n        }\n        disconnectedCallback() {\n            // native `connectedCallback`/`disconnectedCallback` are only enabled in native lifecycle mode\n            if (isTrue(nativeLifecycleElementsToUpgradedByLWC.get(this))) {\n                disconnectRootElement(this);\n            }\n        }\n        formAssociatedCallback(form) {\n            runFormAssociatedCallback(this, form);\n        }\n        formDisabledCallback(disabled) {\n            runFormDisabledCallback(this, disabled);\n        }\n        formResetCallback() {\n            runFormResetCallback(this);\n        }\n        formStateRestoreCallback(state, reason) {\n            runFormStateRestoreCallback(this, state, reason);\n        }\n    };\n    BaseHTMLElement = HTMLElement; // cache to track if it changes\n}\nconst createUpgradableConstructor = (isFormAssociated) => {\n    if (HTMLElement !== BaseHTMLElement) {\n        // If the global HTMLElement changes out from under our feet, then we need to create a new\n        // BaseUpgradableConstructor from scratch (since it extends from HTMLElement). This can occur if\n        // polyfills are in play, e.g. a polyfill for scoped custom element registries.\n        // This workaround can potentially be removed when W-15361244 is resolved.\n        createBaseUpgradableConstructor();\n    }\n    // Using a BaseUpgradableConstructor superclass here is a perf optimization to avoid\n    // re-defining the same logic (connectedCallback, disconnectedCallback, etc.) over and over.\n    class UpgradableConstructor extends (BaseUpgradableConstructor) {\n    }\n    if (isFormAssociated) {\n        // Perf optimization - the vast majority of components have formAssociated=false,\n        // so we can skip the setter in those cases, since undefined works the same as false.\n        UpgradableConstructor.formAssociated = isFormAssociated;\n    }\n    return UpgradableConstructor;\n};\nfunction getUpgradableConstructor(tagName, isFormAssociated) {\n    let UpgradableConstructor = cachedConstructors.get(tagName);\n    if (isUndefined$1(UpgradableConstructor)) {\n        if (!isUndefined$1(customElements.get(tagName))) {\n            throw new Error(`Unexpected tag name \"${tagName}\". This name is a registered custom element, preventing LWC to upgrade the element.`);\n        }\n        UpgradableConstructor = createUpgradableConstructor(isFormAssociated);\n        customElements.define(tagName, UpgradableConstructor);\n        cachedConstructors.set(tagName, UpgradableConstructor);\n    }\n    return UpgradableConstructor;\n}\nconst createCustomElement = (tagName, upgradeCallback, useNativeLifecycle, isFormAssociated) => {\n    const UpgradableConstructor = getUpgradableConstructor(tagName, isFormAssociated);\n    if (Boolean(UpgradableConstructor.formAssociated) !== isFormAssociated) {\n        throw new Error(`<${tagName}> was already registered with formAssociated=${UpgradableConstructor.formAssociated}. It cannot be re-registered with formAssociated=${isFormAssociated}. Please rename your component to have a different name than <${tagName}>`);\n    }\n    elementBeingUpgradedByLWC = true;\n    try {\n        return new UpgradableConstructor(upgradeCallback, useNativeLifecycle);\n    }\n    finally {\n        elementBeingUpgradedByLWC = false;\n    }\n};\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * A factory function that produces a renderer.\n * Renderer encapsulates operations that are required to render an LWC component into the underlying\n * runtime environment. In the case of @lwc/enigne-dom, it is meant to be used in a DOM environment.\n * @param baseRenderer Either null or the base renderer imported from 'lwc'.\n * @returns The created renderer\n * @example\n * import { renderer, rendererFactory } from 'lwc';\n * const customRenderer = rendererFactory(renderer);\n */\nfunction rendererFactory(baseRenderer) {\n    // Type assertion because this is replaced by rollup with an object, not a string.\n    // See `injectInlineRenderer` in /scripts/rollup/rollup.config.js\n    const renderer = (function (exports) {\n\n    /**\n     * Copyright (c) 2025 Salesforce, Inc.\n     */\n    /*\n     * Copyright (c) 2018, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    /**\n     *\n     * @param value\n     * @param msg\n     */\n    function invariant(value, msg) {\n        if (!value) {\n            throw new Error(`Invariant Violation: ${msg}`);\n        }\n    }\n    /**\n     *\n     * @param value\n     * @param msg\n     */\n    function isTrue$1(value, msg) {\n        if (!value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    }\n    /**\n     *\n     * @param value\n     * @param msg\n     */\n    function isFalse$1(value, msg) {\n        if (value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    }\n    /**\n     *\n     * @param msg\n     */\n    function fail(msg) {\n        throw new Error(msg);\n    }\n\n    var assert = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        fail: fail,\n        invariant: invariant,\n        isFalse: isFalse$1,\n        isTrue: isTrue$1\n    });\n\n    /*\n     * Copyright (c) 2024, Salesforce, Inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    const { \n    /** Detached {@linkcode Object.getOwnPropertyDescriptors}; see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors MDN Reference}. */\n    getOwnPropertyDescriptors} = Object;\n    /**\n     * Determines whether the argument is `undefined`.\n     * @param obj Value to test\n     * @returns `true` if the value is `undefined`.\n     */\n    function isUndefined(obj) {\n        return obj === undefined;\n    }\n    /**\n     * Determines whether the argument is `null`.\n     * @param obj Value to test\n     * @returns `true` if the value is `null`.\n     */\n    function isNull(obj) {\n        return obj === null;\n    }\n    /** version: 8.13.2 */\n\n    /*\n     * Copyright (c) 2024, Salesforce, Inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    // Like @lwc/shared, but for DOM APIs\n    const ElementDescriptors = getOwnPropertyDescriptors(Element.prototype);\n    const ElementAttachShadow = ElementDescriptors.attachShadow.value;\n    const ElementShadowRootGetter = ElementDescriptors.shadowRoot.get;\n\n    /*\n     * Copyright (c) 2023, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    class WireContextSubscriptionEvent extends CustomEvent {\n        constructor(adapterToken, { setNewContext, setDisconnectedCallback }) {\n            super(adapterToken, {\n                bubbles: true,\n                composed: true,\n            });\n            this.setNewContext = setNewContext;\n            this.setDisconnectedCallback = setDisconnectedCallback;\n        }\n    }\n    function registerContextConsumer(elm, adapterContextToken, subscriptionPayload) {\n        dispatchEvent(elm, new WireContextSubscriptionEvent(adapterContextToken, subscriptionPayload));\n    }\n    function registerContextProvider(elm, adapterContextToken, onContextSubscription) {\n        addEventListener(elm, adapterContextToken, ((evt) => {\n            evt.stopImmediatePropagation();\n            const { setNewContext, setDisconnectedCallback } = evt;\n            onContextSubscription({\n                setNewContext,\n                setDisconnectedCallback,\n            });\n        }));\n    }\n\n    /*\n     * Copyright (c) 2018, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    function cloneNode(node, deep) {\n        return node.cloneNode(deep);\n    }\n    function createElement(tagName, namespace) {\n        return isUndefined(namespace)\n            ? document.createElement(tagName)\n            : document.createElementNS(namespace, tagName);\n    }\n    function createText(content) {\n        return document.createTextNode(content);\n    }\n    function createComment(content) {\n        return document.createComment(content);\n    }\n    // Parse the fragment HTML string into DOM\n    function createFragment(html) {\n        const template = document.createElement('template');\n        template.innerHTML = html;\n        return template.content.firstChild;\n    }\n    function insert(node, parent, anchor) {\n        parent.insertBefore(node, anchor);\n    }\n    function remove(node, parent) {\n        parent.removeChild(node);\n    }\n    function nextSibling(node) {\n        return node.nextSibling;\n    }\n    function previousSibling(node) {\n        return node.previousSibling;\n    }\n    function getParentNode(node) {\n        return node.parentNode;\n    }\n    function attachShadow(element, options) {\n        // `shadowRoot` will be non-null in two cases:\n        //   1. upon initial load with an SSR-generated DOM, while in Shadow render mode\n        //   2. when a webapp author places <c-app> in their static HTML and mounts their\n        //      root component with customElement.define('c-app', Ctor)\n        // see W-17441501\n        const shadowRoot = ElementShadowRootGetter.call(element);\n        if (!isNull(shadowRoot)) {\n            return shadowRoot;\n        }\n        return ElementAttachShadow.call(element, options);\n    }\n    function setText(node, content) {\n        node.nodeValue = content;\n    }\n    function getProperty(node, key) {\n        return node[key];\n    }\n    function setProperty(node, key, value) {\n        node[key] = value;\n    }\n    function getAttribute(element, name, namespace) {\n        return isUndefined(namespace)\n            ? element.getAttribute(name)\n            : element.getAttributeNS(namespace, name);\n    }\n    function setAttribute(element, name, value, namespace) {\n        return isUndefined(namespace)\n            ? element.setAttribute(name, value)\n            : element.setAttributeNS(namespace, name, value);\n    }\n    function removeAttribute(element, name, namespace) {\n        if (isUndefined(namespace)) {\n            element.removeAttribute(name);\n        }\n        else {\n            element.removeAttributeNS(namespace, name);\n        }\n    }\n    function addEventListener(target, type, callback, options) {\n        target.addEventListener(type, callback, options);\n    }\n    function removeEventListener(target, type, callback, options) {\n        target.removeEventListener(type, callback, options);\n    }\n    function dispatchEvent(target, event) {\n        return target.dispatchEvent(event);\n    }\n    function getClassList(element) {\n        return element.classList;\n    }\n    function setCSSStyleProperty(element, name, value, important) {\n        // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to\n        // represent elements in the engine?\n        element.style.setProperty(name, value, important ? 'important' : '');\n    }\n    function getBoundingClientRect(element) {\n        return element.getBoundingClientRect();\n    }\n    function querySelector(element, selectors) {\n        return element.querySelector(selectors);\n    }\n    function querySelectorAll(element, selectors) {\n        return element.querySelectorAll(selectors);\n    }\n    function getElementsByTagName(element, tagNameOrWildCard) {\n        return element.getElementsByTagName(tagNameOrWildCard);\n    }\n    function getElementsByClassName(element, names) {\n        return element.getElementsByClassName(names);\n    }\n    function getChildren(element) {\n        return element.children;\n    }\n    function getChildNodes(element) {\n        return element.childNodes;\n    }\n    function getFirstChild(element) {\n        return element.firstChild;\n    }\n    function getFirstElementChild(element) {\n        return element.firstElementChild;\n    }\n    function getLastChild(element) {\n        return element.lastChild;\n    }\n    function getLastElementChild(element) {\n        return element.lastElementChild;\n    }\n    function isConnected(node) {\n        return node.isConnected;\n    }\n    function assertInstanceOfHTMLElement(elm, msg) {\n        assert.invariant(elm instanceof HTMLElement, msg);\n    }\n    function ownerDocument(element) {\n        return element.ownerDocument;\n    }\n    function getTagName(elm) {\n        return elm.tagName;\n    }\n    function getStyle(elm) {\n        return elm.style;\n    }\n    function attachInternals(elm) {\n        return attachInternalsFunc.call(elm);\n    }\n    // Use the attachInternals method from HTMLElement.prototype because access to it is removed\n    // in HTMLBridgeElement, ie: elm.attachInternals is undefined.\n    // Additionally, cache the attachInternals method to protect against 3rd party monkey-patching.\n    const attachInternalsFunc = typeof ElementInternals !== 'undefined'\n        ? HTMLElement.prototype.attachInternals\n        : () => {\n            throw new Error('attachInternals API is not supported in this browser environment.');\n        };\n\n    exports.addEventListener = addEventListener;\n    exports.assertInstanceOfHTMLElement = assertInstanceOfHTMLElement;\n    exports.attachInternals = attachInternals;\n    exports.attachShadow = attachShadow;\n    exports.cloneNode = cloneNode;\n    exports.createComment = createComment;\n    exports.createElement = createElement;\n    exports.createFragment = createFragment;\n    exports.createText = createText;\n    exports.dispatchEvent = dispatchEvent;\n    exports.getAttribute = getAttribute;\n    exports.getBoundingClientRect = getBoundingClientRect;\n    exports.getChildNodes = getChildNodes;\n    exports.getChildren = getChildren;\n    exports.getClassList = getClassList;\n    exports.getElementsByClassName = getElementsByClassName;\n    exports.getElementsByTagName = getElementsByTagName;\n    exports.getFirstChild = getFirstChild;\n    exports.getFirstElementChild = getFirstElementChild;\n    exports.getLastChild = getLastChild;\n    exports.getLastElementChild = getLastElementChild;\n    exports.getParentNode = getParentNode;\n    exports.getProperty = getProperty;\n    exports.getStyle = getStyle;\n    exports.getTagName = getTagName;\n    exports.insert = insert;\n    exports.isConnected = isConnected;\n    exports.nextSibling = nextSibling;\n    exports.ownerDocument = ownerDocument;\n    exports.previousSibling = previousSibling;\n    exports.querySelector = querySelector;\n    exports.querySelectorAll = querySelectorAll;\n    exports.registerContextConsumer = registerContextConsumer;\n    exports.registerContextProvider = registerContextProvider;\n    exports.remove = remove;\n    exports.removeAttribute = removeAttribute;\n    exports.removeEventListener = removeEventListener;\n    exports.setAttribute = setAttribute;\n    exports.setCSSStyleProperty = setCSSStyleProperty;\n    exports.setProperty = setProperty;\n    exports.setText = setText;\n\n    return exports;\n\n})({});\n    // Meant to inherit any properties passed via the base renderer as the argument to the factory.\n    Object.setPrototypeOf(renderer, baseRenderer);\n    return renderer;\n}\n\n/*\n * Copyright (c) 2023, Salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Host element mutation tracking is for SSR only\nconst startTrackingMutations = noop;\nconst stopTrackingMutations = noop;\n/**\n * The base renderer that will be used by engine-core.\n * This will be used for DOM operations when lwc is running in a browser environment.\n */\nconst renderer = assign(\n// The base renderer will invoke the factory with null and assign additional properties that are\n// shared across renderers\nrendererFactory(null), \n// Properties that are either not required to be sandboxed or rely on a globally shared information\n{\n    // insertStyleSheet implementation shares a global cache of stylesheet data\n    insertStylesheet,\n    // relies on a shared global cache\n    createCustomElement,\n    defineCustomElement: getUpgradableConstructor,\n    isSyntheticShadowDefined: hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN),\n    startTrackingMutations,\n    stopTrackingMutations,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resetShadowRootAndLightDom(element, Ctor) {\n    if (element.shadowRoot) {\n        const shadowRoot = element.shadowRoot;\n        while (!isNull(shadowRoot.firstChild)) {\n            shadowRoot.removeChild(shadowRoot.firstChild);\n        }\n    }\n    if (Ctor.renderMode === 'light') {\n        while (!isNull(element.firstChild)) {\n            element.removeChild(element.firstChild);\n        }\n    }\n}\nfunction createVMWithProps(element, Ctor, props) {\n    const vm = createVM(element, Ctor, renderer, {\n        mode: 'open',\n        owner: null,\n        tagName: element.tagName.toLowerCase(),\n        hydrated: true,\n    });\n    for (const [key, value] of Object.entries(props)) {\n        element[key] = value;\n    }\n    return vm;\n}\n/**\n * Replaces an existing DOM node with an LWC component.\n * @param element The existing node in the DOM that where the root component should be attached.\n * @param Ctor The LWC class to use as the root component.\n * @param props Any props for the root component as part of initial client-side rendering. The props must be identical to those passed to renderComponent during SSR.\n * @throws Throws when called with invalid parameters.\n * @example\n * import { hydrateComponent } from 'lwc';\n * import App from 'x/App';\n * const elm = document.querySelector('x-app');\n * hydrateComponent(elm, App, { name: 'Hello World' });\n */\nfunction hydrateComponent(element, Ctor, props = {}) {\n    if (!(element instanceof Element)) {\n        throw new TypeError(`\"hydrateComponent\" expects a valid DOM element as the first parameter but instead received ${element}.`);\n    }\n    if (!isFunction$1(Ctor)) {\n        throw new TypeError(`\"hydrateComponent\" expects a valid component constructor as the second parameter but instead received ${Ctor}.`);\n    }\n    if (!isObject(props) || isNull(props)) {\n        throw new TypeError(`\"hydrateComponent\" expects an object as the third parameter but instead received ${props}.`);\n    }\n    if (getAssociatedVMIfPresent(element)) {\n        /* eslint-disable-next-line no-console */\n        console.warn(`\"hydrateComponent\" expects an element that is not hydrated.`, element);\n        return;\n    }\n    try {\n        const { defineCustomElement, getTagName } = renderer;\n        const isFormAssociated = shouldBeFormAssociated(Ctor);\n        defineCustomElement(StringToLowerCase.call(getTagName(element)), isFormAssociated);\n        const vm = createVMWithProps(element, Ctor, props);\n        hydrateRoot(vm);\n    }\n    catch (e) {\n        // Fallback: In case there's an error while hydrating, let's log the error, and replace the element content\n        //           with the client generated DOM.\n        /* eslint-disable-next-line no-console */\n        console.error('Recovering from error while hydrating: ', e);\n        // We want to preserve the element, so we need to reset the shadowRoot and light dom.\n        resetShadowRootAndLightDom(element, Ctor);\n        // we need to recreate the vm with the hydration flag on, so it re-uses the existing shadowRoot.\n        createVMWithProps(element, Ctor, props);\n        connectRootElement(element);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This function builds a Web Component class from a LWC constructor so it can be\n * registered as a new element via customElements.define() at any given time.\n * @param Ctor LWC constructor to build\n * @returns A Web Component class\n * @example\n * import { buildCustomElementConstructor } from 'lwc';\n * import Foo from 'ns/foo';\n * const WC = buildCustomElementConstructor(Foo);\n * customElements.define('x-foo', WC);\n * const elm = document.createElement('x-foo');\n * @deprecated since version 1.3.11\n */\nfunction deprecatedBuildCustomElementConstructor(Ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        /* eslint-disable-next-line no-console */\n        console.warn('Deprecated function called: \"buildCustomElementConstructor\" function is deprecated and it will be removed.' +\n            `Use \"${Ctor.name}.CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead.`);\n    }\n    return Ctor.CustomElementConstructor;\n}\nfunction clearNode(node) {\n    const childNodes = renderer.getChildNodes(node);\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n        renderer.remove(childNodes[i], node);\n    }\n}\n/**\n * The real `buildCustomElementConstructor`. Should not be accessible to external users!\n * @internal\n * @param Ctor LWC constructor to build\n * @returns A Web Component class\n * @see {@linkcode deprecatedBuildCustomElementConstructor}\n */\nfunction buildCustomElementConstructor(Ctor) {\n    var _a;\n    const HtmlPrototype = getComponentHtmlPrototype(Ctor);\n    const { observedAttributes } = HtmlPrototype;\n    const { attributeChangedCallback } = HtmlPrototype.prototype;\n    return _a = class extends HTMLElement {\n            constructor() {\n                super();\n                if (!isNull(this.shadowRoot)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // eslint-disable-next-line no-console\n                        console.warn(`Found an existing shadow root for the custom element \"${Ctor.name}\". Call \\`hydrateComponent\\` instead.`);\n                    }\n                    clearNode(this.shadowRoot);\n                }\n                // Compute renderMode/shadowMode in advance. This must be done before `createVM` because `createVM` may\n                // mutate the element.\n                const { shadowMode, renderMode } = computeShadowAndRenderMode(Ctor, renderer);\n                // Native shadow components are allowed to have pre-existing `childNodes` before upgrade. This supports\n                // use cases where a custom element has declaratively-defined slotted content, e.g.:\n                // https://github.com/salesforce/lwc/issues/3639\n                const isNativeShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 0 /* ShadowMode.Native */;\n                if (!isNativeShadow && this.childNodes.length > 0) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // eslint-disable-next-line no-console\n                        console.warn(`Light DOM and synthetic shadow custom elements cannot have child nodes. ` +\n                            `Ensure the element is empty, including whitespace.`);\n                    }\n                    clearNode(this);\n                }\n                createVM(this, Ctor, renderer, {\n                    mode: 'open',\n                    owner: null,\n                    tagName: this.tagName,\n                });\n            }\n            connectedCallback() {\n                connectRootElement(this);\n            }\n            disconnectedCallback() {\n                disconnectRootElement(this);\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (this instanceof BaseBridgeElement) {\n                    // W-17420330\n                    attributeChangedCallback.call(this, name, oldValue, newValue);\n                }\n            }\n            formAssociatedCallback(form) {\n                runFormAssociatedCallback(this, form);\n            }\n            formDisabledCallback(disabled) {\n                runFormDisabledCallback(this, disabled);\n            }\n            formResetCallback() {\n                runFormResetCallback(this);\n            }\n            formStateRestoreCallback(state, reason) {\n                runFormStateRestoreCallback(this, state, reason);\n            }\n        },\n        _a.observedAttributes = observedAttributes,\n        // Note CustomElementConstructor is not upgraded by LWC and inherits directly from HTMLElement which means it calls the native\n        // attachInternals API.\n        _a.formAssociated = Boolean(Ctor.formAssociated),\n        _a;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node$1 = Node;\nconst ConnectingSlot = new WeakMap();\nconst DisconnectingSlot = new WeakMap();\nfunction callNodeSlot(node, slot) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n    }\n    const fn = slot.get(node);\n    if (!isUndefined$1(fn)) {\n        fn(node);\n    }\n    return node; // for convenience\n}\nlet monkeyPatched = false;\nfunction monkeyPatchDomAPIs() {\n    if (monkeyPatched) {\n        // don't double-patch\n        return;\n    }\n    monkeyPatched = true;\n    // Monkey patching Node methods to be able to detect the insertions and removal of root elements\n    // created via createElement.\n    const { appendChild, insertBefore, removeChild, replaceChild } = _Node$1.prototype;\n    assign(_Node$1.prototype, {\n        appendChild(newChild) {\n            const appendedNode = appendChild.call(this, newChild);\n            return callNodeSlot(appendedNode, ConnectingSlot);\n        },\n        insertBefore(newChild, referenceNode) {\n            if (process.env.NODE_ENV !== 'production' && arguments.length < 2) {\n                // eslint-disable-next-line no-console\n                console.warn('insertBefore should be called with 2 arguments. Calling with only 1 argument is not supported.');\n            }\n            const insertedNode = insertBefore.call(this, newChild, referenceNode);\n            return callNodeSlot(insertedNode, ConnectingSlot);\n        },\n        removeChild(oldChild) {\n            const removedNode = removeChild.call(this, oldChild);\n            return callNodeSlot(removedNode, DisconnectingSlot);\n        },\n        replaceChild(newChild, oldChild) {\n            const replacedNode = replaceChild.call(this, newChild, oldChild);\n            callNodeSlot(replacedNode, DisconnectingSlot);\n            callNodeSlot(newChild, ConnectingSlot);\n            return replacedNode;\n        },\n    });\n}\nif (process.env.NODE_ENV !== 'production') {\n    // In dev mode, we must eagerly patch these DOM APIs because `restrictions.ts` in `@lwc/engine-core` does\n    // its own monkey-patching, and the assumption is that its monkey patches will apply on top of our own.\n    // If we _don't_ eagerly monkey-patch, then APIs like `element.appendChild` could end up calling through\n    // directly to the native DOM APIs instead, which would bypass synthetic custom element lifecycle\n    // and cause rendering/`connectedCallback`/`disconnectedCallback` not to fire.\n    // In prod mode, we avoid global patching as a slight perf optimization and because it's good practice\n    // in general to avoid global patching.\n    // See issue #4242 for details.\n    monkeyPatchDomAPIs();\n}\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly\n * difference that in the options, you can pass the `is` property set to a Constructor instead of\n * just a string value. The intent is to allow the creation of an element controlled by LWC without\n * having to register the element as a custom element.\n *\n * NOTE: The returned type incorrectly includes _all_ properties defined on the component class,\n * even though the runtime object only uses those decorated with `@api`. This is due to a\n * limitation of TypeScript. To avoid inferring incorrect properties, provide an explicit generic\n * parameter, e.g. `createElement<typeof LightningElement>('x-foo', { is: FooCtor })`.\n * @param sel The tagname of the element to create\n * @param options Control the behavior of the created element\n * @param options.is The LWC component that the element should be\n * @param options.mode What kind of shadow root to use\n * @returns The created HTML element\n * @throws Throws when called with invalid parameters.\n * @example\n * const el = createElement('x-foo', { is: FooCtor });\n */\nfunction createElement(sel, options) {\n    if (!isObject(options) || isNull(options)) {\n        throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${toString(options)}\".`);\n    }\n    const Ctor = options.is;\n    if (!isFunction$1(Ctor)) {\n        throw new TypeError(`\"createElement\" function expects an \"is\" option with a valid component constructor.`);\n    }\n    const { createCustomElement } = renderer;\n    // tagName must be all lowercase, unfortunately, we have legacy code that is\n    // passing `sel` as a camel-case, which makes them invalid custom elements name\n    // the following line guarantees that this does not leaks beyond this point.\n    const tagName = StringToLowerCase.call(sel);\n    const useNativeCustomElementLifecycle = !lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE;\n    const isFormAssociated = shouldBeFormAssociated(Ctor);\n    // the custom element from the registry is expecting an upgrade callback\n    /*\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    const upgradeCallback = (elm) => {\n        createVM(elm, Ctor, renderer, {\n            tagName,\n            mode: options.mode !== 'closed' ? 'open' : 'closed',\n            owner: null,\n        });\n        if (!useNativeCustomElementLifecycle) {\n            // Monkey-patch on-demand, because `lwcRuntimeFlags.DISABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE` may be set to\n            // `true` lazily, after `@lwc/engine-dom` has finished initializing but before a component has rendered.\n            monkeyPatchDomAPIs();\n            ConnectingSlot.set(elm, connectRootElement);\n            DisconnectingSlot.set(elm, disconnectRootElement);\n        }\n    };\n    return createCustomElement(tagName, upgradeCallback, useNativeCustomElementLifecycle, isFormAssociated);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node = Node;\n/**\n * EXPERIMENTAL: The purpose of this function is to detect shadowed nodes. THIS API WILL BE REMOVED\n * ONCE LOCKER V1 IS NO LONGER SUPPORTED.\n * @param node Node to check\n * @returns `true` if the the node is shadowed\n * @example isNodeShadowed(document.querySelector('my-component'))\n */\nfunction isNodeShadowed(node) {\n    if (isFalse(node instanceof _Node)) {\n        return false;\n    }\n    // It's debatable whether shadow root instances should be considered as shadowed, but we keep\n    // this unchanged for legacy reasons (#1250).\n    if (node instanceof ShadowRoot) {\n        return false;\n    }\n    const rootNode = node.getRootNode();\n    // Handle the native case. We can return early here because an invariant of LWC is that\n    // synthetic roots cannot be descendants of native roots.\n    if (rootNode instanceof ShadowRoot &&\n        isFalse(hasOwnProperty$1.call(getPrototypeOf$1(rootNode), 'synthetic'))) {\n        return true;\n    }\n    // TODO [#1252]: Old behavior that is still used by some pieces of the platform. Manually\n    // inserted nodes without the `lwc:dom=manual` directive will be considered as global elements.\n    return renderer.isSyntheticShadowDefined && !isUndefined$1(node[KEY__SHADOW_RESOLVER]);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ComponentConstructorToCustomElementConstructorMap = new Map();\nfunction getCustomElementConstructor(Ctor) {\n    if (Ctor === LightningElement) {\n        throw new TypeError(`Invalid Constructor. LightningElement base class can't be claimed as a custom element.`);\n    }\n    let ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);\n    if (isUndefined$1(ce)) {\n        ce = buildCustomElementConstructor(Ctor);\n        ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);\n    }\n    return ce;\n}\n/**\n * This static getter builds a Web Component class from a LWC constructor so it can be registered\n * as a new element via customElements.define() at any given time.\n * @example\n * import Foo from 'ns/foo';\n * customElements.define('x-foo', Foo.CustomElementConstructor);\n * const elm = document.createElement('x-foo');\n */\ndefineProperty(LightningElement, 'CustomElementConstructor', {\n    get() {\n        return getCustomElementConstructor(this);\n    },\n});\nfreeze(LightningElement);\nseal(LightningElement.prototype);\n\n/*\n * Copyright (c) 2024, Salesforce, Inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Like @lwc/shared, but for DOM APIs\nconst ElementDescriptors = getOwnPropertyDescriptors(Element.prototype);\nElementDescriptors.attachShadow.value;\nElementDescriptors.shadowRoot.get;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction addEventListener(target, type, callback, options) {\n    target.addEventListener(type, callback, options);\n}\n\n/*\n * Copyright (c) 2023, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * Creates a context provider, given a wire adapter constructor.\n * @param adapter The wire adapter to create a context provider for.\n * @returns A new context provider.\n */\nfunction createContextProvider(adapter) {\n    return createContextProviderWithRegister(adapter, registerContextProvider);\n}\nfunction registerContextProvider(elm, adapterContextToken, onContextSubscription) {\n    addEventListener(elm, adapterContextToken, ((evt) => {\n        evt.stopImmediatePropagation();\n        const { setNewContext, setDisconnectedCallback } = evt;\n        onContextSubscription({\n            setNewContext,\n            setDisconnectedCallback,\n        });\n    }));\n}\n\nexport { LightningElement, profilerControl as __unstable__ProfilerControl, reportingControl as __unstable__ReportingControl, api$1 as api, deprecatedBuildCustomElementConstructor as buildCustomElementConstructor, createContextProvider, createElement, freezeTemplate, getComponentConstructor, getComponentDef, hydrateComponent, isComponentConstructor, isNodeShadowed as isNodeFromTemplate, parseFragment, parseSVGFragment, readonly, registerComponent, registerDecorators, registerTemplate, renderer, rendererFactory, sanitizeAttribute, setFeatureFlag, setFeatureFlagForTest, setHooks, setTrustedSignalSet, swapComponent, swapStyle, swapTemplate, track, unwrap, wire };\n/** version: 8.13.2 */\n//# sourceMappingURL=index.js.map\n",null],"names":[],"mappings":"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"}